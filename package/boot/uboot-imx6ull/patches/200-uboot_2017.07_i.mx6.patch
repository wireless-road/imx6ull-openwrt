diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx5/clock.c u-boot-imx6/arch/arm/cpu/armv7/mx5/clock.c
--- u-boot-2017.07/arch/arm/cpu/armv7/mx5/clock.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx5/clock.c	2018-08-27 21:35:36.634139837 +0300
@@ -911,6 +911,10 @@
 }
 #endif
 
+int get_pll3_clock(void)
+{
+	return decode_pll(mxc_plls[PLL3_CLOCK], MXC_HCLK);
+}
 /*
  * Dump some core clockes.
  */
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx5/Kconfig u-boot-imx6/arch/arm/cpu/armv7/mx5/Kconfig
--- u-boot-2017.07/arch/arm/cpu/armv7/mx5/Kconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx5/Kconfig	2018-08-27 21:35:36.634139837 +0300
@@ -58,6 +58,14 @@
 	bool "Support USB armory"
 	select MX53
 
+config TARGET_NITROGEN51_E
+	bool "Support Boundary Devices nitrogen51_e board"
+	select CPU_V7
+
+config TARGET_NITROGEN51_VM
+	bool "Support Boundary Devices nitrogen51_vm board"
+	select CPU_V7
+
 endchoice
 
 config SYS_SOC
@@ -65,6 +73,8 @@
 
 source "board/aries/m53evk/Kconfig"
 source "board/beckhoff/mx53cx9020/Kconfig"
+source "board/boundary/nitrogen51_e/Kconfig"
+source "board/boundary/nitrogen51_vm/Kconfig"
 source "board/freescale/mx51evk/Kconfig"
 source "board/freescale/mx53ard/Kconfig"
 source "board/freescale/mx53evk/Kconfig"
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx5/lowlevel_init.S u-boot-imx6/arch/arm/cpu/armv7/mx5/lowlevel_init.S
--- u-boot-2017.07/arch/arm/cpu/armv7/mx5/lowlevel_init.S	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx5/lowlevel_init.S	2018-08-27 21:35:36.634139837 +0300
@@ -13,38 +13,87 @@
 
 .section ".text.init", "x"
 
+.macro init_l1cc r_zero
+	mcr	p15, 0, \r_zero, c8, c7, 0	@ invalidate I + D TLBs
+	mcr	p15, 0, \r_zero, c2, c0, 2	@ TTB control register
+
+	mcr	p15, 2, \r_zero, c0, c0, 0
+	mrc	p15, 1, r0, c0, c0, 0
+
+	ldr	r1, =0x7fff
+	and	r2, r1, r0, lsr #13
+
+	ldr	r1, =0x3ff
+
+	and	r3, r1, r0, lsr #3	@ NumWays - 1
+	add	r2, r2, #1		@ NumSets
+
+	and	r0, r0, #0x7
+	add	r0, r0, #4		@ SetShift
+
+	clz	r1, r3			@ WayShift
+	add	r7, r3, #1		@ NumWays
+1:	sub	r2, r2, #1		@ NumSets--
+	mov	r3, r7			@ Temp = NumWays
+2:	subs	r3, r3, #1		@ Temp--
+	mov	r5, r3, lsl r1
+	mov	r6, r2, lsl r0
+	orr	r5, r5, r6
+@ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+	mcr	p15, 0, r5, c7, c6, 2
+	bgt	2b
+	cmp	r2, #0
+	bgt	1b
+	dsb
+	isb
+.endm
+
 .macro init_arm_erratum
 	/* ARM erratum ID #468414 */
 	mrc 15, 0, r1, c1, c0, 1
 	orr r1, r1, #(1 << 5)    /* enable L1NEON bit */
 	mcr 15, 0, r1, c1, c0, 1
+
+	/*
+	 * Workaround for arm errata #709718
+	 * ARM: Load and Store operations on the shared device memory
+	 * regions may not complete in program order
+	 */
+	/* Setup PRRR so device is always mapped to non-shared */
+	mrc p15, 0, r1, c10, c2, 0
+	bic r1, r1, #3 << 0x10
+	mcr p15, 0, r1, c10, c2, 0
+.endm
+
+.macro 	orr_mx51_tape2_or_lower	r_dest, value, r_zero
+#if defined(CONFIG_MX51)
+	ldr r0, =IIM_BASE_ADDR
+	ldr r0, [r0, #IIM_SREV]
+	cmp r0, #0x10		/* 0x10 is for TO3 */
+	orrlo \r_dest, \r_dest, #\value
+#endif
 .endm
 
 /*
  * L2CC Cache setup/invalidation/disable
  */
-.macro init_l2cc
+.macro init_l2cc r_zero
 	/* explicitly disable L2 cache */
 	mrc 15, 0, r0, c1, c0, 1
 	bic r0, r0, #0x2
-	mcr 15, 0, r0, c1, c0, 1
+	mcr 15, 0, r0, c1, c0, 1	/* Write Auxiliary Control Register */
 
 	/* reconfigure L2 cache aux control reg */
-	ldr r0, =0xC0 |			/* tag RAM */ \
-		 0x4 |			/* data RAM */ \
-		 1 << 24 |		/* disable write allocate delay */ \
-		 1 << 23 |		/* disable write allocate combine */ \
-		 1 << 22		/* disable write allocate */
-
-#if defined(CONFIG_MX51)
-	ldr r3, [r4, #ROM_SI_REV]
-	cmp r3, #0x10
+	mov r1, #0xC4			/* tag/data RAM */
+	orr r1, r1, #(1 << 24) |	/* disable write allocate delay */ \
+		 (1 << 23) |		/* disable write allocate combine */ \
+		 (1 << 22)		/* disable write allocate */
 
 	/* disable write combine for TO 2 and lower revs */
-	orrls r0, r0, #1 << 25
-#endif
+	orr_mx51_tape2_or_lower	r1, (1 << 25), \r_zero
 
-	mcr 15, 1, r0, c9, c0, 2
+	/* Write L2 Cache Auxiliary Control Register */
+	mcr 15, 1, r1, c9, c0, 2
 
 	/* enable L2 cache */
 	mrc 15, 0, r0, c1, c0, 1
@@ -53,20 +102,22 @@
 
 .endm /* init_l2cc */
 
-/* AIPS setup - Only setup MPROTx registers.
- * The PACR default values are good.*/
-.macro init_aips
+/* AIPS setup - setup MPROTx and PACR registers. */
+.macro init_aips r_zero, r_aips1, r_aips2
 	/*
 	 * Set all MPROTx to be non-bufferable, trusted for R/W,
 	 * not forced to user-mode.
 	 */
-	ldr r0, =AIPS1_BASE_ADDR
 	ldr r1, =0x77777777
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	ldr r0, =AIPS2_BASE_ADDR
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
+	str r1, [\r_aips1, #0x0]
+	str r1, [\r_aips1, #0x4]
+	str \r_zero, [\r_aips1, #0x40]
+	str \r_zero, [\r_aips1, #0x44]
+	str \r_zero, [\r_aips1, #0x48]
+	str \r_zero, [\r_aips1, #0x4c]
+	str \r_zero, [\r_aips1, #0x50]
+	str r1, [\r_aips2, #0x0]
+	str r1, [\r_aips2, #0x4]
 	/*
 	 * Clear the on and off peripheral modules Supervisor Protect bit
 	 * for SDMA to access them. Did not change the AIPS control registers
@@ -75,304 +126,263 @@
 .endm /* init_aips */
 
 /* M4IF setup */
-.macro init_m4if
+.macro init_m4if r_zero, r_m4if
 #ifdef CONFIG_MX51
 	/* VPU and IPU given higher priority (0x4)
 	 * IPU accesses with ID=0x1 given highest priority (=0xA)
 	 */
-	ldr r0, =M4IF_BASE_ADDR
-
 	ldr r1, =0x00000203
-	str r1, [r0, #0x40]
+	str r1, [\r_m4if, #0x40]
 
-	str r4, [r0, #0x44]
+	str \r_zero, [\r_m4if, #0x44]
 
 	ldr r1, =0x00120125
-	str r1, [r0, #0x9C]
+	str r1, [\r_m4if, #0x9C]
 
 	ldr r1, =0x001901A3
-	str r1, [r0, #0x48]
+	str r1, [\r_m4if, #0x48]
 
 #endif
 .endm /* init_m4if */
 
-.macro setup_pll pll, freq
-	ldr r0, =\pll
-	adr r2, W_DP_\freq
-	bl setup_pll_func
-.endm
-
-#define W_DP_OP		0
-#define W_DP_MFD	4
-#define W_DP_MFN	8
-
-setup_pll_func:
-	ldr r1, =0x00001232
-	str r1, [r0, #PLL_DP_CTL] /* Set DPLL ON (set UPEN bit): BRMO=1 */
-	mov r1, #0x2
-	str r1, [r0, #PLL_DP_CONFIG] /* Enable auto-restart AREN bit */
-
-	ldr r1, [r2, #W_DP_OP]
-	str r1, [r0, #PLL_DP_OP]
-	str r1, [r0, #PLL_DP_HFS_OP]
-
-	ldr r1, [r2, #W_DP_MFD]
-	str r1, [r0, #PLL_DP_MFD]
-	str r1, [r0, #PLL_DP_HFS_MFD]
-
-	ldr r1, [r2, #W_DP_MFN]
-	str r1, [r0, #PLL_DP_MFN]
-	str r1, [r0, #PLL_DP_HFS_MFN]
-
-	ldr r1, =0x00001232
-	str r1, [r0, #PLL_DP_CTL]
-1:	ldr r1, [r0, #PLL_DP_CTL]
-	ands r1, r1, #0x1
-	beq 1b
-
-	/* r10 saved upper lr */
-	mov pc, lr
-
-.macro setup_pll_errata pll, freq
-	ldr r2, =\pll
-	str r4, [r2, #PLL_DP_CONFIG] /* Disable auto-restart AREN bit */
+.macro setup_pll_errata r_pll, freq
 	ldr r1, =0x00001236
-	str r1, [r2, #PLL_DP_CTL]    /* Restart PLL with PLM=1 */
-1:	ldr r1, [r2, #PLL_DP_CTL]    /* Wait for lock */
+	str r1, [\r_pll, #PLL_DP_CTL]    /* Restart PLL with PLM=1 */
+1:	ldr r1, [\r_pll, #PLL_DP_CTL]    /* Wait for lock */
 	ands r1, r1, #0x1
 	beq 1b
 
-	ldr r5, \freq
-	str r5, [r2, #PLL_DP_MFN]    /* Modify MFN value */
-	str r5, [r2, #PLL_DP_HFS_MFN]
+	ldr r1, =\freq
+	str r1, [\r_pll, #PLL_DP_MFN]    /* Modify MFN value */
+	str r1, [\r_pll, #PLL_DP_HFS_MFN]
 
 	mov r1, #0x1
-	str r1, [r2, #PLL_DP_CONFIG] /* Reload MFN value */
+	str r1, [\r_pll, #PLL_DP_CONFIG] /* Reload MFN value */
 
-2:	ldr r1, [r2, #PLL_DP_CONFIG]
+2:	ldr r1, [\r_pll, #PLL_DP_CONFIG]
 	tst r1, #1
 	bne 2b
 
 	ldr r1, =100		     /* Wait at least 4 us */
 3:	subs r1, r1, #1
 	bge 3b
+.endm
 
-	mov r1, #0x2
-	str r1, [r2, #PLL_DP_CONFIG] /* Enable auto-restart AREN bit */
+.macro pll_op_mfd_mfn r_pll, dp_op, dp_mfd, dp_mfn, dp_ctl
+	mov r0, #\dp_op
+	str r0, [\r_pll, #PLL_DP_OP]
+	str r0, [\r_pll, #PLL_DP_HFS_OP]
+
+	mov r0, #\dp_mfd
+	str r0, [\r_pll, #PLL_DP_MFD]
+	str r0, [\r_pll, #PLL_DP_HFS_MFD]
+
+	mov r0, #\dp_mfn
+	str r0, [\r_pll, #PLL_DP_MFN]
+	str r0, [\r_pll, #PLL_DP_HFS_MFN]
+
+	ldr r0, =\dp_ctl
+	str r0, [\r_pll, #PLL_DP_CTL] /* Set DPLL ON (set UPEN bit) */
+1:	ldr r0, [\r_pll, #PLL_DP_CTL]
+	tst r0, #0x1
+	beq 1b
 .endm
 
-.macro init_clock
-#if defined (CONFIG_MX51)
-	ldr r0, =CCM_BASE_ADDR
+.macro divisor_change_wait r_ccm
+	/* make sure divider effective */
+1:	ldr r0, [\r_ccm, #CLKCTL_CDHIPR]
+	cmp r0, #0x0
+	bne 1b
+.endm
+
+#define setup_pll(pll, freq) \
+		pll_op_mfd_mfn pll, DP_OP_##freq, DP_MFD_##freq, \
+		DP_MFN_##freq, DP_CTL_##freq
+
+#define setup_pll_(pll, freq) setup_pll(pll, freq)
+
+#ifndef CONFIG_SYS_PLL1_FREQ
+#define CONFIG_SYS_PLL1_FREQ 800
+#endif
+
+#ifndef CONFIG_SYS_DDR_CLKSEL
+#define CONFIG_SYS_DDR_CLKSEL 0
+#endif
+
+#define ARM_ICGC	0x14
+
+#ifdef CONFIG_MX51
+	/* Disable IPU and HSC handshake */
+#define IPU_HANDSHAKE_DISABLE	0x60000
+#define CCGR6_DISABLE_VAL	0x00000300
+#define CBCDR_VAL		0x19239145
+#define CBCMR_PER_PLL3		0x000010C0 | CONFIG_SYS_DDR_CLKSEL
+#define CBCMR_PER_PLL2		0x000020C0 | CONFIG_SYS_DDR_CLKSEL
+#define PLL3_TEMP_FREQ		665
+#define PLL2_FREQ		665
+#define ARM_ICGC_VAL		0x00000725
+#else
+	/* Disable IPU handshake */
+#define IPU_HANDSHAKE_DISABLE	(1<<21)
+#define CCGR6_DISABLE_VAL	0x0F00030F
+#define CBCDR_VAL		0x00888945
+#define CBCMR_PER_PLL3		0x00015154
+#define CBCMR_PER_PLL2		0x00016154
+#define PLL3_TEMP_FREQ	 	400
+#define PLL2_FREQ		400
+#define ARM_ICGC_VAL		0x00000124
+#endif
+
+.macro init_clock r_zero, r_ccm, r_pll1, r_pll2, r_pll3, r_pll4
+
+	mov r1, #IPU_HANDSHAKE_DISABLE
+	str r1, [\r_ccm, #CLKCTL_CCDR]
+
+	mov r1, #0x2000
+	sub r1, r1, #1			/* =0x1fff */
+	str r1, [\r_ccm,#CLKCTL_CCMR]	/* Turn on oscillator */
+
+1:	ldr r1, [\r_ccm, #CLKCTL_CSR]
+	and r1, r1, #0x22
+	cmp r1, #0x22			/* wait for Oscillator and FPM ready */
+	bne 1b
+
+/* disable auto restart */
+	str     \r_zero, [\r_pll1, #PLL_DP_CONFIG]
+	str     \r_zero, [\r_pll2, #PLL_DP_CONFIG]
+	str     \r_zero, [\r_pll3, #PLL_DP_CONFIG]
 
 	/* Gate of clocks to the peripherals first */
 	ldr r1, =0x3FFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r4, [r0, #CLKCTL_CCGR1]
-	str r4, [r0, #CLKCTL_CCGR2]
-	str r4, [r0, #CLKCTL_CCGR3]
+	str r1, [\r_ccm, #CLKCTL_CCGR0]
+	str \r_zero, [\r_ccm, #CLKCTL_CCGR1]
+	str \r_zero, [\r_ccm, #CLKCTL_CCGR2]
+	str \r_zero, [\r_ccm, #CLKCTL_CCGR3]
 
 	ldr r1, =0x00030000
-	str r1, [r0, #CLKCTL_CCGR4]
+	str r1, [\r_ccm, #CLKCTL_CCGR4]
 	ldr r1, =0x00FFF030
-	str r1, [r0, #CLKCTL_CCGR5]
-	ldr r1, =0x00000300
-	str r1, [r0, #CLKCTL_CCGR6]
-
-	/* Disable IPU and HSC dividers */
-	mov r1, #0x60000
-	str r1, [r0, #CLKCTL_CCDR]
+	str r1, [\r_ccm, #CLKCTL_CCGR5]
+	ldr r1, =CCGR6_DISABLE_VAL
+	str r1, [\r_ccm, #CLKCTL_CCGR6]
+#ifdef CONFIG_MX53
+	str \r_zero, [\r_ccm, #CLKCTL_CCGR7]
+#endif
 
+	ldr r3, =CBCDR_VAL
+#ifdef CONFIG_MX51
 	/* Make sure to switch the DDR away from PLL 1 */
-	ldr r1, =0x19239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	/* make sure divider effective */
-1:	ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
+	/* keep the initial ddr podf value */
+	ldr r2, [\r_ccm, #CLKCTL_CBCDR]
+	str r3, [\r_ccm, #CLKCTL_CBCDR]
+	divisor_change_wait \r_ccm
+#endif
 
-	/* Switch ARM to step clock */
+	/* Switch ARM to step clock (clock source 4) */
+	ldr r0, [\r_ccm, #CLKCTL_CCSR]
+	/* deselect step clock for glitch free update */
+	bic r0, r0, #4
+	str r0, [\r_ccm, #CLKCTL_CCSR]
+	/* select clock source 4 as source for step clock */
+	str \r_zero, [\r_ccm, #CLKCTL_CCSR]
+
+	/* switch arm to step clock */
 	mov r1, #0x4
-	str r1, [r0, #CLKCTL_CCSR]
+	str r1, [\r_ccm, #CLKCTL_CCSR]
 
 #if defined(CONFIG_MX51_PLL_ERRATA)
-	setup_pll PLL1_BASE_ADDR, 864
-	setup_pll_errata PLL1_BASE_ADDR, W_DP_MFN_800_DIT
+	setup_pll(\r_pll1, 864)
+	setup_pll_errata \r_pll1, DP_MFN_800_DIT
 #else
-	setup_pll PLL1_BASE_ADDR, 800
+	setup_pll_(\r_pll1, CONFIG_SYS_PLL1_FREQ)
 #endif
 
-	setup_pll PLL3_BASE_ADDR, 665
+	/* Switch ARM back to PLL 1 */
+	str \r_zero, [\r_ccm, #CLKCTL_CCSR]
+	setup_pll_(\r_pll3, PLL3_TEMP_FREQ)
 
 	/* Switch peripheral to PLL 3 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x000010C0 | CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
-	ldr r1, =0x13239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	setup_pll PLL2_BASE_ADDR, 665
+	ldr r1, =CBCMR_PER_PLL3
+	str r1, [\r_ccm, #CLKCTL_CBCMR]
+	/* [25] 0 -> 1 (periph was pll2, now apm) */
+	orr r1, r3, #1<<25
+	str r1, [\r_ccm, #CLKCTL_CBCDR]
+	divisor_change_wait \r_ccm
+
+	setup_pll_(\r_pll2, PLL2_FREQ)
 
 	/* Switch peripheral to PLL2 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x19239145
-	str r1, [r0, #CLKCTL_CBCDR]
-	ldr r1, =0x000020C0 | CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
+	/* [25] 1 -> 0 (periph was apm, now pll2) */
+	str r3, [\r_ccm, #CLKCTL_CBCDR]
 
-	setup_pll PLL3_BASE_ADDR, 216
+	ldr r1, =CBCMR_PER_PLL2
+	str r1, [\r_ccm, #CLKCTL_CBCMR]
 
+	setup_pll(\r_pll3, 216)
+#ifdef CONFIG_MX53
+	setup_pll(\r_pll4, 455)
+#endif
 	/* Set the platform clock dividers */
 	ldr r0, =ARM_BASE_ADDR
-	ldr r1, =0x00000725
-	str r1, [r0, #0x14]
-
-	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =ARM_ICGC_VAL
+	str r1, [r0, #ARM_ICGC]
 
+	mov r1, #0
 	/* Run 3.0 at Full speed, for other TO's wait till we increase VDDGP */
-	ldr r3, [r4, #ROM_SI_REV]
-	cmp r3, #0x10
-	movls r1, #0x1
-	movhi r1, #0
-
-	str r1, [r0, #CLKCTL_CACRR]
-
-	/* Switch ARM back to PLL 1 */
-	str r4, [r0, #CLKCTL_CCSR]
+	orr_mx51_tape2_or_lower	r1, 1, \r_zero
+	str r1, [\r_ccm, #CLKCTL_CACRR]
 
+#ifdef CONFIG_MX51
 	/* setup the rest */
 	/* Use lp_apm (24MHz) source for perclk */
 	ldr r1, =0x000020C2 | CONFIG_SYS_DDR_CLKSEL
-	str r1, [r0, #CLKCTL_CBCMR]
+	str r1, [\r_ccm, #CLKCTL_CBCMR]
 	/* ddr clock from PLL 1, all perclk dividers are 1 since using 24MHz */
-	ldr r1, =CONFIG_SYS_CLKTL_CBCDR
-	str r1, [r0, #CLKCTL_CBCDR]
-
-	/* Restore the default values in the Gate registers */
-	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r1, [r0, #CLKCTL_CCGR1]
-	str r1, [r0, #CLKCTL_CCGR2]
-	str r1, [r0, #CLKCTL_CCGR3]
-	str r1, [r0, #CLKCTL_CCGR4]
-	str r1, [r0, #CLKCTL_CCGR5]
-	str r1, [r0, #CLKCTL_CCGR6]
+	ldr r1, =(CONFIG_SYS_CLKTL_CBCDR & ~(7 << 27))
+	/* keep the initial ddr podf value */
+	and r2, r2, #(7 << 27)
+	orr r1, r1, r2
+	str r1, [\r_ccm, #CLKCTL_CBCDR]
 
 	/* Use PLL 2 for UART's, get 66.5MHz from it */
 	ldr r1, =0xA5A2A020
-	str r1, [r0, #CLKCTL_CSCMR1]
+	str r1, [\r_ccm, #CLKCTL_CSCMR1]
 	ldr r1, =0x00C30321
-	str r1, [r0, #CLKCTL_CSCDR1]
-	/* make sure divider effective */
-1:	ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-	str r4, [r0, #CLKCTL_CCDR]
-
-	/* for cko - for ARM div by 8 */
-	mov r1, #0x000A0000
-	add r1, r1, #0x00000F0
-	str r1, [r0, #CLKCTL_CCOSR]
-#else	/* CONFIG_MX53 */
-	ldr r0, =CCM_BASE_ADDR
-
-	/* Gate of clocks to the peripherals first */
-	ldr r1, =0x3FFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r4, [r0, #CLKCTL_CCGR1]
-	str r4, [r0, #CLKCTL_CCGR2]
-	str r4, [r0, #CLKCTL_CCGR3]
-	str r4, [r0, #CLKCTL_CCGR7]
-	ldr r1, =0x00030000
-	str r1, [r0, #CLKCTL_CCGR4]
-	ldr r1, =0x00FFF030
-	str r1, [r0, #CLKCTL_CCGR5]
-	ldr r1, =0x0F00030F
-	str r1, [r0, #CLKCTL_CCGR6]
-
-	/* Switch ARM to step clock */
-	mov r1, #0x4
-	str r1, [r0, #CLKCTL_CCSR]
-
-	setup_pll PLL1_BASE_ADDR, 800
-
-	setup_pll PLL3_BASE_ADDR, 400
-
-	/* Switch peripheral to PLL3 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x00015154
-	str r1, [r0, #CLKCTL_CBCMR]
-	ldr r1, =0x02898945
-	str r1, [r0, #CLKCTL_CBCDR]
-	/* make sure change is effective */
-1:      ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-	setup_pll PLL2_BASE_ADDR, 400
-
-	/* Switch peripheral to PLL2 */
-	ldr r0, =CCM_BASE_ADDR
-	ldr r1, =0x00888945
-	str r1, [r0, #CLKCTL_CBCDR]
-
-	ldr r1, =0x00016154
-	str r1, [r0, #CLKCTL_CBCMR]
-
-	/*change uart clk parent to pll2*/
-	ldr r1, [r0, #CLKCTL_CSCMR1]
-	and r1, r1, #0xfcffffff
-	orr r1, r1, #0x01000000
-	str r1, [r0, #CLKCTL_CSCMR1]
-
-	/* make sure change is effective */
-1:      ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-	setup_pll PLL3_BASE_ADDR, 216
-
-	setup_pll PLL4_BASE_ADDR, 455
-
-	/* Set the platform clock dividers */
-	ldr r0, =ARM_BASE_ADDR
-	ldr r1, =0x00000124
-	str r1, [r0, #0x14]
-
-	ldr r0, =CCM_BASE_ADDR
-	mov r1, #0
-	str r1, [r0, #CLKCTL_CACRR]
-
-	/* Switch ARM back to PLL 1. */
-	mov r1, #0x0
-	str r1, [r0, #CLKCTL_CCSR]
-
-	/* make uart div=6 */
-	ldr r1, [r0, #CLKCTL_CSCDR1]
-	and r1, r1, #0xffffffc0
-	orr r1, r1, #0x0a
-	str r1, [r0, #CLKCTL_CSCDR1]
+	str r1, [\r_ccm, #CLKCTL_CSCDR1]
+#else
+	/* change uart clk parent to pll2 */
+	ldr	r1, [\r_ccm, #CLKCTL_CSCMR1]
+	and	r1, r1, #0xfcffffff
+	orr	r1, r1, #0x01000000
+	str	r1, [\r_ccm, #CLKCTL_CSCMR1]
+
+	/* make uart div = 6 */
+	ldr	r1, [\r_ccm, #CLKCTL_CSCDR1]
+	and	r1, r1, #0xffffffc0
+	orr	r1, r1, #0x0a
+	str	r1, [\r_ccm, #CLKCTL_CSCDR1]
+#endif
+	divisor_change_wait \r_ccm
 
 	/* Restore the default values in the Gate registers */
 	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r1, [r0, #CLKCTL_CCGR1]
-	str r1, [r0, #CLKCTL_CCGR2]
-	str r1, [r0, #CLKCTL_CCGR3]
-	str r1, [r0, #CLKCTL_CCGR4]
-	str r1, [r0, #CLKCTL_CCGR5]
-	str r1, [r0, #CLKCTL_CCGR6]
-	str r1, [r0, #CLKCTL_CCGR7]
+	str r1, [\r_ccm, #CLKCTL_CCGR0]
+	str r1, [\r_ccm, #CLKCTL_CCGR1]
+	str r1, [\r_ccm, #CLKCTL_CCGR2]
+	str r1, [\r_ccm, #CLKCTL_CCGR3]
+	str r1, [\r_ccm, #CLKCTL_CCGR4]
+	str r1, [\r_ccm, #CLKCTL_CCGR5]
+	str r1, [\r_ccm, #CLKCTL_CCGR6]
+#ifdef CONFIG_MX53
+	str	r1, [\r_ccm, #CLKCTL_CCGR7]
+#endif
 
-	mov r1, #0x00000
-	str r1, [r0, #CLKCTL_CCDR]
+	str \r_zero, [\r_ccm, #CLKCTL_CCDR]
 
 	/* for cko - for ARM div by 8 */
 	mov r1, #0x000A0000
 	add r1, r1, #0x00000F0
-	str r1, [r0, #CLKCTL_CCOSR]
-
-#endif	/* CONFIG_MX53 */
+	str r1, [\r_ccm, #CLKCTL_CCOSR]
 .endm
 
 ENTRY(lowlevel_init)
@@ -391,39 +401,24 @@
 
 	init_arm_erratum
 
-	init_l2cc
-
-	init_aips
-
-	init_m4if
+	init_l1cc r4
+	init_l2cc r4
 
-	init_clock
+	ldr r5, =AIPS1_BASE_ADDR
+	ldr r6, =AIPS2_BASE_ADDR
+	init_aips r4, r5, r6
+
+	ldr r5, =M4IF_BASE_ADDR
+	init_m4if r4, r5
+
+	ldr r5, =CCM_BASE_ADDR
+	ldr r6, =PLL1_BASE_ADDR
+	ldr r7, =PLL2_BASE_ADDR
+	ldr r8, =PLL3_BASE_ADDR
+#ifdef CONFIG_MX53
+	ldr r9, =PLL4_BASE_ADDR
+#endif
+	init_clock r4, r5, r6, r7, r8, r9
 
 	mov pc, r10
 ENDPROC(lowlevel_init)
-
-/* Board level setting value */
-#if defined(CONFIG_MX51_PLL_ERRATA)
-W_DP_864:		.word DP_OP_864
-			.word DP_MFD_864
-			.word DP_MFN_864
-W_DP_MFN_800_DIT:	.word DP_MFN_800_DIT
-#else
-W_DP_800:		.word DP_OP_800
-			.word DP_MFD_800
-			.word DP_MFN_800
-#endif
-#if defined(CONFIG_MX51)
-W_DP_665:		.word DP_OP_665
-			.word DP_MFD_665
-			.word DP_MFN_665
-#endif
-W_DP_216:		.word DP_OP_216
-			.word DP_MFD_216
-			.word DP_MFN_216
-W_DP_400:               .word DP_OP_400
-			.word DP_MFD_400
-			.word DP_MFN_400
-W_DP_455:               .word DP_OP_455
-			.word DP_MFD_455
-			.word DP_MFN_455
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx5/soc.c u-boot-imx6/arch/arm/cpu/armv7/mx5/soc.c
--- u-boot-2017.07/arch/arm/cpu/armv7/mx5/soc.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx5/soc.c	2018-08-27 21:35:36.634139837 +0300
@@ -24,30 +24,28 @@
 {
 #ifdef CONFIG_MX51
 	int system_rev = 0x51000;
-#else
-	int system_rev = 0x53000;
-#endif
-	int reg = __raw_readl(ROM_SI_REV);
+	int reg = readl(&((struct iim_regs *)IIM_BASE_ADDR)->srev);
 
-#if defined(CONFIG_MX51)
-	switch (reg) {
-	case 0x02:
-		system_rev |= CHIP_REV_1_1;
-		break;
-	case 0x10:
-		if ((__raw_readl(GPIO1_BASE_ADDR + 0x0) & (0x1 << 22)) == 0)
-			system_rev |= CHIP_REV_2_5;
-		else
-			system_rev |= CHIP_REV_2_0;
-		break;
-	case 0x20:
+	if (reg >= 0x10) {
 		system_rev |= CHIP_REV_3_0;
-		break;
-	default:
-		system_rev |= CHIP_REV_1_0;
-		break;
+	} else {
+		reg = __raw_readl(ROM_SI_REV);
+		if (reg >= 0x10) {
+			/* Why read from UART3_RXD, surely this is board specific ? */
+			if ((__raw_readl(GPIO1_BASE_ADDR + 0x0) & (0x1 << 22)) == 0)
+				system_rev |= CHIP_REV_2_5;
+			else
+				system_rev |= CHIP_REV_2_0;
+		} else if (reg >= 0x02) {
+			system_rev |= CHIP_REV_1_1;
+		} else {
+			system_rev |= CHIP_REV_1_0;
+		}
 	}
 #else
+	int system_rev = 0x53000;
+	int reg = __raw_readl(ROM_SI_REV);
+
 	if (reg < 0x20)
 		system_rev |= CHIP_REV_1_0;
 	else
@@ -80,8 +78,11 @@
 	struct fuse_bank1_regs *fuse =
 			(struct fuse_bank1_regs *)bank->fuse_regs;
 
+#ifndef CONFIG_IIM_MAC_ADDR_INDEX
+#define CONFIG_IIM_MAC_ADDR_INDEX 0
+#endif
 	for (i = 0; i < 6; i++)
-		mac[i] = readl(&fuse->mac_addr[i]) & 0xff;
+		mac[i] = readl(&fuse->mac_addr[i + CONFIG_IIM_MAC_ADDR_INDEX]) & 0xff;
 }
 #endif
 
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx6/Kconfig u-boot-imx6/arch/arm/cpu/armv7/mx6/Kconfig
--- u-boot-2017.07/arch/arm/cpu/armv7/mx6/Kconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx6/Kconfig	2018-08-27 21:35:36.634139837 +0300
@@ -292,6 +292,115 @@
 	select DM
 	select DM_THERMAL
 
+config TARGET_A
+	bool "a"
+
+config TARGET_ACL
+	bool "acl"
+
+config TARGET_AP
+	bool "ap"
+
+config TARGET_ASH
+	bool "ash"
+
+config TARGET_ASH2
+	bool "ash2"
+
+config TARGET_BT
+	bool "bt"
+
+config TARGET_BT2
+	bool "bt2"
+
+config TARGET_CAD
+	bool "cad"
+
+config TARGET_CID
+	bool "cid"
+
+config TARGET_CID_TAB
+	bool "cid_tab"
+
+config TARGET_CNT
+	bool "cnt"
+
+config TARGET_COB
+	bool "cob"
+
+config TARGET_COB2
+	bool "cob2"
+
+config TARGET_DASH
+	bool "dash"
+
+config TARGET_EO
+	bool "eo"
+
+config TARGET_H
+	bool "h"
+
+config TARGET_H4
+	bool "h4"
+
+config TARGET_HL
+	bool "hl"
+
+config TARGET_HP
+	bool "hp"
+
+config TARGET_INSP
+	bool "insp"
+
+config TARGET_IOC
+	bool "ioc"
+
+config TARGET_JLM
+	bool "jlm"
+
+config TARGET_LS
+	bool "ls"
+
+config TARGET_LSHORE
+	bool "lshore"
+
+config TARGET_LTCH
+	bool "ltch"
+
+config TARGET_MCS
+	bool "mcs"
+
+config TARGET_MED
+	bool "med"
+
+config TARGET_MTP
+	bool "mtp"
+
+config TARGET_MX6_R
+	bool "mx6_r"
+
+config TARGET_NEOL
+	bool "neol"
+
+config TARGET_NIT6XLITE
+	bool "nit6xlite"
+
+config TARGET_NITROGEN6_MAX
+	bool "nitrogen6_max"
+
+config TARGET_NITROGEN6_SCM
+	bool "nitrogen6_scm"
+
+config TARGET_NITROGEN6_SOM2
+	bool "nitrogen6_som2"
+
+config TARGET_NITROGEN6_VM
+	bool "nitrogen6_vm"
+
+config TARGET_NITROGEN6SX
+	bool "nitrogen6sx"
+	select MX6SX
+
 config TARGET_NITROGEN6X
 	bool "nitrogen6x"
 
@@ -299,6 +408,49 @@
 	bool "Armadeus OPOS6ULDev board"
 	select MX6UL_OPOS6UL
 
+config TARGET_NW
+	bool "nw"
+
+config TARGET_OC
+	bool "oc"
+
+config TARGET_PER
+	bool "per"
+
+config TARGET_RC
+	bool "rc"
+
+config TARGET_S
+	bool "s"
+
+config TARGET_SES
+	bool "ses"
+
+config TARGET_SNAP
+	bool "snap"
+
+config TARGET_SP
+	bool "sp"
+
+config TARGET_TA
+	bool "ta"
+
+config TARGET_USD
+	bool "usd"
+
+config TARGET_USD_MR2
+	bool "usd_mr2"
+
+config TARGET_UTC
+	bool "utc"
+
+config TARGET_VP
+	bool "vp"
+
+config TARGET_YS
+	bool "ys"
+	select MX6SX
+
 config TARGET_OT1200
 	bool "Bachmann OT1200"
 	select SUPPORT_SPL
@@ -401,7 +553,57 @@
 source "board/bachmann/ot1200/Kconfig"
 source "board/barco/platinum/Kconfig"
 source "board/barco/titanium/Kconfig"
+source "board/boundary/a/Kconfig"
+source "board/boundary/acl/Kconfig"
+source "board/boundary/ap/Kconfig"
+source "board/boundary/ash/Kconfig"
+source "board/boundary/ash2/Kconfig"
+source "board/boundary/bt/Kconfig"
+source "board/boundary/bt2/Kconfig"
+source "board/boundary/cad/Kconfig"
+source "board/boundary/cid/Kconfig"
+source "board/boundary/cid_tab/Kconfig"
+source "board/boundary/cnt/Kconfig"
+source "board/boundary/cob/Kconfig"
+source "board/boundary/cob2/Kconfig"
+source "board/boundary/dash/Kconfig"
+source "board/boundary/eo/Kconfig"
+source "board/boundary/h/Kconfig"
+source "board/boundary/h4/Kconfig"
+source "board/boundary/hl/Kconfig"
+source "board/boundary/hp/Kconfig"
+source "board/boundary/insp/Kconfig"
+source "board/boundary/ioc/Kconfig"
+source "board/boundary/jlm/Kconfig"
+source "board/boundary/ls/Kconfig"
+source "board/boundary/lshore/Kconfig"
+source "board/boundary/ltch/Kconfig"
+source "board/boundary/mcs/Kconfig"
+source "board/boundary/med/Kconfig"
+source "board/boundary/mtp/Kconfig"
+source "board/boundary/mx6_r/Kconfig"
+source "board/boundary/neol/Kconfig"
+source "board/boundary/nit6xlite/Kconfig"
+source "board/boundary/nitrogen6_max/Kconfig"
+source "board/boundary/nitrogen6_scm/Kconfig"
+source "board/boundary/nitrogen6_som2/Kconfig"
+source "board/boundary/nitrogen6_vm/Kconfig"
+source "board/boundary/nitrogen6sx/Kconfig"
 source "board/boundary/nitrogen6x/Kconfig"
+source "board/boundary/nw/Kconfig"
+source "board/boundary/oc/Kconfig"
+source "board/boundary/per/Kconfig"
+source "board/boundary/rc/Kconfig"
+source "board/boundary/s/Kconfig"
+source "board/boundary/ses/Kconfig"
+source "board/boundary/snap/Kconfig"
+source "board/boundary/sp/Kconfig"
+source "board/boundary/ta/Kconfig"
+source "board/boundary/usd/Kconfig"
+source "board/boundary/usd_mr2/Kconfig"
+source "board/boundary/utc/Kconfig"
+source "board/boundary/vp/Kconfig"
+source "board/boundary/ys/Kconfig"
 source "board/ccv/xpress/Kconfig"
 source "board/compulab/cm_fx6/Kconfig"
 source "board/congatec/cgtqmx6eval/Kconfig"
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx6/soc.c u-boot-imx6/arch/arm/cpu/armv7/mx6/soc.c
--- u-boot-2017.07/arch/arm/cpu/armv7/mx6/soc.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx6/soc.c	2018-08-27 21:35:36.634139837 +0300
@@ -432,6 +432,9 @@
 	mxs_dma_init();
 #endif
 
+	if (is_mx6dqp())
+		writel(0x80000201, 0xbb0608);
+
 	init_src();
 
 	return 0;
@@ -505,37 +508,42 @@
 	return 0;
 }
 
-#if defined(CONFIG_FEC_MXC)
+#if defined(CONFIG_FEC_MXC) || defined(CONFIG_FEC_MAC_FUSE)
 void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
 {
 	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
 	struct fuse_bank *bank = &ocotp->bank[4];
 	struct fuse_bank4_regs *fuse =
 			(struct fuse_bank4_regs *)bank->fuse_regs;
+	u32 value_high, value_low;
 
 	if ((is_mx6sx() || is_mx6ul() || is_mx6ull()) && dev_id == 1) {
-		u32 value = readl(&fuse->mac_addr2);
-		mac[0] = value >> 24 ;
-		mac[1] = value >> 16 ;
-		mac[2] = value >> 8 ;
-		mac[3] = value ;
-
-		value = readl(&fuse->mac_addr1);
-		mac[4] = value >> 24 ;
-		mac[5] = value >> 16 ;
-		
-	} else {
-		u32 value = readl(&fuse->mac_addr1);
-		mac[0] = (value >> 8);
-		mac[1] = value ;
-
-		value = readl(&fuse->mac_addr0);
-		mac[2] = value >> 24 ;
-		mac[3] = value >> 16 ;
-		mac[4] = value >> 8 ;
-		mac[5] = value ;
+		value_high = readl(&fuse->mac_addr2);
+		value_low = readl(&fuse->mac_addr1) >> 16;
+
+		value_low |= (value_high << 16);
+		value_high >>= 16;
+		if (value_low | value_high) {
+			dev_id--;
+			goto valid;
+		}
 	}
 
+	value_high = readl(&fuse->mac_addr1);
+	value_low = readl(&fuse->mac_addr0);
+valid:
+	if ((dev_id > 0) && (value_low | value_high)) {
+		u32 prev = value_low;
+		value_low += dev_id;
+		if (value_low < prev)
+			value_high++;
+	}
+	mac[0] = (value_high >> 8);
+	mac[1] = value_high ;
+	mac[2] = value_low >> 24 ;
+	mac[3] = value_low >> 16 ;
+	mac[4] = value_low >> 8 ;
+	mac[5] = value_low ;
 }
 #endif
 
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx7/clock.c u-boot-imx6/arch/arm/cpu/armv7/mx7/clock.c
--- u-boot-2017.07/arch/arm/cpu/armv7/mx7/clock.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx7/clock.c	2018-08-27 21:35:36.634139837 +0300
@@ -850,17 +850,37 @@
 	return 1;
 }
 
-int set_clk_qspi(void)
+int set_clk_qspi(u32 freq)
 {
 	u32 target;
+	u32 div, pre, post;
+	u32 best = 64 * 8;
+	u32 best_pre = 8;
+	u32 best_post = 64;
 
 	/* disable the clock gate first */
 	clock_enable(CCGR_QSPI, 0);
+	if (!freq)
+		return 0;
+
+
+	target = ((392000000/4 - 1)/ freq) + 1;
+	for (pre = 1; pre <= 8; pre++) {
+		post = ((target - 1)/ pre) + 1;
+		if (post > 64)
+			continue;
+		div = pre * post;
+		if (best >= div) {
+			best = div;
+			best_pre = pre;
+			best_post = post;
+		}
+	}
 
 	/* 49M: 392/2/4 */
 	target = CLK_ROOT_ON | QSPI_CLK_ROOT_FROM_PLL_SYS_PFD4_CLK |
-		 CLK_ROOT_PRE_DIV(CLK_ROOT_PRE_DIV1) |
-		 CLK_ROOT_POST_DIV(CLK_ROOT_POST_DIV2);
+		 CLK_ROOT_PRE_DIV(best_pre - 1) |
+		 CLK_ROOT_POST_DIV(best_post - 1);
 	clock_set_target_val(QSPI_CLK_ROOT, target);
 
 	/* enable the clock gate */
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx7/Kconfig u-boot-imx6/arch/arm/cpu/armv7/mx7/Kconfig
--- u-boot-2017.07/arch/arm/cpu/armv7/mx7/Kconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx7/Kconfig	2018-08-27 21:35:36.634139837 +0300
@@ -46,11 +46,18 @@
 	select DM_SERIAL
 	select DM_THERMAL
 
+config TARGET_NITROGEN7
+	bool "nitrogen7"
+	select CPU_V7
+	select DM
+	select DM_THERMAL
+
 endchoice
 
 config SYS_SOC
 	default "mx7"
 
+source "board/boundary/nitrogen7/Kconfig"
 source "board/freescale/mx7dsabresd/Kconfig"
 source "board/technexion/pico-imx7d/Kconfig"
 source "board/toradex/colibri_imx7/Kconfig"
diff -Nru u-boot-2017.07/arch/arm/cpu/armv7/mx7/soc.c u-boot-imx6/arch/arm/cpu/armv7/mx7/soc.c
--- u-boot-2017.07/arch/arm/cpu/armv7/mx7/soc.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/cpu/armv7/mx7/soc.c	2018-08-27 21:35:36.634139837 +0300
@@ -285,28 +285,35 @@
 	struct fuse_bank *bank = &ocotp->bank[9];
 	struct fuse_bank9_regs *fuse =
 		(struct fuse_bank9_regs *)bank->fuse_regs;
+	u32 value_high, value_low;
 
-	if (0 == dev_id) {
-		u32 value = readl(&fuse->mac_addr1);
-		mac[0] = (value >> 8);
-		mac[1] = value;
-
-		value = readl(&fuse->mac_addr0);
-		mac[2] = value >> 24;
-		mac[3] = value >> 16;
-		mac[4] = value >> 8;
-		mac[5] = value;
-	} else {
-		u32 value = readl(&fuse->mac_addr2);
-		mac[0] = value >> 24;
-		mac[1] = value >> 16;
-		mac[2] = value >> 8;
-		mac[3] = value;
-
-		value = readl(&fuse->mac_addr1);
-		mac[4] = value >> 24;
-		mac[5] = value >> 16;
+	if (dev_id == 1) {
+		value_high = readl(&fuse->mac_addr2);
+		value_low = readl(&fuse->mac_addr1) >> 16;
+
+		value_low |= (value_high << 16);
+		value_high >>= 16;
+		if (value_low | value_high) {
+			dev_id--;
+			goto valid;
+		}
 	}
+
+	value_high = readl(&fuse->mac_addr1);
+	value_low = readl(&fuse->mac_addr0);
+valid:
+	if ((dev_id > 0) && (value_low | value_high)) {
+		u32 prev = value_low;
+		value_low += dev_id;
+		if (value_low < prev)
+			value_high++;
+	}
+	mac[0] = (value_high >> 8);
+	mac[1] = value_high ;
+	mac[2] = value_low >> 24 ;
+	mac[3] = value_low >> 16 ;
+	mac[4] = value_low >> 8 ;
+	mac[5] = value_low ;
 }
 #endif
 
@@ -371,13 +378,16 @@
  * to SBMR1, which will determine the boot device.
  */
 const struct boot_mode soc_boot_modes[] = {
+	{"normal",	MAKE_CFGVAL(0x00, 0x00, 0x00, 0x00)},
+	/* reserved value should start rom usb */
+	{"usb",		MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00)},
 	{"ecspi1:0",	MAKE_CFGVAL(0x00, 0x60, 0x00, 0x00)},
-	{"ecspi1:1",	MAKE_CFGVAL(0x40, 0x62, 0x00, 0x00)},
-	{"ecspi1:2",	MAKE_CFGVAL(0x80, 0x64, 0x00, 0x00)},
-	{"ecspi1:3",	MAKE_CFGVAL(0xc0, 0x66, 0x00, 0x00)},
+	{"ecspi1:1",	MAKE_CFGVAL(0x40, 0x60, 0x00, 0x00)},
+	{"ecspi1:2",	MAKE_CFGVAL(0x80, 0x60, 0x00, 0x00)},
+	{"ecspi1:3",	MAKE_CFGVAL(0xc0, 0x60, 0x00, 0x00)},
 
 	{"weim",	MAKE_CFGVAL(0x00, 0x50, 0x00, 0x00)},
-	{"qspi1",	MAKE_CFGVAL(0x10, 0x40, 0x00, 0x00)},
+	{"qspi1",	MAKE_CFGVAL(0x00, 0x40, 0x00, 0x00)},
 	/* 4 bit bus width */
 	{"usdhc1",	MAKE_CFGVAL(0x10, 0x10, 0x00, 0x00)},
 	{"usdhc2",	MAKE_CFGVAL(0x10, 0x14, 0x00, 0x00)},
diff -Nru u-boot-2017.07/arch/arm/imx-common/cache.c u-boot-imx6/arch/arm/imx-common/cache.c
--- u-boot-2017.07/arch/arm/imx-common/cache.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/cache.c	2018-08-27 21:35:36.684139600 +0300
@@ -86,6 +86,9 @@
 
 #ifndef CONFIG_MX6Q
 	val |= 0x40800000;
+#else
+	if (is_mx6dqp())
+		val |= 0x40800000;
 #endif
 	writel(val, &pl310->pl310_prefetch_ctrl);
 
diff -Nru u-boot-2017.07/arch/arm/imx-common/cpu.c u-boot-imx6/arch/arm/imx-common/cpu.c
--- u-boot-2017.07/arch/arm/imx-common/cpu.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/cpu.c	2018-08-27 21:35:36.684139600 +0300
@@ -37,6 +37,14 @@
 	writel(cause, &src_regs->srsr);
 	reset_cause = cause;
 
+#ifdef CONFIG_RESET_CAUSE_ADDR
+	{
+		unsigned *p = (unsigned *)CONFIG_RESET_CAUSE_ADDR;
+		*p++ = 0x12345678;	/* magic value to check for */
+		*p = cause;
+	}
+#endif
+
 	switch (cause) {
 	case 0x00001:
 	case 0x00011:
@@ -241,7 +249,7 @@
 {
 	int rc = -ENODEV;
 
-#if defined(CONFIG_FEC_MXC)
+#if defined(CONFIG_FEC_MXC) && defined(CONFIG_FEC_MXC_PHYADDR)
 	rc = fecmxc_initialize(bis);
 #endif
 
diff -Nru u-boot-2017.07/arch/arm/imx-common/fbpanel.c u-boot-imx6/arch/arm/imx-common/fbpanel.c
--- u-boot-2017.07/arch/arm/imx-common/fbpanel.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/fbpanel.c	2018-08-27 21:35:36.684139600 +0300
@@ -0,0 +1,1461 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#if !defined(CONFIG_MX51) && !defined(CONFIG_MX53) && !defined(CONFIG_MX7D)
+#include <asm/arch/mxc_hdmi.h>
+#endif
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/io.h>
+#include <div64.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <video_fb.h>
+/*
+ * This creates commands strings to work on dtb files.
+ * i.e. if you define the following environment variables
+ *
+ * setenv fb_hdmi 1920x1080M@60
+ * setenv fb_lcd *off
+ * setenv fb_lvds lg1280x800
+ *
+ * Note: the "*" means u-boot should enable this display, in this case none.
+ *
+ * you'll get the follow strings if cmd_frozen is not defined.
+ * cmd_hdmi=fdt set fb_hdmi status okay;fdt set fb_hdmi mode_str 1920x1080M@60;
+ *
+ * cmd_lcd=fdt set fb_lcd status disabled
+ *
+ * cmd_lvds=fdt set fb_lvds status okay;
+ * 	fdt set fb_lvds interface_pix_fmt RGB24;
+ * 	fdt set ldb/lvds-channel@0 fsl,data-width <24>;
+ * 	fdt set ldb/lvds-channel@0 fsl,data-mapping jeida;
+ * 	fdt rm ldb split-mode;
+ * 	fdt set t_lvds clock-frequency <71107200>;
+ * 	fdt set t_lvds hactive <1280>;
+ * 	fdt set t_lvds vactive <800>;
+ * 	fdt set t_lvds hback-porch <48>;
+ * 	fdt set t_lvds hfront-porch <80>;
+ * 	fdt set t_lvds vback-porch <15>;
+ * 	fdt set t_lvds vfront-porch <2>;
+ * 	fdt set t_lvds hsync-len <32>;
+ * 	fdt set t_lvds vsync-len <6>;
+ *
+ * cmd_lvds2=fdt set fb_lvds2 status disabled
+ *
+ *
+ * These strings are then used in 6x_bootscript to configure displays
+ *
+ * The following aliases should be defined in the dtb if possible
+ * fb_hdmi, fb_lcd, fb_lvds, fb_lvds2
+ * lcd
+ * ldb
+ * t_lvds, t_lvds2
+ */
+static const char *const fbnames[] = {
+[FB_HDMI] = "fb_hdmi",
+[FB_LCD] = "fb_lcd",
+[FB_LCD2] = "fb_lcd2",
+[FB_LVDS] = "fb_lvds",
+[FB_LVDS2] = "fb_lvds2"
+};
+
+static const char *const timings_names[] = {
+[FB_HDMI] = "t_hdmi",
+[FB_LCD] = "t_lcd",
+[FB_LCD2] = "t_lcd2",
+[FB_LVDS] = "t_lvds",
+[FB_LVDS2] = "t_lvds2"
+};
+
+static const char *const ch_names[] = {
+[FB_HDMI] = "",
+[FB_LCD] = "",
+[FB_LCD2] = "",
+[FB_LVDS] = "ldb/lvds-channel@0",
+[FB_LVDS2] = "ldb/lvds-channel@1"
+};
+
+static const char *const cmd_fbnames[] = {
+[FB_HDMI] = "cmd_hdmi",
+[FB_LCD] = "cmd_lcd",
+[FB_LCD2] = "cmd_lcd2",
+[FB_LVDS] = "cmd_lvds",
+[FB_LVDS2] = "cmd_lvds2"
+};
+
+static const char *const backlight_names[] = {
+[FB_HDMI] = "backlight_hdmi",
+[FB_LCD] = "backlight_lcd",
+[FB_LCD2] = "backlight_lcd2",
+[FB_LVDS] = "backlight_lvds",
+[FB_LVDS2] = "backlight_lvds2"
+};
+
+static const char *const pwm_names[] = {
+[FB_HDMI] = "pwm_hdmi",
+[FB_LCD] = "pwm_lcd",
+[FB_LCD2] = "pwm_lcd2",
+[FB_LVDS] = "pwm_lvds",
+[FB_LVDS2] = "pwm_lvds2"
+};
+
+static const char *const short_names[] = {
+[FB_HDMI] = "hdmi",
+[FB_LCD] = "lcd",
+[FB_LCD2] = "lcd2",
+[FB_LVDS] = "lvds",
+[FB_LVDS2] = "lvds2"
+};
+
+static const char *const timings_properties[] = {
+"clock-frequency",
+"hactive",
+"vactive",
+"hback-porch",
+"hfront-porch",
+"vback-porch",
+"vfront-porch",
+"hsync-len",
+"vsync-len",
+};
+
+static const int timings_offsets[] = {
+	offsetof(struct fb_videomode, pixclock),
+	offsetof(struct fb_videomode, xres),
+	offsetof(struct fb_videomode, yres),
+	offsetof(struct fb_videomode, left_margin),
+	offsetof(struct fb_videomode, right_margin),
+	offsetof(struct fb_videomode, upper_margin),
+	offsetof(struct fb_videomode, lower_margin),
+	offsetof(struct fb_videomode, hsync_len),
+	offsetof(struct fb_videomode, vsync_len),
+};
+
+static void __board_pre_enable(const struct display_info_t *di)
+{
+}
+
+static void __board_enable_hdmi(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_lcd(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_lvds(const struct display_info_t *di, int enable)
+{
+}
+
+static void __board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+}
+
+void board_pre_enable(const struct display_info_t *di)
+	__attribute__((weak, alias("__board_pre_enable")));
+void board_enable_hdmi(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_hdmi")));
+void board_enable_lcd(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_lcd")));
+void board_enable_lvds(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_lvds")));
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+	__attribute__((weak, alias("__board_enable_lvds2")));
+
+static unsigned get_fb_available_mask(const struct display_info_t *di, int cnt)
+{
+	unsigned mask = 0;
+	int i;
+
+	for (i = 0; i < cnt; i++, di++)
+		mask |= (1 << di->fbtype);
+
+	return mask;
+}
+static const char bgr24[] = "BGR24";
+static const char rgb24[] = "RGB24";
+static const char rgb565[] = "RGB565";
+static const char rgb666[] = "RGB666";
+static const char yuyv16[] = "YUYV16";
+
+static char lvds_enabled;
+static const char brightness_levels_low_active[] = "<10 9 8 7 6 5 4 3 2 1 0>";
+static const char brightness_levels_high_active[] = "<0 1 2 3 4 5 6 7 8 9 10>";
+
+static u32 period_to_freq(u32 freq)
+{
+	u64 lval = 1000000000000ULL;
+
+	if (freq < (233 * 16))
+		freq = (233 * 16);	/* ensure result * 16 fits in u32 */
+	do_div(lval, freq);
+	return (u32)lval;
+}
+
+static u32 freq_to_period(u32 val)
+{
+	u64 lval = 1000000000000ULL;
+
+	if (val < (233 * 16)) {
+		val = 233 * 16;
+		printf("invalid pixel clock frequency\n");
+	}
+	do_div(lval, val);
+	return (u32)lval;
+}
+
+static void setup_cmd_fb(unsigned fb, const struct display_info_t *di, char *buf, int size)
+{
+	const char *mode_str = NULL;
+	int i;
+	int sz;
+	int interface_width;
+	const char *buf_start = buf;
+	const struct fb_videomode *mode;
+	const char * fmt;
+
+	if (getenv("cmd_frozen") && getenv(cmd_fbnames[fb]))
+		return;		/* don't override if already set */
+
+	if (fb == FB_LVDS)
+		lvds_enabled = 0;
+	if (!di) {
+		const char *name = getenv(fbnames[fb]);
+		if (name) {
+			if (name[0] == '*')
+				name++;
+			if (strcmp(name, "off")) {
+				/* Not off and not in list, assume mode_str value */
+				mode_str = name;
+			}
+		}
+		if (!mode_str) {
+			sz = snprintf(buf, size, "fdt set %s status disabled", fbnames[fb]);
+			buf += sz;
+			size -= sz;
+			if (fb == FB_LCD)
+				sz = snprintf(buf, size, ";fdt set lcd status disabled");
+			if ((fb == FB_LVDS) || (fb == FB_LVDS2)) {
+				sz = snprintf(buf, size, ";fdt set ldb/lvds-channel@%d status disabled", fb - FB_LVDS);
+			}
+			setenv(cmd_fbnames[fb], buf_start);
+			return;
+		}
+	} else {
+		if (di->fbflags & FBF_MODESTR)
+			mode_str = di->mode.name;
+	}
+
+	if (fb == FB_LVDS)
+		lvds_enabled = 1;
+	sz = snprintf(buf, size, "fdt set %s status okay;", fbnames[fb]);
+	buf += sz;
+	size -= sz;
+	if ((fb == FB_LVDS2) && !lvds_enabled) {
+		sz = snprintf(buf, size, "fdt set ldb/lvds-channel@1 primary;");
+		buf += sz;
+		size -= sz;
+	}
+
+	interface_width = 18;
+	if (di->pixfmt == IPU_PIX_FMT_RGB24) {
+		fmt = rgb24;
+		interface_width = 24;
+	} else if (di->pixfmt == IPU_PIX_FMT_BGR24) {
+		fmt = bgr24;
+		interface_width = 24;
+	} else if (di->pixfmt == IPU_PIX_FMT_YUYV) {
+		fmt = yuyv16;
+	} else if (di->pixfmt == IPU_PIX_FMT_RGB565) {
+		fmt = rgb565;
+	} else {
+		fmt = rgb666;
+	}
+
+	if (di && (fb >= FB_LCD)) {
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX7D)
+		sz = snprintf(buf, size, "fdt set %s bus-width <%u>;", short_names[fb],
+				interface_width);
+
+#else
+		sz = snprintf(buf, size, "fdt set %s interface_pix_fmt %s;",
+				fbnames[fb], fmt);
+#endif
+		buf += sz;
+		size -= sz;
+	}
+
+	if (di && ((fb == FB_LCD) || (fb == FB_LCD2))) {
+		sz = snprintf(buf, size, "fdt set %s default_ifmt %s;",
+				short_names[fb], fmt);
+		buf += sz;
+		size -= sz;
+
+		sz = snprintf(buf, size, "fdt set %s status okay;",
+				short_names[fb]);
+		buf += sz;
+		size -= sz;
+	}
+
+	if (di && ((fb == FB_LVDS) || (fb == FB_LVDS2))) {
+
+		sz = snprintf(buf, size, "fdt set %s fsl,data-width <%u>;",
+				ch_names[fb],
+				interface_width);
+		buf += sz;
+		size -= sz;
+
+		sz = snprintf(buf, size, "fdt set %s fsl,data-mapping %s;",
+				ch_names[fb],
+				(di->fbflags & FBF_JEIDA) ? "jeida" : "spwg");
+		buf += sz;
+		size -= sz;
+
+		if (di->fbflags & FBF_SPLITMODE) {
+			sz = snprintf(buf, size, "fdt set ldb split-mode 1;");
+			buf += sz;
+			size -= sz;
+		}
+	}
+
+	if (di && di->pwm_period) {
+		sz = snprintf(buf, size, "fdt get value pwm %s phandle; fdt set %s pwms <${pwm} 0x%x 0x%x>;",
+				pwm_names[fb], backlight_names[fb], 0, di->pwm_period);
+		buf += sz;
+		size -= sz;
+	}
+	if (di && (di->fbflags & FBF_BKLIT_DTB)) {
+		sz = snprintf(buf, size, "fdt set %s brightness-levels %s;",
+			backlight_names[fb],
+			(di->fbflags & FBF_BKLIT_LOW_ACTIVE) ?
+				brightness_levels_low_active :
+				brightness_levels_high_active);
+		buf += sz;
+		size -= sz;
+	}
+
+	if (mode_str) {
+		snprintf(buf, size, "fdt set %s mode_str %s;", fbnames[fb], mode_str);
+		setenv(cmd_fbnames[fb], buf_start);
+		return;
+	}
+
+	mode = &di->mode;
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *p = (u32 *)((char *)mode + timings_offsets[i]);
+		u32 val;
+
+		if (i == 0) {
+			val = period_to_freq(mode->pixclock);
+		} else {
+			val = *p;
+		}
+		sz = snprintf(buf, size, "fdt set %s %s <%u>;", timings_names[fb], timings_properties[i], val);
+		buf += sz;
+		size -= sz;
+	}
+	setenv(cmd_fbnames[fb], buf_start);
+}
+
+static const struct display_info_t *find_panel(const struct display_info_t *di, int cnt, unsigned fb, const char *name)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++, di++) {
+		if ((fb == di->fbtype) && !strcmp(name, di->mode.name))
+			return di;
+	}
+	return NULL;
+}
+
+static char g_mode_str[FB_COUNT][80];
+static struct display_info_t g_di_temp[FB_COUNT];
+
+int fbp_detect_i2c(struct display_info_t const *di)
+{
+	int ret;
+	int gp = di->bus >> 8;
+
+	if (gp)
+		gpio_set_value(gp, 1);
+	ret = i2c_set_bus_num(di->bus & 0xff);
+	if (ret == 0)
+		ret = i2c_probe(di->addr);
+	if (gp)
+		gpio_set_value(gp, 0);
+	return (ret == 0);
+}
+
+int calc_gcd(int a, int b)
+{
+	int n;
+
+	while (b) {
+		if (a > b) {
+			n = a;
+			a = b;
+			b = n;
+		}
+		n = b / a;
+		b -= n * a;
+	}
+	return a;
+}
+
+#ifdef CONFIG_MX6SX
+void reparent_lvds(int fbtype, int new_parent)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int ldb_sel_shift = 9;
+	u32 reg = readl(&ccm->cs2cdr);
+
+	reg &= ~(7 << ldb_sel_shift);
+
+	reg |= new_parent << ldb_sel_shift;
+	writel(reg, &ccm->cs2cdr);
+	readl(&ccm->cs2cdr);	/* wait for write */
+}
+
+#elif !defined(CONFIG_MX51) && !defined(CONFIG_MX53) && !defined(CONFIG_MX7D)
+void reparent_lvds(int fbtype, int new_parent)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int ldb_sel_shift = (fbtype == FB_LVDS2) ? 12 : 9;
+	u32 reg;
+
+	reg = readl(&ccm->cbcmr);
+	reg &= ~MXC_CCM_CBCMR_PERIPH2_CLK2_SEL;
+	writel(reg, &ccm->cbcmr);
+
+	/* Set MMDC_CH1 mask bit */
+	reg = readl(&ccm->ccdr);
+	reg |= MXC_CCM_CCDR_MMDC_CH1_HS_MASK;
+	writel(reg, &ccm->ccdr);
+
+	/*
+	 * Set the periph2_clk_sel to the top mux so that
+	 * mmdc_ch1 is from pll3_sw_clk.
+	 */
+	reg = readl(&ccm->cbcdr);
+	reg |= MXC_CCM_CBCDR_PERIPH2_CLK_SEL;
+	writel(reg, &ccm->cbcdr);
+
+	/* Wait for the clock switch */
+	while (readl(&ccm->cdhipr) != 0) {
+		udelay(100);
+	}
+
+	/* Disable pll3_sw_clk by selecting the bypass clock source */
+	reg = readl(&ccm->ccsr);
+	reg |= MXC_CCM_CCSR_PLL3_SW_CLK_SEL;
+	writel(reg, &ccm->ccsr);
+
+	/* Set the ldb_di0/1_clk to 1xxb, to change to lower mux */
+	reg = readl(&ccm->cs2cdr);
+	reg |= (4 << ldb_sel_shift);
+	writel(reg, &ccm->cs2cdr);
+	readl(&ccm->cs2cdr);	/* wait for write */
+
+	/* Set the ldb_di0/1_clk to 100b, change upper mux to pll5 */
+	reg &= ~(3 << ldb_sel_shift);
+	reg |= new_parent << ldb_sel_shift;
+	writel(reg, &ccm->cs2cdr);
+	readl(&ccm->cs2cdr);	/* wait for write */
+
+	/* select upper mux, pll 5 clock */
+	reg &= ~(4 << ldb_sel_shift);
+	writel(reg, &ccm->cs2cdr);
+	readl(&ccm->cs2cdr);	/* wait for write */
+
+	/* Unbypass pll3_sw_clk */
+	reg = readl(&ccm->ccsr);
+	reg &= ~MXC_CCM_CCSR_PLL3_SW_CLK_SEL;
+	writel(reg, &ccm->ccsr);
+
+	/*
+	 * Set the periph2_clk_sel back to the bottom mux so that
+	 * mmdc_ch1 is from its original parent.
+	 */
+	reg = readl(&ccm->cbcdr);
+	reg &= ~MXC_CCM_CBCDR_PERIPH2_CLK_SEL;
+	writel(reg, &ccm->cbcdr);
+
+	/* Wait for the clock switch */
+	while (readl(&ccm->cdhipr)) {
+		udelay(100);
+	}
+
+	/* Clear MMDC_CH1 mask bit */
+	reg = readl(&ccm->ccdr);
+	reg &= ~MXC_CCM_CCDR_MMDC_CH1_HS_MASK;
+	writel(reg, &ccm->ccdr);
+}
+#endif
+
+#if defined(CONFIG_MX51) || defined(CONFIG_MX53)
+int get_pll3_clock(void);
+
+void setup_clock(struct display_info_t const *di)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 desired_freq, freq;
+	u32 pll3_freq = get_pll3_clock();
+	u32 n, m;
+	u32 i;
+	u32 best = 8;
+	u32 best_diff = ~0;
+	u32 diff;
+	u32 reg;
+
+	if (!(di->mode.sync & FB_SYNC_EXT))
+		return;
+
+	desired_freq = period_to_freq(di->mode.pixclock) * 16;
+
+	for (i = 8; i > 0 ; i--) {
+		n = pll3_freq / i;
+		m = n / desired_freq;
+		if (!m || (m & 1))
+			continue;
+		if (m > 16)
+			break;
+		freq = n / m;
+		if (freq >= desired_freq)
+			diff = freq - desired_freq;
+		else
+			diff = desired_freq - freq;
+
+		if (best_diff > diff) {
+			best_diff = diff;
+			best = i;
+		}
+	}
+	reg = readl(&ccm->cdcdr);
+	reg &= ~(7 << 6);
+	reg |= (best - 1) << 6;
+	writel(reg, &ccm->cdcdr);
+
+#ifndef CONFIG_MX6SX
+	ipu_set_ldb_clock(pll3_freq / best);	/* used for all ext clocks */
+#endif
+}
+
+#else
+void setup_clock(struct display_info_t const *di)
+{
+#if defined(CONFIG_MX7D)
+	struct mxc_ccm_anatop_reg *ccm_anatop = (struct mxc_ccm_anatop_reg *)
+						 ANATOP_BASE_ADDR;
+	u32 target;
+#else
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 reg;
+	u32 pll_video;
+#if !defined(CONFIG_MX6SX)
+	u32 out_freq;
+#endif
+#endif
+	u32 desired_freq;
+	int post_div = 2;	/* 0: /4, 1: /2, 2: /1 */
+	int misc2_div = 0;	/* 0: /1, 1: /2, 3: /4 */
+	int lvds = ((di->fbtype == FB_LVDS) | (di->fbtype == FB_LVDS2)) ? 1 : 0;
+	int timeout = 1000;
+	int multiplier;
+	int gcd;
+	int num, denom;
+	int ipu_div = 7;
+	int x = 1;
+
+	if (!(di->mode.sync & FB_SYNC_EXT))
+		return;
+
+#if defined(CONFIG_MX6SX)
+	clrbits_le32(&ccm->CCGR2, MXC_CCM_CCGR2_LCD_MASK);
+	/* gate LCDIF2/LCDIF1/LDB_DI0 */
+	clrbits_le32(&ccm->CCGR3, 0x3f << 8);
+#elif defined(CONFIG_MX7D)
+	clock_enable(CCGR_LCDIF, 0);
+#else
+	/* gate ipu1_di0_clk */
+	clrbits_le32(&ccm->CCGR3, MXC_CCM_CCGR3_LDB_DI0_MASK |
+			MXC_CCM_CCGR3_LDB_DI1_MASK |
+			MXC_CCM_CCGR3_IPU1_IPU_DI0_MASK);
+#endif
+
+#if defined(CONFIG_MX7D)
+	/* Power up video PLL and disable its output */
+	writel(CCM_ANALOG_PLL_VIDEO_CLR_ENABLE_CLK_MASK |
+		CCM_ANALOG_PLL_VIDEO_CLR_POWERDOWN_MASK |
+		CCM_ANALOG_PLL_VIDEO_CLR_BYPASS_MASK |
+		CCM_ANALOG_PLL_VIDEO_CLR_DIV_SELECT_MASK |
+		CCM_ANALOG_PLL_VIDEO_CLR_POST_DIV_SEL_MASK |
+		CCM_ANALOG_PLL_VIDEO_CLR_TEST_DIV_SELECT_MASK,
+		&ccm_anatop->pll_video_clr);
+#else
+	pll_video = readl(&ccm->analog_pll_video);
+	pll_video &= BM_ANADIG_PLL_VIDEO_ENABLE;
+	pll_video |= BM_ANADIG_PLL_VIDEO_POWERDOWN;
+	writel(pll_video, &ccm->analog_pll_video);
+#endif
+
+	desired_freq = period_to_freq(di->mode.pixclock);
+	debug("desired_freq=%d\n", desired_freq);
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX7D)
+	out_freq = desired_freq;
+#endif
+
+#if !defined(CONFIG_MX7D)
+	if (lvds) {
+		reparent_lvds(di->fbtype, 0);
+		desired_freq *= 7;
+		if (di->fbflags & FBF_SPLITMODE)
+			desired_freq >>= 1;
+
+	}
+#endif
+	debug("desired_freq=%d\n", desired_freq);
+
+#define MIN_FREQ 648000000	/* 24000000 * 27 */
+
+	if (!(is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) ||
+			soc_rev() > CHIP_REV_1_0) {
+		while (desired_freq < MIN_FREQ) {
+			desired_freq <<= 1;
+			if (--post_div <= 0)
+				break;
+		}
+		debug("desired_freq=%d\n", desired_freq);
+
+		while (desired_freq < MIN_FREQ) {
+			desired_freq <<= 1;
+			misc2_div = (misc2_div << 1) + 1;
+			if (misc2_div >= 3)
+				break;
+		}
+		debug("desired_freq=%d\n", desired_freq);
+	};
+
+	if (!lvds) {
+		num = (MIN_FREQ - 1) / desired_freq + 1;
+		x = (num + 7) / 8;
+		ipu_div =  (num - 1) / x + 1;
+		desired_freq *= ipu_div * x;
+#if defined(CONFIG_MX6SX)
+		if (x > 8) {
+			printf("div changed from %d to 64\n", num);
+			ipu_div = 8;
+			x = 8;
+			desired_freq = MIN_FREQ;
+		}
+#endif
+	} else if (desired_freq < MIN_FREQ) {
+		printf("desired_freq=%d is too low\n", desired_freq);
+	}
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX7D)
+	ipu_set_ldb_clock(out_freq * x);	/* used for all ext clocks */
+#endif
+	debug("desired_freq=%d ipu div=%d x=%d\n", desired_freq, ipu_div, x);
+
+	multiplier = desired_freq / 24000000;
+	if (multiplier > 54) {
+		multiplier = 54;
+		desired_freq = 24000000 * 54;
+	}
+
+#if defined(CONFIG_MX7D)
+	writel(CCM_ANALOG_PLL_VIDEO_SET_DIV_SELECT(multiplier) |
+		CCM_ANALOG_PLL_VIDEO_SET_TEST_DIV_SELECT(post_div) |
+		CCM_ANALOG_PLL_VIDEO_SET_POST_DIV_SEL(misc2_div),
+		&ccm_anatop->pll_video_set);
+#else
+	reg = readl(&ccm->pmu_misc2);
+	reg &= ~(BF_PMU_MISC2_VIDEO_DIV(3));
+	reg |= BF_PMU_MISC2_VIDEO_DIV(misc2_div);
+	writel(reg, &ccm->pmu_misc2);
+
+	pll_video &= ~(BM_ANADIG_PLL_VIDEO_DIV_SELECT |
+		 BM_ANADIG_PLL_VIDEO_POST_DIV_SELECT);
+	pll_video |= BF_ANADIG_PLL_VIDEO_DIV_SELECT(multiplier) |
+		BF_ANADIG_PLL_VIDEO_POST_DIV_SELECT(post_div);
+	writel(pll_video, &ccm->analog_pll_video);
+#endif
+	desired_freq -= multiplier * 24000000;
+	gcd = calc_gcd(desired_freq, 24000000);
+	debug("gcd=%d desired_freq=%d 24000000\n", gcd, desired_freq);
+	num = desired_freq / gcd;
+	denom = 24000000 / gcd;
+	debug("desired_freq=%d multiplier=%d %d/%d\n", desired_freq, multiplier, num, denom);
+
+#if defined(CONFIG_MX7D)
+	writel(num, &ccm_anatop->pll_video_num);
+	writel(denom, &ccm_anatop->pll_video_denom);
+
+	while (!(readl(&ccm_anatop->pll_video) & CCM_ANALOG_PLL_VIDEO_LOCK_MASK)) {
+		udelay(100);
+		if (--timeout < 0) {
+			printf("Warning: video pll lock timeout!\n");
+			break;
+		}
+	}
+
+	/* Enable PLL out */
+	writel(CCM_ANALOG_PLL_VIDEO_CLR_ENABLE_CLK_MASK,
+			&ccm_anatop->pll_video_set);
+#else
+	writel(num, &ccm->analog_pll_video_num);
+	writel(denom, &ccm->analog_pll_video_denom);
+
+	pll_video &= ~BM_ANADIG_PLL_VIDEO_POWERDOWN;
+	writel(pll_video, &ccm->analog_pll_video);
+
+	while (!(readl(&ccm->analog_pll_video) & BM_ANADIG_PLL_VIDEO_LOCK)) {
+		udelay(100);
+		if (--timeout < 0) {
+			printf("Warning: video pll lock timeout!\n");
+			break;
+		}
+	}
+
+	pll_video &= ~BM_ANADIG_PLL_VIDEO_BYPASS;
+	pll_video |= BM_ANADIG_PLL_VIDEO_ENABLE;
+	writel(pll_video, &ccm->analog_pll_video);
+#endif
+
+#if defined(CONFIG_MX6SX)
+	/* Select pll5 clock for ldb di0 */
+	clrbits_le32(&ccm->cs2cdr, MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK);
+
+	/* lvds:
+	 *   lcdif1 from ldb_di0
+	 * lcd:
+	 *   lcdif1 from pre-muxed lcdif1 clock / ipu_div
+	 *   pre-muxed from PLL5
+	 */
+	clrsetbits_le32(&ccm->cscdr2,
+		(MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK |
+		MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK |
+		MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK),
+		(((lvds ? 3 : 0) << MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET) |
+		((ipu_div - 1) << MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET) |
+		(2 << MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET)));
+
+	/* Set the post divider */
+	clrsetbits_le32(&ccm->cbcmr,
+			MXC_CCM_CBCMR_LCDIF1_PODF_MASK,
+			((x - 1) <<
+			MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET));
+
+	setbits_le32(&ccm->CCGR2, MXC_CCM_CCGR2_LCD_MASK);
+	/* enable lcdif1/ ldb_di0 (if lvds)*/
+	setbits_le32(&ccm->CCGR3, MXC_CCM_CCGR3_LCDIF1_PIX_MASK |
+		MXC_CCM_CCGR3_DISP_AXI_MASK |
+		(lvds ? MXC_CCM_CCGR3_LDB_DI0_MASK : 0));
+
+#elif defined(CONFIG_MX7D)
+	target = CLK_ROOT_ON | LCDIF_PIXEL_CLK_ROOT_FROM_PLL_VIDEO_MAIN_CLK |
+		 CLK_ROOT_PRE_DIV((ipu_div - 1)) | CLK_ROOT_POST_DIV((x - 1));
+	clock_set_target_val(LCDIF_PIXEL_CLK_ROOT, target);
+	clock_enable(CCGR_LCDIF, 1);
+
+#else
+	reg = readl(&ccm->chsccdr);
+	reg &= ~(MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK |
+		 MXC_CCM_CHSCCDR_IPU1_DI0_PODF_MASK |
+		 MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_MASK);
+	reg |= ((lvds ? ((di->fbtype == FB_LVDS2) ?
+			 CHSCCDR_CLK_SEL_LDB_DI1 : CHSCCDR_CLK_SEL_LDB_DI0)
+		: CHSCCDR_CLK_SEL_IPU1_DI0)
+			<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET) |
+		((ipu_div - 1) << MXC_CCM_CHSCCDR_IPU1_DI0_PODF_OFFSET) |
+		(CHSCCDR_IPU_PRE_CLK_PLL5 << MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_OFFSET);
+	writel(reg, &ccm->chsccdr);
+
+	/* enable ipu1_di0_clk */
+	setbits_le32(&ccm->CCGR3, MXC_CCM_CCGR3_IPU1_IPU_DI0_MASK |
+			(lvds ? ((di->fbtype == FB_LVDS2) ?
+				 MXC_CCM_CCGR3_LDB_DI1_MASK : MXC_CCM_CCGR3_LDB_DI0_MASK)
+			 : 0));
+#endif
+}
+#endif
+
+void fbp_enable_fb(struct display_info_t const *di, int enable)
+{
+#if !defined(CONFIG_MX51) && !defined(CONFIG_MX53) && !defined(CONFIG_MX7D)
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	u32 reg, cscmr2;
+	u32 tmp;
+#endif
+	switch (di->fbtype) {
+#ifdef CONFIG_IMX_HDMI
+	case FB_HDMI:
+		imx_enable_hdmi_phy();
+		board_enable_hdmi(di, enable);
+		break;
+#endif
+	case FB_LCD2:
+	case FB_LCD:
+		board_enable_lcd(di, enable);
+		break;
+#if !defined(CONFIG_MX51) && !defined(CONFIG_MX53) && !defined(CONFIG_MX7D)
+	case FB_LVDS:
+#ifdef CONFIG_MX6SX
+#define GPR_LDB	6
+#else
+#define GPR_LDB	2
+#endif
+		reg = readl(&iomux->gpr[GPR_LDB]);
+		cscmr2 = readl(&mxc_ccm->cscmr2);
+		reg &= ~(IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT |
+			 IOMUXC_GPR2_BIT_MAPPING_CH0_JEIDA |
+			 IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT |
+ 			 IOMUXC_GPR2_BIT_MAPPING_CH1_JEIDA |
+			 IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+			 IOMUXC_GPR2_LVDS_CH1_MODE_MASK |
+			 IOMUXC_GPR2_SPLIT_MODE_EN_MASK);
+		tmp = 0;
+		if ((di->pixfmt == IPU_PIX_FMT_RGB24) ||
+				(di->pixfmt == IPU_PIX_FMT_BGR24))
+			tmp |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT;
+		if (di->fbflags & FBF_JEIDA)
+			tmp |= IOMUXC_GPR2_BIT_MAPPING_CH0_JEIDA;
+		if (di->fbflags & FBF_SPLITMODE) {
+			tmp |= tmp << 2;
+			tmp |= IOMUXC_GPR2_SPLIT_MODE_EN_MASK |
+			       IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+
+			cscmr2 &= ~(MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV |
+				 MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV);
+
+		} else {
+			cscmr2 |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+		}
+		writel(cscmr2, &mxc_ccm->cscmr2);
+		if (enable)
+			reg |= tmp | IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+
+		writel(reg, &iomux->gpr[GPR_LDB]);
+		board_enable_lvds(di, enable);
+		break;
+#ifndef CONFIG_MX6SX
+	case FB_LVDS2:
+		reg = readl(&iomux->gpr[2]);
+		cscmr2 = readl(&mxc_ccm->cscmr2);
+		reg &= ~(IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT |
+			 IOMUXC_GPR2_BIT_MAPPING_CH1_JEIDA |
+			 IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+			 IOMUXC_GPR2_LVDS_CH1_MODE_MASK |
+			 IOMUXC_GPR2_SPLIT_MODE_EN_MASK);
+		if ((di->pixfmt == IPU_PIX_FMT_RGB24) ||
+				(di->pixfmt == IPU_PIX_FMT_BGR24))
+			reg |= IOMUXC_GPR2_DATA_WIDTH_CH1_24BIT;
+		if (di->fbflags & FBF_JEIDA)
+			reg |= IOMUXC_GPR2_BIT_MAPPING_CH1_JEIDA;
+
+		cscmr2 |= MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+		writel(cscmr2, &mxc_ccm->cscmr2);
+
+		if (enable)
+			reg |= IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+		writel(reg, &iomux->gpr[2]);
+		board_enable_lvds2(di, enable);
+		break;
+#endif
+#endif
+	}
+}
+
+static void imx_prepare_display(void)
+{
+#if !defined(CONFIG_MX51) && !defined(CONFIG_MX53) && \
+		!defined(CONFIG_MX7D)
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int reg;
+#if !defined(CONFIG_MX6SX)
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	enable_ipu_clock();
+#ifdef CONFIG_IMX_HDMI
+	imx_setup_hdmi();
+#endif
+#endif
+	/* Turn on LDB0,IPU,IPU DI0 clocks */
+	reg = __raw_readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		| MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+#ifdef CONFIG_MX6SX
+	/* Select pll5 clock for ldb di0 */
+#else
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg |= (3<<MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      |(3<<MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+#endif
+	writel(reg, &mxc_ccm->cs2cdr);
+
+#ifndef CONFIG_MX6SX
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     |IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     |IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     |IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     |IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK
+			|IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       <<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+#endif
+#endif
+}
+
+static const struct display_info_t * parse_mode(
+		const struct display_info_t *gdi, int cnt, const char *p,
+		unsigned fb, unsigned *prefer)
+{
+	char c;
+	char *endp;
+	unsigned value;
+	int i;
+	struct display_info_t *di;
+	char *mode_str = g_mode_str[fb];
+	int pix_fmt = IPU_PIX_FMT_RGB24;
+
+	if (*p == '*') {
+		p++;
+		*prefer = 1;
+	}
+	if (!strcmp(p, "off")) {
+		*prefer |= 2;
+		return NULL;
+	}
+
+	i = 0;
+	while (i < 80 - 1) {
+		c = *p;
+		if (c)
+			p++;
+		if (!c || (c == ':')) {
+			break;
+		}
+		mode_str[i++] = c;
+	}
+	mode_str[i] = 0;
+	c = *p;
+	if (!c) {
+		return find_panel(gdi, cnt, fb, mode_str);
+	}
+	di = &g_di_temp[fb];
+	memset(di, 0, sizeof(*di));
+
+	di->fbtype = fb;
+	di->mode.name = mode_str;
+	di->enable = fbp_enable_fb;
+
+	if (c == 'm') {
+		di->fbflags |= FBF_MODESTR;
+		p++;
+		c = *p;
+	}
+	if (c == 'j') {
+		di->fbflags |= FBF_JEIDA;
+		p++;
+		c = *p;
+	}
+	if (c == 's') {
+		di->fbflags |= FBF_SPLITMODE;
+		p++;
+		c = *p;
+	}
+	if (c == 'b') {
+		pix_fmt = IPU_PIX_FMT_BGR24;
+		p++;
+		c = *p;
+	}
+	value = simple_strtoul(p, &endp, 10);
+	if (endp <= p) {
+		printf("expecting 18|24\n");
+		return NULL;
+	}
+	if ((value != 18) && (value != 24)) {
+		printf("expecting 18|24, found %d\n", value);
+		return NULL;
+	}
+	p = endp;
+	di->pixfmt = (value == 24) ? pix_fmt : IPU_PIX_FMT_RGB666;
+	c = *p;
+
+	if (c == 'S') {
+		di->fbflags |= FBF_SPI;
+		p++;
+		c = *p;
+	}
+	if (c == 'D') {
+		di->fbflags |= FBF_BKLIT_DTB;
+		p++;
+		c = *p;
+	}
+	if (c == 'b') {
+		di->fbflags |= FBF_BKLIT_LOW_ACTIVE;
+		p++;
+		c = *p;
+	}
+	if (c == 'e') {
+		di->pre_enable = board_pre_enable;
+		p++;
+		c = *p;
+	}
+	if (c == 'x') {
+		p++;
+		value = simple_strtoul(p, &endp, 16);
+		if (endp <= p) {
+			printf("expecting bus\n");
+			return NULL;
+		}
+		p = endp;
+		di->bus = value;
+		c = *p;
+		if (c == ',') {
+			p++;
+			value = simple_strtoul(p, &endp, 16);
+			if (endp <= p) {
+				printf("expecting bus addr\n");
+				return NULL;
+			}
+			p = endp;
+			di->addr = value;
+			c = *p;
+		}
+	}
+	if (c == 'p') {
+		p++;
+		value = simple_strtoul(p, &endp, 10);
+		if (endp <= p) {
+			printf("expecting period of pwm\n");
+			return NULL;
+		}
+		p = endp;
+		di->pwm_period = value;
+		c = *p;
+	}
+	if (c != ':') {
+		printf("expected ':', %s\n", p);
+		return NULL;
+	}
+	p++;
+
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *dest = (u32 *)((char *)&di->mode + timings_offsets[i]);
+		u32 val;
+
+		val = simple_strtoul(p, &endp, 10);
+		if (endp <= p) {
+			printf("expecting integer:%s\n", p);
+			return NULL;
+		}
+		if (i == 0)
+			val = freq_to_period(val);
+		*dest = val;
+		p = endp;
+		if (*p == ',')
+			p++;
+		if (*p == ' ')
+			p++;
+	}
+
+	di->mode.sync |= FB_SYNC_EXT;
+	if (*p) {
+		printf("extra parameters found:%s\n", p);
+		return NULL;
+	}
+	return di;
+}
+
+static const struct display_info_t *find_disp(const struct display_info_t *di,
+		int cnt, unsigned fb, unsigned *prefer)
+{
+	int i;
+	const char *name = getenv(fbnames[fb]);
+
+	if (name) {
+		di = parse_mode(di, cnt, name, fb, prefer);
+		if (di)
+			return di;
+		if (!(*prefer & 2))
+			printf("No match, assuming mode_str: %s\n", name);
+		return NULL;
+	}
+	/* No specific name requested, lets probe */
+	for (i = 0; i < cnt; i++, di++) {
+		if (fb == di->fbtype) {
+			if (di->detect && di->detect(di)) {
+				printf("auto-detected panel %s\n", di->mode.name);
+				return di;
+			}
+		}
+	}
+	return NULL;
+}
+
+static const struct display_info_t *find_first_disp(
+		const struct display_info_t *di, int cnt)
+{
+	int i;
+	unsigned skip_mask = 0;
+
+	for (i = 0; i < cnt; i++, di++) {
+		if (di->fbtype >= FB_COUNT)
+			continue;
+		if (skip_mask & (1 << di->fbtype))
+			continue;
+		if (getenv(fbnames[di->fbtype])) {
+			skip_mask |= (1 << di->fbtype);
+			continue;
+		}
+		return di;
+	}
+	return NULL;
+}
+
+static void str_mode(char *p, int size, const struct display_info_t *di, unsigned prefer)
+{
+	int count;
+	int i;
+	int interface_width = 18;
+
+	if (prefer) {
+		*p++ = '*';
+		size--;
+	}
+	if (!di) {
+		count = snprintf(p, size, "off");
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+		*p = 0;
+		return;
+	}
+	count = snprintf(p, size, "%s:", di->mode.name);
+	if (size > count) {
+		p += count;
+		size -= count;
+	}
+	if (di->fbflags & FBF_MODESTR) {
+		*p++ = 'm';
+		size--;
+	}
+	if (di->fbflags & FBF_JEIDA) {
+		*p++ = 'j';
+		size--;
+	}
+	if (di->fbflags & FBF_SPLITMODE) {
+		*p++ = 's';
+		size--;
+	}
+	if ((di->pixfmt == IPU_PIX_FMT_RGB24) ||
+			(di->pixfmt == IPU_PIX_FMT_BGR24))
+		interface_width = 24;
+	if (di->pixfmt == IPU_PIX_FMT_BGR24) {
+		*p++ = 'b';
+		size--;
+	}
+	count = snprintf(p, size, "%d", interface_width);
+	if (size > count) {
+		p += count;
+		size -= count;
+	}
+	if (di->fbflags & FBF_SPI) {
+		*p++ = 'S';
+		size--;
+	}
+	if (di->fbflags & FBF_BKLIT_DTB) {
+		*p++ = 'D';
+		size--;
+	}
+	if (di->fbflags & FBF_BKLIT_LOW_ACTIVE) {
+		*p++ = 'b';
+		size--;
+	}
+	if (di->pre_enable) {
+		*p++ = 'e';
+		size--;
+	}
+	if (di->bus || di->addr) {
+		count = snprintf(p, size, "x%x,%x", di->bus, di->addr);
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+	}
+	if (di->pwm_period) {
+		count = snprintf(p, size, "p%d", di->pwm_period);
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+	}
+	*p++ = ':';
+	size--;
+
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *src = (u32 *)((char *)&di->mode + timings_offsets[i]);
+		u32 val;
+
+		if (i == 0) {
+			val = period_to_freq(di->mode.pixclock);
+		} else {
+			val = *src;
+			if (size > 1) {
+				*p++ = ',';
+				size--;
+			}
+		}
+		count = snprintf(p, size, "%d", val);
+		if (size > count) {
+			p += count;
+			size -= count;
+		}
+	}
+	*p = 0;
+}
+
+static void print_mode(const struct display_info_t *di, int *len)
+{
+	int i;
+	char format_buf[16];
+	const struct fb_videomode* mode = &di->mode;
+	int fb = di->fbtype;
+	char buf[256];
+
+	str_mode(buf, sizeof(buf), di, 0);
+	printf("%s: %s\n\x09", short_names[fb], buf);
+
+
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		u32 *p = (u32 *)((char *)mode + timings_offsets[i]);
+		u32 val;
+
+		if (i == 0) {
+			val = period_to_freq(mode->pixclock);
+		} else {
+			val = *p;
+		}
+		snprintf(format_buf, sizeof(format_buf), " %c%du", '%', len[i]);
+		printf(format_buf, val);
+	}
+	printf("\n");
+}
+
+static void print_modes(const struct display_info_t *di, int cnt, unsigned mask)
+{
+	int i;
+	int len[ARRAY_SIZE(timings_properties)];
+
+	/* Print heading */
+	printf("\x09");
+	for (i = 0; i < ARRAY_SIZE(timings_properties); i++) {
+		printf(" %s", timings_properties[i]);
+		len[i] = strlen(timings_properties[i]);
+	}
+	printf("\n");
+
+	for (i = 0; i < cnt; i++, di++) {
+		if (mask & (1 << di->fbtype))
+			print_mode(di, len);
+	}
+}
+
+static const struct display_info_t *select_display(
+		const struct display_info_t *gdi, int cnt)
+{
+	const struct display_info_t *disp[FB_COUNT];
+	const struct display_info_t *di = NULL;
+	unsigned prefer_mask = 0;
+	unsigned fb;
+	char *buf = malloc(4096);
+
+	for (fb = 0; fb < ARRAY_SIZE(disp); fb++) {
+		unsigned prefer = 0;
+
+		disp[fb] = find_disp(gdi, cnt, fb, &prefer);
+		if (prefer & 1)
+			prefer_mask |= (1 << fb);
+	}
+	fb = ffs(prefer_mask) - 1;
+	if (fb < ARRAY_SIZE(disp)) {
+		di = disp[fb];
+	} else {
+		/* default to the 1st one in the list*/
+		for (fb = 0; fb < ARRAY_SIZE(disp); fb++) {
+			if (!di) {
+				di = disp[fb];
+			} else {
+				if (disp[fb] && ((unsigned)disp[fb]
+						< (unsigned)di))
+					di = disp[fb];
+			}
+		}
+		if (!di) {
+			di = find_first_disp(gdi, cnt);
+			if (di)
+				disp[di->fbtype] = di;
+		}
+	}
+
+	if (buf) {
+		unsigned mask = get_fb_available_mask(gdi, cnt);
+
+		for (fb = 0; fb < ARRAY_SIZE(disp); fb++) {
+			if (mask & (1 << fb))
+				setup_cmd_fb(fb, disp[fb], buf, 4096);
+		}
+		free(buf);
+	}
+	return di;
+}
+
+static const struct display_info_t *g_displays;
+static int g_display_cnt;
+
+static const struct display_info_t *g_di_active;
+
+void board_video_enable(void)
+{
+	const struct display_info_t *di = g_di_active;
+	if (di && di->enable)
+		di->enable(di, 1);
+}
+
+static int init_display(const struct display_info_t *di)
+{
+	int ret;
+
+	if (di->pre_enable)
+		di->pre_enable(di);
+	setup_clock(di);
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX7D)
+	ret = mxsfb_init(&di->mode, di->pixfmt);
+#else
+	ret = ipuv3_fb_init(&di->mode, (di->fbtype == FB_LCD2) ? 1 : 0,
+			di->pixfmt);
+#endif
+	if (ret) {
+		printf("LCD %s cannot be configured: %d\n", di->mode.name, ret);
+		return -EINVAL;
+	}
+	printf("Display: %s:%s (%ux%u)\n", short_names[di->fbtype],
+			di->mode.name, di->mode.xres, di->mode.yres);
+	g_di_active = di;
+	return 0;
+}
+
+static int do_fbpanel(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	const char *fbname;
+	int fb = -1;
+	const char *p;
+	char *buf;
+	unsigned prefer;
+	int ret = 0;
+	const struct display_info_t* di = g_displays;
+	int cnt = g_display_cnt;
+
+	if (argc < 2) {
+		print_modes(di, cnt, 0xf);
+                return 0;
+	}
+	fbname = argv[1];
+	for (i = 0; i < ARRAY_SIZE(short_names); i++) {
+		if (!strcmp(short_names[i], fbname)) {
+			fb = i;
+			break;
+		}
+	}
+	if (fb < 0)
+		return CMD_RET_USAGE;
+
+	if (argc < 3) {
+		print_modes(di, cnt, 1 << fb);
+		return 0;
+	}
+	p = argv[2];
+	di = parse_mode(di, cnt, p, fb, &prefer);
+	if (!di && !(prefer & 2))
+		return 1;
+
+	buf = malloc(4096);
+	if (buf) {
+		str_mode(buf, 256, di, prefer & 1);
+		setenv(fbnames[fb], buf);
+
+		setup_cmd_fb(fb, di, buf, 4096);
+		free(buf);
+	}
+	if (!(prefer & 1))
+		return 0;
+	{
+		const struct display_info_t* di1;
+		di1 = g_di_active;
+		if (di1 && di1->enable) {
+			di1->enable(di1, 0);
+			g_di_active = NULL;
+		}
+	}
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX7D)
+	ipuv3_fb_shutdown();
+	if (!di)
+		return 0;
+	ret = init_display(di);
+	if (ret)
+		return ret;
+	ipuv3_fb_init2();
+#else
+	lcdif_power_down();
+	if (!di)
+		return 0;
+	ret = init_display(di);
+	if (ret)
+		return ret;
+	mxsfb_init2();
+#endif
+	return ret;
+}
+
+U_BOOT_CMD(fbpanel, 3, 0, do_fbpanel,
+           "show/set panel names available",
+           "fbpanel [hdmi|lcd|lvds|lvds2] [\"[*]mode_str[:[m][j][s][18|24][S][e][xhexbus,hexaddr][pnnn]:pixclkfreq,xres,yres,hback-porch,hfront-porch,vback-porch,vfront-porch,hsync,vsync]\"]\n"
+           "\n"
+           "fbpanel  - show all panels");
+
+int board_video_skip(void)
+{
+	const struct display_info_t *di = select_display(g_displays, g_display_cnt);
+
+	if (!di)
+		return -EINVAL;
+	return init_display(di);
+}
+
+void fbp_setup_display(const struct display_info_t *displays, int cnt)
+{
+	g_displays = displays;
+	g_display_cnt = cnt;
+	imx_prepare_display();
+}
diff -Nru u-boot-2017.07/arch/arm/imx-common/i2c-mxv7.c u-boot-imx6/arch/arm/imx-common/i2c-mxv7.c
--- u-boot-2017.07/arch/arm/imx-common/i2c-mxv7.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/i2c-mxv7.c	2018-08-27 21:35:36.684139600 +0300
@@ -12,12 +12,12 @@
 #include <asm/imx-common/mxc_i2c.h>
 #include <watchdog.h>
 
-int force_idle_bus(void *priv)
+int force_idle_bus(const void *priv)
 {
 	int i;
 	int sda, scl;
 	ulong elapsed, start_time;
-	struct i2c_pads_info *p = (struct i2c_pads_info *)priv;
+	const struct i2c_pads_info *p = (struct i2c_pads_info *)priv;
 	int ret = 0;
 
 	gpio_direction_input(p->sda.gp);
@@ -74,7 +74,7 @@
 
 /* i2c_index can be from 0 - 3 */
 int setup_i2c(unsigned i2c_index, int speed, int slave_addr,
-	      struct i2c_pads_info *p)
+	      const struct i2c_pads_info *p)
 {
 	char name[9];
 	int ret;
diff -Nru u-boot-2017.07/arch/arm/imx-common/iomux-v3.c u-boot-imx6/arch/arm/imx-common/iomux-v3.c
--- u-boot-2017.07/arch/arm/imx-common/iomux-v3.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/iomux-v3.c	2018-08-27 21:35:36.684139600 +0300
@@ -31,7 +31,7 @@
 		(pad & MUX_PAD_CTRL_OFS_MASK) >> MUX_PAD_CTRL_OFS_SHIFT;
 	u32 pad_ctrl = (pad & MUX_PAD_CTRL_MASK) >> MUX_PAD_CTRL_SHIFT;
 
-#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL)
+#if defined(CONFIG_MX6SL) || defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SX)
 	/* Check whether LVE bit needs to be set */
 	if (pad_ctrl & PAD_CTL_LVE) {
 		pad_ctrl &= ~PAD_CTL_LVE;
diff -Nru u-boot-2017.07/arch/arm/imx-common/Makefile u-boot-imx6/arch/arm/imx-common/Makefile
--- u-boot-2017.07/arch/arm/imx-common/Makefile	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/imx-common/Makefile	2018-08-27 21:35:36.684139600 +0300
@@ -23,6 +23,11 @@
 obj-$(CONFIG_SYS_I2C_MXC) += i2c-mxv7.o
 obj-$(CONFIG_SYSCOUNTER_TIMER) += syscounter.o
 endif
+
+ifeq ($(SOC),$(filter $(SOC),mx5 mx6 mx7))
+obj-$(CONFIG_CMD_FBPANEL) += fbpanel.o
+endif
+
 ifeq ($(SOC),$(filter $(SOC),mx6 mx7))
 obj-y 	+= cache.o init.o
 obj-$(CONFIG_CMD_SATA) += sata.o
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx5/imx-regs.h u-boot-imx6/arch/arm/include/asm/arch-mx5/imx-regs.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx5/imx-regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx5/imx-regs.h	2018-08-27 21:35:36.694139553 +0300
@@ -250,49 +250,92 @@
 #define M4IF_GENP_WEIM_MM_MASK		0x00000001
 #define WEIM_GCR2_MUX16_BYP_GRANT_MASK	0x00001000
 
-/* Assuming 24MHz input clock with doubler ON */
-/*                            MFI         PDF */
+/*
+ * Assuming 24MHz input clock with doubler ON
+ * fdck_2 = 4 * fref * (MFI + (MFN/MFD))/PDF
+ * fdck_2 = (MFN/MFD + MFI) * 96 /PDF
+ *
+ * (MFI >= 5) && (MFI <= 15)
+ * (PDF >= 1) && (PDF <= 16)
+ * (MFD >= 1) && (MFD <= 0x3fffffe)
+ * (MFN >= -0x3fffffe) && (MFN <= 0x3fffffe) && (|MFN| <= MFD)
+ *
+ * BRM = 0 if MFD < 8
+ * BRM = 1 if MFD >= 8
+ */
+#define MAKE_OP(mfi, pdf) (((mfi) << 4) | (pdf - 1))
+
+#define DP_CTL_RESTART	0x10
+#define DP_CTL_BRMO	0x02
+
 #define DP_OP_864	((8 << 4) + ((1 - 1)  << 0))
 #define DP_MFD_864	(180 - 1) /* PL Dither mode */
 #define DP_MFN_864	180
 #define DP_MFN_800_DIT	60 /* PL Dither mode */
+#define DP_CTL_864	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_850	((8 << 4) + ((1 - 1)  << 0))
+/* (41/48 + 8) * 96 / 1 = 850 */
+#define DP_OP_850	MAKE_OP(8, 1)
 #define DP_MFD_850	(48 - 1)
 #define DP_MFN_850	41
+#define DP_CTL_850	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_800	((8 << 4) + ((1 - 1)  << 0))
+/* (1/3 + 8) * 96 / 1 = 800 */
+#define DP_OP_800	MAKE_OP(8, 1)
 #define DP_MFD_800	(3 - 1)
 #define DP_MFN_800	1
+#define DP_CTL_800	(0x1220 | DP_CTL_RESTART)
 
-#define DP_OP_700	((7 << 4) + ((1 - 1)  << 0))
+/* (7/24 + 7) * 96 / 1 = 700 */
+#define DP_OP_700	MAKE_OP(7, 1)
 #define DP_MFD_700	(24 - 1)
 #define DP_MFN_700	7
+#define DP_CTL_700	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_665	((6 << 4) + ((1 - 1)  << 0))
+/* (89/96 + 6) * 96 / 1 = 665 */
+#define DP_OP_665	MAKE_OP(6, 1)
 #define DP_MFD_665	(96 - 1)
 #define DP_MFN_665	89
+#define DP_CTL_665	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_532	((5 << 4) + ((1 - 1)  << 0))
+/* (13/24 + 5) * 96 / 1 = 532 */
+#define DP_OP_532	MAKE_OP(5, 1)
 #define DP_MFD_532	(24 - 1)
 #define DP_MFN_532	13
+#define DP_CTL_532	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_400	((8 << 4) + ((2 - 1)  << 0))
+/* (1/3 + 8) * 96 / 2 = 400 */
+#define DP_OP_400	MAKE_OP(8, 2)
 #define DP_MFD_400	(3 - 1)
 #define DP_MFN_400	1
+#define DP_CTL_400	(0x1220 | DP_CTL_RESTART)
 
-#define DP_OP_455	((9 << 4) + ((2 - 1)  << 0))
+#define DP_OP_455	MAKE_OP(9, 2)
 #define DP_MFD_455	(48 - 1)
 #define DP_MFN_455	23
+#define DP_CTL_455	(0x1220 | DP_CTL_RESTART | DP_CTL_BRMO)
 
-#define DP_OP_216	((6 << 4) + ((3 - 1)  << 0))
+#if 0
+/* Too low, output must be 300 - 800 */
+/* (3/4 + 6) * 96 / 3 = 216 */
+#define DP_OP_216	MAKE_OP(6, 3)
 #define DP_MFD_216	(4 - 1)
 #define DP_MFN_216	3
+#define DP_CTL_216	(0x1220 | DP_CTL_RESTART)
+#else
+/* (0/2 + 9) * 96 / 2 = 432 */
+/* 432 / 2 = 216 */
+#define DP_OP_216	MAKE_OP(9, 2)
+#define DP_MFD_216	(2 - 1)
+#define DP_MFN_216	0
+#define DP_CTL_216	(0x0220 | DP_CTL_RESTART)
+#endif
 
 #define IMX_IIM_BASE            (IIM_BASE_ADDR)
 
 #if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
 #include <asm/types.h>
+void imx_get_mac_from_fuse(int dev_id, unsigned char *mac);
 
 #define __REG(x)	(*((volatile u32 *)(x)))
 #define __REG16(x)	(*((volatile u16 *)(x)))
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx5/iomux-mx51.h u-boot-imx6/arch/arm/include/asm/arch-mx5/iomux-mx51.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx5/iomux-mx51.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx5/iomux-mx51.h	2018-08-27 21:35:36.694139553 +0300
@@ -22,6 +22,8 @@
 #include <asm/imx-common/iomux-v3.h>
 
 /* Pad control groupings */
+#define MX51_AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_HIGH | \
+				PAD_CTL_HYS | PAD_CTL_SRE_FAST)
 #define MX51_UART_PAD_CTRL	(PAD_CTL_PUS_100K_DOWN | PAD_CTL_DSE_HIGH | \
 				PAD_CTL_HYS | PAD_CTL_SRE_FAST)
 #define MX51_I2C_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_ODE | \
@@ -48,25 +50,39 @@
  * See also iomux-v3.h
  */
 
+#define IOMUX_P(mux_ctrl_ofs, pad_ctrl_ofs, sel_input_ofs,		\
+		mux_mode, sel_input, pad_ctrl)				\
+		IOMUX_PAD(pad_ctrl_ofs, mux_ctrl_ofs, mux_mode,		\
+		sel_input_ofs, sel_input, pad_ctrl)
 /*							    PAD    MUX   ALT INPSE PATH PADCTRL */
 enum {
+	MX51_PAD_EIM_D16__GPIO2_0		= IOMUX_PAD(0x3f0, 0x05c, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D16__USBH2_DATA0		= IOMUX_PAD(0x3f0, 0x05c, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
+	MX51_PAD_EIM_D16__I2C1_SDA		= IOMUX_PAD(0x3f0, 0x05c, 0x14, 0x9b4, 0, MX51_I2C_PAD_CTRL),
 	MX51_PAD_EIM_D17__GPIO2_1		= IOMUX_PAD(0x3f4, 0x060, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D17__USBH2_DATA1		= IOMUX_PAD(0x3f4, 0x060, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_EIM_D18__USBH2_DATA2		= IOMUX_PAD(0x3f8, 0x064, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
+	MX51_PAD_EIM_D19__GPIO2_3		= IOMUX_PAD(0x3fc, 0x068, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D19__USBH2_DATA3		= IOMUX_PAD(0x3fc, 0x068, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
+	MX51_PAD_EIM_D19__I2C1_SCL		= IOMUX_PAD(0x3fc, 0x068, 0x14, 0x9b0, 0, MX51_I2C_PAD_CTRL),
 	MX51_PAD_EIM_D20__USBH2_DATA4		= IOMUX_PAD(0x400, 0x06c, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_EIM_D21__GPIO2_5		= IOMUX_PAD(0x404, 0x070, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D21__USBH2_DATA5		= IOMUX_PAD(0x404, 0x070, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
+	MX51_PAD_EIM_D22__GPIO2_6		= IOMUX_PAD(0x408, 0x074, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D22__USBH2_DATA6		= IOMUX_PAD(0x408, 0x074, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_EIM_D23__USBH2_DATA7		= IOMUX_PAD(0x40c, 0x078, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
+	MX51_PAD_EIM_D24__GPIO2_8		= IOMUX_PAD(0x410, 0x07c, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_EIM_D24__I2C2_SDA		= IOMUX_PAD(0x410, 0x07c, 0x14, 0x9bc, 0, MX51_I2C_PAD_CTRL),
 	MX51_PAD_EIM_D25__UART3_RXD		= IOMUX_PAD(0x414, 0x080, 3, 0x9f4, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_EIM_D26__KEY_COL7		= IOMUX_PAD(0x418, 0x084, 1, 0x9cc, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_D26__UART3_TXD		= IOMUX_PAD(0x418, 0x084, 3, __NA_, 0, MX51_UART_PAD_CTRL),
 	MX51_PAD_EIM_D27__GPIO2_9		= IOMUX_PAD(0x41c, 0x088, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_EIM_D27__I2C2_SCL		= IOMUX_PAD(0x41c, 0x088, 0x14, 0x9b8, 0, MX51_I2C_PAD_CTRL),
 	MX51_PAD_EIM_A16__GPIO2_10		= IOMUX_PAD(0x430, 0x09c, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_A17__GPIO2_11		= IOMUX_PAD(0x434, 0x0a0, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_A20__GPIO2_14		= IOMUX_PAD(0x440, 0x0ac, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_A22__GPIO2_16		= IOMUX_PAD(0x448, 0x0b4, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_EIM_A23__GPIO2_17		= IOMUX_PAD(0x44c, 0x0b8, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_EIM_A24__USBH2_CLK		= IOMUX_PAD(0x450, 0x0bc, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_EIM_A25__USBH2_DIR		= IOMUX_PAD(0x454, 0x0c0, 2, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_EIM_A26__GPIO2_20		= IOMUX_PAD(0x458, 0x0c4, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
@@ -100,17 +116,26 @@
 	MX51_PAD_DRAM_DQM2__DRAM_DQM2		= IOMUX_PAD(0x4dc, __NA_, 0, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_DRAM_DQM3__DRAM_DQM3		= IOMUX_PAD(0x4e0, __NA_, 0, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_WE_B__PATA_DIOW		= IOMUX_PAD(0x4e4, 0x108, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_WE_B__GPIO3_3		= IOMUX_PAD(0x4e4, 0x108, 3, 0x980, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_RE_B__PATA_DIOR		= IOMUX_PAD(0x4e8, 0x10c, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_RE_B__GPIO3_4		= IOMUX_PAD(0x4e8, 0x10c, 3, 0x984, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_ALE__PATA_BUFFER_EN	= IOMUX_PAD(0x4ec, 0x110, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_CLE__PATA_RESET_B	= IOMUX_PAD(0x4f0, 0x114, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_CLE__GPIO3_6		= IOMUX_PAD(0x4f0, 0x114, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_WP_B__PATA_DMACK		= IOMUX_PAD(0x4f4, 0x118, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_WP_B__GPIO3_7		= IOMUX_PAD(0x4f4, 0x118, 3, 0x990, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_RB0__PATA_DMARQ		= IOMUX_PAD(0x4f8, 0x11c, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_RB0__GPIO3_8		= IOMUX_PAD(0x4f8, 0x11c, 3, 0x994, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_RB1__PATA_IORDY		= IOMUX_PAD(0x4fc, 0x120, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_RB1__GPIO3_9		= IOMUX_PAD(0x4fc, 0x120, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_RB2__FEC_COL		= IOMUX_PAD(0x500, 0x124, 1, 0x94c, 0, MX51_PAD_CTRL_2),
 	MX51_PAD_NANDF_RB2__GPIO3_10		= IOMUX_PAD(0x500, 0x124, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_RB3__FEC_RX_CLK		= IOMUX_PAD(0x504, 0x128, 1, 0x968, 0, MX51_PAD_CTRL_2),
 	MX51_PAD_NANDF_RB3__GPIO3_11		= IOMUX_PAD(0x504, 0x128, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_GPIO_NAND__GPIO3_12		= IOMUX_PAD(0x514, 0x12c, 0, 0x998, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO_NAND__PATA_INTRQ		= IOMUX_PAD(0x514, 0x12c, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_CS0__GPIO3_16		= IOMUX_PAD(0x518, 0x130, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_NANDF_CS1__GPIO3_17		= IOMUX_PAD(0x51c, 0x134, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_CS2__FEC_TX_ER		= IOMUX_PAD(0x520, 0x138, 2, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_NANDF_CS2__PATA_CS_0		= IOMUX_PAD(0x520, 0x138, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_CS3__FEC_MDC		= IOMUX_PAD(0x524, 0x13c, 2, __NA_, 0, MX51_PAD_CTRL_5),
@@ -130,6 +155,7 @@
 	MX51_PAD_NANDF_D13__GPIO3_27		= IOMUX_PAD(0x544, 0x15c, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_D13__PATA_DATA13		= IOMUX_PAD(0x544, 0x15c, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_D12__PATA_DATA12		= IOMUX_PAD(0x548, 0x160, 1, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_NANDF_D12__GPIO3_28		= IOMUX_PAD(0x548, 0x160, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_NANDF_D11__FEC_RX_DV		= IOMUX_PAD(0x54c, 0x164, 2, 0x96c, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_D11__PATA_DATA11		= IOMUX_PAD(0x54c, 0x164, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_D10__GPIO3_30		= IOMUX_PAD(0x550, 0x168, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
@@ -147,8 +173,58 @@
 	MX51_PAD_NANDF_D2__PATA_DATA2		= IOMUX_PAD(0x570, 0x188, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_D1__PATA_DATA1		= IOMUX_PAD(0x574, 0x18c, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_NANDF_D0__PATA_DATA0		= IOMUX_PAD(0x578, 0x190, 1, __NA_, 0, NO_PAD_CTRL),
-	MX51_PAD_CSI2_D12__GPIO4_9		= IOMUX_PAD(0x5bc, 0x1cc, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
-	MX51_PAD_CSI2_D13__GPIO4_10		= IOMUX_PAD(0x5c0, 0x1d0, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI1_D8__CSI1_D8		= IOMUX_P(0x194, 0x57c, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D8__GPIO3_12		= IOMUX_P(0x194, 0x57c, 0x998, 0x3, 0x1, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI1_D9__CSI1_D9		= IOMUX_P(0x198, 0x580, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D9__GPIO3_13		= IOMUX_P(0x198, 0x580, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI1_D10__CSI1_D10		= IOMUX_P(0x19c, 0x584, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D11__CSI1_D11		= IOMUX_P(0x1a0, 0x588, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D12__CSI1_D12		= IOMUX_P(0x1a4, 0x58c, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D13__CSI1_D13		= IOMUX_P(0x1a8, 0x590, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D14__CSI1_D14		= IOMUX_P(0x1ac, 0x594, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D15__CSI1_D15		= IOMUX_P(0x1b0, 0x598, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D16__CSI1_D16		= IOMUX_P(0x1b4, 0x59c, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D17__CSI1_D17		= IOMUX_P(0x1b8, 0x5a0, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D18__CSI1_D18		= IOMUX_P(0x1bc, 0x5a4, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_D19__CSI1_D19		= IOMUX_P(0x1c0, 0x5a8, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_VSYNC__CSI1_VSYNC		= IOMUX_P(0x1c4, 0x5ac, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_VSYNC__GPIO3_14		= IOMUX_P(0x1c4, 0x5ac, __NA_, 0x3, 0x0, 0x0),
+	MX51_PAD_CSI1_HSYNC__CSI1_HSYNC		= IOMUX_P(0x1c8, 0x5b0, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_HSYNC__GPIO3_15		= IOMUX_P(0x1c8, 0x5b0, __NA_, 0x3, 0x0, 0x0),
+	MX51_PAD_CSI1_PIXCLK__CSI1_PIXCLK	= IOMUX_P(__NA_, 0x5b4, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI1_MCLK__CSI1_MCLK		= IOMUX_P(__NA_, 0x5b8, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D12__CSI2_D12		= IOMUX_P(0x1cc, 0x5bc, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D12__GPIO4_9		= IOMUX_P(0x1cc, 0x5bc, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI2_D13__CSI2_D13		= IOMUX_P(0x1d0, 0x5c0, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D13__GPIO4_10		= IOMUX_P(0x1d0, 0x5c0, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI2_D14__CSI2_D14		= IOMUX_P(0x1d4, 0x5c4, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D15__CSI2_D15		= IOMUX_P(0x1d8, 0x5c8, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D16__CSI2_D16		= IOMUX_P(0x1dc, 0x5cc, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D17__CSI2_D17		= IOMUX_P(0x1e0, 0x5d0, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D18__CSI2_D18		= IOMUX_P(0x1e4, 0x5d4, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D18__GPIO4_11		= IOMUX_P(0x1e4, 0x5d4, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI2_D19__CSI2_D19		= IOMUX_P(0x1e8, 0x5d8, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_D19__GPIO4_12		= IOMUX_P(0x1e8, 0x5d8, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_CSI2_VSYNC__CSI2_VSYNC		= IOMUX_P(0x1ec, 0x5dc, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_VSYNC__GPIO4_13		= IOMUX_P(0x1ec, 0x5dc, __NA_, 0x3, 0x0, 0x0),
+	MX51_PAD_CSI2_HSYNC__CSI2_HSYNC		= IOMUX_P(0x1f0, 0x5e0, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_HSYNC__GPIO4_14		= IOMUX_P(0x1f0, 0x5e0, __NA_, 0x3, 0x0, 0x0),
+	MX51_PAD_CSI2_PIXCLK__CSI2_PIXCLK	= IOMUX_P(0x1f4, 0x5e4, __NA_, 0x0, 0x0, 0x0),
+	MX51_PAD_CSI2_PIXCLK__GPIO4_15		= IOMUX_P(0x1f4, 0x5e4, __NA_, 0x3, 0x0, 0x0),
+	MX51_PAD_I2C1_CLK__I2C1_CLK		= IOMUX_PAD(0x5e8, 0x1f8, 0x10, __NA_, 0, MX51_I2C_PAD_CTRL),
+	MX51_PAD_I2C1_CLK__GPIO4_16		= IOMUX_PAD(0x5e8, 0x1f8, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_I2C1_DAT__I2C1_DAT		= IOMUX_PAD(0x5ec, 0x1fc, 0x10, __NA_, 0, MX51_I2C_PAD_CTRL),
+	MX51_PAD_I2C1_DAT__GPIO4_17		= IOMUX_PAD(0x5ec, 0x1fc, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_AUD3_BB_TXD__AUD3_TXD		= IOMUX_P(0x200, 0x5f0, __NA_, 0x0, 0x0, MX51_AUD_PAD_CTRL),
+	MX51_PAD_AUD3_BB_TXD__GPIO4_18		= IOMUX_P(0x200, 0x5f0, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_AUD3_BB_RXD__AUD3_RXD		= IOMUX_P(0x204, 0x5f4, __NA_, 0x0, 0x0, MX51_AUD_PAD_CTRL),
+	MX51_PAD_AUD3_BB_RXD__GPIO4_19		= IOMUX_P(0x204, 0x5f4, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_AUD3_BB_RXD__UART3_RXD		= IOMUX_P(0x204, 0x5f4, 0x9f4, 0x1, 0x2, MX51_UART_PAD_CTRL),
+	MX51_PAD_AUD3_BB_CK__AUD3_TXC		= IOMUX_P(0x208, 0x5f8, __NA_, 0x0, 0x0, MX51_AUD_PAD_CTRL),
+	MX51_PAD_AUD3_BB_CK__GPIO4_20		= IOMUX_P(0x208, 0x5f8, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_AUD3_BB_FS__AUD3_TXFS		= IOMUX_P(0x20c, 0x5fc, __NA_, 0x0, 0x0, MX51_AUD_PAD_CTRL),
+	MX51_PAD_AUD3_BB_FS__GPIO4_21		= IOMUX_P(0x20c, 0x5fc, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_AUD3_BB_FS__UART3_TXD		= IOMUX_P(0x20c, 0x5fc, __NA_, 0x1, 0x0, MX51_UART_PAD_CTRL),
 	MX51_PAD_CSPI1_MOSI__ECSPI1_MOSI	= IOMUX_PAD(0x600, 0x210, 0, __NA_, 0, MX51_ECSPI_PAD_CTRL),
 	MX51_PAD_CSPI1_MISO__ECSPI1_MISO	= IOMUX_PAD(0x604, 0x214, 0, __NA_, 0, MX51_ECSPI_PAD_CTRL),
 	MX51_PAD_CSPI1_SS0__ECSPI1_SS0		= IOMUX_PAD(0x608, 0x218, 0, __NA_, 0, MX51_ECSPI_PAD_CTRL),
@@ -159,9 +235,17 @@
 	MX51_PAD_CSPI1_RDY__GPIO4_26		= IOMUX_PAD(0x610, 0x220, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_CSPI1_SCLK__ECSPI1_SCLK	= IOMUX_PAD(0x614, 0x224, 0, __NA_, 0, MX51_ECSPI_PAD_CTRL),
 	MX51_PAD_UART1_RXD__UART1_RXD		= IOMUX_PAD(0x618, 0x228, 0, 0x9e4, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART1_RXD__GPIO4_28		= IOMUX_P(0x228, 0x618, __NA_, 0x3, 0x0, MX51_UART_PAD_CTRL),
 	MX51_PAD_UART1_TXD__UART1_TXD		= IOMUX_PAD(0x61c, 0x22c, 0, __NA_, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART1_TXD__GPIO4_29		= IOMUX_P(0x22c, 0x61c, __NA_, 0x3, 0x0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_UART1_RTS__UART1_RTS		= IOMUX_PAD(0x620, 0x230, 0, 0x9e0, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART1_RTS__GPIO4_30		= IOMUX_PAD(0x620, 0x230, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_UART1_CTS__UART1_CTS		= IOMUX_PAD(0x624, 0x234, 0, __NA_, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART1_CTS__GPIO4_31		= IOMUX_PAD(0x624, 0x234, 3, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_UART2_RXD__UART2_RXD		= IOMUX_PAD(0x628, 0x238, 0, 0x9ec, 2, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART2_TXD__UART2_TXD		= IOMUX_PAD(0x62c, 0x23c, 0, __NA_, 0, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART3_RXD__UART3_RXD		= IOMUX_PAD(0x630, 0x240, 1, 0x9f4, 4, MX51_UART_PAD_CTRL),
+	MX51_PAD_UART3_TXD__UART3_TXD		= IOMUX_PAD(0x634, 0x244, 1, __NA_, 0, MX51_UART_PAD_CTRL),
 	MX51_PAD_USBH1_CLK__USBH1_CLK		= IOMUX_PAD(0x678, 0x278, 0, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_USBH1_DIR__USBH1_DIR		= IOMUX_PAD(0x67c, 0x27c, 0, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_USBH1_STP__GPIO1_27		= IOMUX_PAD(0x680, 0x280, 2, __NA_, 0, MX51_GPIO_PAD_CTRL),
@@ -176,50 +260,97 @@
 	MX51_PAD_USBH1_DATA6__USBH1_DATA6	= IOMUX_PAD(0x6a0, 0x2a0, 0, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_USBH1_DATA7__USBH1_DATA7	= IOMUX_PAD(0x6a4, 0x2a4, 0, __NA_, 0, MX51_USBH_PAD_CTRL),
 	MX51_PAD_DI1_PIN11__ECSPI1_SS2		= IOMUX_PAD(0x6a8, 0x2a8, 7, __NA_, 0, MX51_ECSPI_PAD_CTRL),
+	MX51_PAD_DI1_PIN11__GPIO3_0		= IOMUX_P(0x2a8, 0x6a8, __NA_, 0x4, 0x0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DI1_PIN12__GPIO3_1		= IOMUX_PAD(0x6ac, 0x2ac, 4, 0x978, 1, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DI1_PIN13__GPIO3_2		= IOMUX_PAD(0x6b0, 0x2b0, 4, 0x97c, 1, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DI1_D0_CS__GPIO3_3		= IOMUX_PAD(0x6b4, 0x2b4, 4, 0x980, 1, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DI1_D1_CS__GPIO3_4		= IOMUX_PAD(0x6b8, 0x2b8, 4, 0x984, 1, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DISPB2_SER_DIN__GPIO3_5	= IOMUX_PAD(0x6bc, 0x2bc, 4, 0x988, 1, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_DISPB2_SER_DIO__GPIO3_6	= IOMUX_PAD(0x6c0, 0x2c0, 4, 0x98c, 1, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_DISP1_DAT0__DISP1_DAT0		= IOMUX_PAD(0x6cc, 0x2cc, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT1__DISP1_DAT1		= IOMUX_PAD(0x6d0, 0x2d0, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT2__DISP1_DAT2		= IOMUX_PAD(0x6d4, 0x2d4, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT3__DISP1_DAT3		= IOMUX_PAD(0x6d8, 0x2d8, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT4__DISP1_DAT4		= IOMUX_PAD(0x6dc, 0x2dc, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT5__DISP1_DAT5		= IOMUX_PAD(0x6e0, 0x2e0, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT6__DISP1_DAT6		= IOMUX_PAD(0x6e4, 0x2e4, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT7__DISP1_DAT7		= IOMUX_PAD(0x6e8, 0x2e8, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT8__DISP1_DAT8		= IOMUX_PAD(0x6ec, 0x2ec, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT9__DISP1_DAT9		= IOMUX_PAD(0x6f0, 0x2f0, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT10__DISP1_DAT10	= IOMUX_PAD(0x6f4, 0x2f4, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT11__DISP1_DAT11	= IOMUX_PAD(0x6f8, 0x2f8, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT12__DISP1_DAT12	= IOMUX_PAD(0x6fc, 0x2fc, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT13__DISP1_DAT13	= IOMUX_PAD(0x700, 0x300, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT14__DISP1_DAT14	= IOMUX_PAD(0x704, 0x304, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT15__DISP1_DAT15	= IOMUX_PAD(0x708, 0x308, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT16__DISP1_DAT16	= IOMUX_PAD(0x70c, 0x30c, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT17__DISP1_DAT17	= IOMUX_PAD(0x710, 0x310, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT18__DISP1_DAT18	= IOMUX_PAD(0x714, 0x314, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT19__DISP1_DAT19	= IOMUX_PAD(0x718, 0x318, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT20__DISP1_DAT20	= IOMUX_PAD(0x71c, 0x31c, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT21__DISP1_DAT21	= IOMUX_PAD(0x720, 0x320, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT22__DISP1_DAT22	= IOMUX_PAD(0x724, 0x324, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP1_DAT23__DISP1_DAT23	= IOMUX_PAD(0x728, 0x328, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DI1_PIN3__DI1_PIN3		= IOMUX_PAD(0x72c, 0x32c, 0, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_DI1_DISP_CLK__DI1_DISP_CLK	= IOMUX_PAD(0x730, 0x000, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DI1_PIN2__DI1_PIN2		= IOMUX_PAD(0x734, 0x330, 0, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_DI1_PIN15__DI1_PIN15		= IOMUX_PAD(0x738, 0x000, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DI2_PIN2__FEC_MDC		= IOMUX_PAD(0x74C, 0x344, 2, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DI2_DISP_CLK__DI2_DISP_CLK	= IOMUX_PAD(0x754, 0x34c, 0, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_DI_GP4__DI2_PIN15		= IOMUX_PAD(0x758, 0x350, 4, __NA_, 0, NO_PAD_CTRL),
+	MX51_PAD_DISP2_DAT0__DISP2_DAT0		= IOMUX_PAD(0x75c, 0x354, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT1__DISP2_DAT1		= IOMUX_PAD(0x760, 0x358, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT2__DISP2_DAT2		= IOMUX_PAD(0x764, 0x35c, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT3__DISP2_DAT3		= IOMUX_PAD(0x768, 0x360, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT4__DISP2_DAT4		= IOMUX_PAD(0x76c, 0x364, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT5__DISP2_DAT5		= IOMUX_PAD(0x770, 0x368, 0, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT6__DISP2_DAT6		= IOMUX_PAD(0x774, 0x36c, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT6__FEC_TDAT1		= IOMUX_PAD(0x774, 0x36C, 2, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT7__DISP2_DAT7		= IOMUX_PAD(0x778, 0x370, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT7__FEC_TDAT2		= IOMUX_PAD(0x778, 0x370, 2, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT8__DISP2_DAT8		= IOMUX_PAD(0x77c, 0x374, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT8__FEC_TDAT3		= IOMUX_PAD(0x77C, 0x374, 2, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT9__DISP2_DAT9		= IOMUX_PAD(0x780, 0x378, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT9__FEC_TX_EN		= IOMUX_PAD(0x780, 0x378, 2, __NA_, 0, MX51_PAD_CTRL_5),
+	MX51_PAD_DISP2_DAT10__DISP2_DAT10	= IOMUX_PAD(0x784, 0x37c, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT10__FEC_COL		= IOMUX_PAD(0x784, 0x37C, 2, 0x94c, 0x1, MX51_PAD_CTRL_2),
+	MX51_PAD_DISP2_DAT11__DISP2_DAT11	= IOMUX_PAD(0x788, 0x380, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT11__FEC_RXCLK		= IOMUX_PAD(0x788, 0x380, 2, 0x968, 0x1, MX51_PAD_CTRL_2),
+	MX51_PAD_DISP2_DAT12__DISP2_DAT12	= IOMUX_PAD(0x78c, 0x384, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT12__FEC_RX_DV		= IOMUX_PAD(0x78C, 0x384, 2, 0x96c, 0x1, MX51_PAD_CTRL_4),
+	MX51_PAD_DISP2_DAT13__DISP2_DAT13	= IOMUX_PAD(0x790, 0x388, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT13__FEC_TX_CLK	= IOMUX_PAD(0x790, 0x388, 2, 0x974, 0x1, MX51_PAD_CTRL_4),
+	MX51_PAD_DISP2_DAT14__DISP2_DAT14	= IOMUX_PAD(0x794, 0x38c, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT14__FEC_RDAT0		= IOMUX_PAD(0x794, 0x38C, 2, 0x958, 0x1, MX51_PAD_CTRL_4),
+	MX51_PAD_DISP2_DAT15__DISP2_DAT15	= IOMUX_PAD(0x798, 0x390, 0, __NA_, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_DISP2_DAT15__FEC_TDAT0		= IOMUX_PAD(0x798, 0x390, 2, 0x0, 0, MX51_PAD_CTRL_5),
 	MX51_PAD_SD1_CMD__SD1_CMD		= IOMUX_PAD(0x79c, 0x394, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD1_CLK__SD1_CLK		= IOMUX_PAD(0x7a0, 0x398, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL | PAD_CTL_HYS),
-	MX51_PAD_SD1_DATA0__SD1_DATA0		= IOMUX_PAD(0x7a4, 0x39c, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD1_DATA1__SD1_DATA1		= IOMUX_PAD(0x7a8, 0x3a0, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD1_DATA2__SD1_DATA2		= IOMUX_PAD(0x7ac, 0x3a4, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD1_DATA3__SD1_DATA3		= IOMUX_PAD(0x7b0, 0x3a8, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD1_CLK__SD1_CLK		= IOMUX_PAD(0x7a0, 0x398, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL | PAD_CTL_HYS),
+	MX51_PAD_SD1_DATA0__SD1_DATA0		= IOMUX_PAD(0x7a4, 0x39c, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD1_DATA1__SD1_DATA1		= IOMUX_PAD(0x7a8, 0x3a0, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD1_DATA2__SD1_DATA2		= IOMUX_PAD(0x7ac, 0x3a4, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD1_DATA3__SD1_DATA3		= IOMUX_PAD(0x7b0, 0x3a8, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
 	MX51_PAD_GPIO1_0__GPIO1_0		= IOMUX_PAD(0x7b4, 0x3ac, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_0__SD1_CD		= IOMUX_PAD(0x7b4, 0x3ac, 0, __NA_, 0, MX51_ESDHC_PAD_CTRL),
 	MX51_PAD_GPIO1_1__SD1_WP		= IOMUX_PAD(0x7b8, 0x3b0, 0, __NA_, 0, MX51_ESDHC_PAD_CTRL),
+	MX51_PAD_GPIO1_1__GPIO1_1		= IOMUX_PAD(0x7b8, 0x3b0, 1, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_SD2_CMD__SD2_CMD		= IOMUX_PAD(0x7bc, 0x3b4, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD2_CLK__SD2_CLK		= IOMUX_PAD(0x7c0, 0x3b8, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL | PAD_CTL_HYS),
-	MX51_PAD_SD2_DATA0__SD2_DATA0		= IOMUX_PAD(0x7c4, 0x3bc, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD2_DATA1__SD2_DATA1		= IOMUX_PAD(0x7c8, 0x3c0, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD2_DATA2__SD2_DATA2		= IOMUX_PAD(0x7cc, 0x3c4, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
-	MX51_PAD_SD2_DATA3__SD2_DATA3		= IOMUX_PAD(0x7d0, 0x3c8, 0x10, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD2_CLK__SD2_CLK		= IOMUX_PAD(0x7c0, 0x3b8, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL | PAD_CTL_HYS),
+	MX51_PAD_SD2_DATA0__SD2_DATA0		= IOMUX_PAD(0x7c4, 0x3bc, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD2_DATA1__SD2_DATA1		= IOMUX_PAD(0x7c8, 0x3c0, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD2_DATA2__SD2_DATA2		= IOMUX_PAD(0x7cc, 0x3c4, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
+	MX51_PAD_SD2_DATA3__SD2_DATA3		= IOMUX_PAD(0x7d0, 0x3c8, 0, __NA_, 0, MX51_SDHCI_PAD_CTRL),
 	MX51_PAD_GPIO1_2__GPIO1_2		= IOMUX_PAD(0x7d4, 0x3cc, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_2__PWM1_PWMO		= IOMUX_PAD(0x7d4, 0x3cc, 1, __NA_, 0, NO_PAD_CTRL),
 	MX51_PAD_GPIO1_3__GPIO1_3		= IOMUX_PAD(0x7d8, 0x3d0, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
+	MX51_PAD_GPIO1_4__GPIO1_4		= IOMUX_PAD(0x804, 0x3d8, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_5__GPIO1_5		= IOMUX_PAD(0x808, 0x3dc, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_6__GPIO1_6		= IOMUX_PAD(0x80c, 0x3e0, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_7__GPIO1_7		= IOMUX_PAD(0x810, 0x3e4, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_7__SD2_WP		= IOMUX_PAD(0x810, 0x3e4, 6, __NA_, 0, MX51_ESDHC_PAD_CTRL),
+	MX51_PAD_GPIO1_8__GPIO1_8		= IOMUX_PAD(0x814, 0x3e8, 0, __NA_, 0, MX51_GPIO_PAD_CTRL),
 	MX51_PAD_GPIO1_8__SD2_CD		= IOMUX_PAD(0x814, 0x3e8, 6, __NA_, 0, MX51_ESDHC_PAD_CTRL),
+	MX51_PAD_GPIO1_9__GPIO1_9		= IOMUX_P(0x3ec, 0x818, __NA_, 0x0, 0x0, MX51_GPIO_PAD_CTRL),
 	MX51_GRP_DDRPKS				= IOMUX_PAD(0x820, __NA_, 0, __NA_, 0, NO_PAD_CTRL),
 	MX51_GRP_DRAM_B4			= IOMUX_PAD(0x82c, __NA_, 0, __NA_, 0, NO_PAD_CTRL),
 	MX51_GRP_PKEDDR				= IOMUX_PAD(0x838, __NA_, 0, __NA_, 0, NO_PAD_CTRL),
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx6/crm_regs.h u-boot-imx6/arch/arm/include/asm/arch-mx6/crm_regs.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx6/crm_regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx6/crm_regs.h	2018-08-27 21:35:36.697472870 +0300
@@ -7,6 +7,7 @@
 #ifndef __ARCH_ARM_MACH_MX6_CCM_REGS_H__
 #define __ARCH_ARM_MACH_MX6_CCM_REGS_H__
 
+#define CCM_CBCMR		0x020c4018
 #define CCM_CCOSR		0x020c4060
 #define CCM_CCGR0		0x020C4068
 #define CCM_CCGR1		0x020C406c
@@ -15,7 +16,9 @@
 #define CCM_CCGR4		0x020C4078
 #define CCM_CCGR5		0x020C407c
 #define CCM_CCGR6		0x020C4080
+#define CCM_CCGR7		0x020C4084
 
+#define CCM_ANALOG_PFD_528	0x020c8100
 #define PMU_MISC2		0x020C8170
 
 #ifndef __ASSEMBLY__
@@ -508,8 +511,12 @@
 #define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK		(0x7 << 9)
 #define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET		9
 
+#define CHSCCDR_CLK_SEL_IPU1_DI0			0
 #define CHSCCDR_CLK_SEL_LDB_DI0				3
+#define CHSCCDR_CLK_SEL_LDB_DI1				4
+
 #define CHSCCDR_PODF_DIVIDE_BY_3			2
+#define CHSCCDR_IPU_PRE_CLK_PLL5			2
 #define CHSCCDR_IPU_PRE_CLK_540M_PFD			5
 
 /* Define the bits in register CSCDR2 */
@@ -1307,4 +1314,6 @@
 	((v & BM_PMU_MISC2_AUDIO_DIV_LSB) >> \
 	 BP_PMU_MISC2_AUDIO_DIV_LSB))
 
+#define BF_PMU_MISC2_VIDEO_DIV(v)  ((v) << 30)
+
 #endif /*__ARCH_ARM_MACH_MX6_CCM_REGS_H__ */
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx6/imx-regs.h u-boot-imx6/arch/arm/include/asm/arch-mx6/imx-regs.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx6/imx-regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx6/imx-regs.h	2018-08-27 21:35:36.697472870 +0300
@@ -480,6 +480,47 @@
 #define SRC_SCR_M4C_NON_SCLR_RST_OFFSET         4
 #define SRC_SCR_M4C_NON_SCLR_RST_MASK           (1 << 4)
 
+struct snvs_regs {
+	u32 hplr;	/* 0x00, lock register */
+	u32 hpcomr;	/* 0x04, command reg */
+	u32 hpcr;	/* 0x08, control reg */
+	u32 hpsicr;	/* 0x0c, security interrupt control */
+	u32 hpsvcr;	/* 0x10, security violation control */
+	u32 hpsr;	/* 0x14, status reg */
+	u32 hpsvsr;	/* 0x18, security violation status */
+	u32 hphacivr;	/* 0x1c, high assurance counter IV */
+	u32 hphacr;	/* 0x20, high assurance counter */
+	u32 hprtcmr;	/* 0x24, real time counter MSB */
+	u32 hprtclr;	/* 0x28, real time counter LSB */
+	u32 hptamr;	/* 0x2c, time alarm MSB */
+	u32 hptalr;	/* 0x30, time alarm LSB */
+	u32 lplr;	/* 0x34, lock register */
+	u32 lpcr;	/* 0x38, control reg */
+	u32 lpmkcr;	/* 0x3c, master key control */
+	u32 lpsvcr;	/* 0x40, security violation control */
+	u32 lptgfcr;	/* 0x44, tamper glitch filters config */
+	u32 lptdcr;	/* 0x48, tamper detectors config */
+	u32 lpsr;	/* 0x4c, status reg */
+	u32 lpsrtcmr;	/* 0x50, secure real time counter MSB */
+	u32 lpsrtclr;	/* 0x54, secure real time counter LSB */
+	u32 lptar;	/* 0x58, time alarm reg */
+	u32 lpsmcmr;	/* 0x5c, secure monotonic counter MSB */
+	u32 lpsmclr;	/* 0x60, secure monotonic counter LSB */
+	u32 lppgdr;	/* 0x64, power glitch detector */
+	u32 lpgpr;	/* 0x68, general purpose reg */
+	u32 lpzmkr0;	/* 0x6c, zeroizable master key */
+	u32 lpzmkr1;	/* 0x70, zeroizable master key */
+	u32 lpzmkr2;	/* 0x74, zeroizable master key */
+	u32 lpzmkr3;	/* 0x78, zeroizable master key */
+	u32 lpzmkr4;	/* 0x7c, zeroizable master key */
+	u32 lpzmkr5;	/* 0x80, zeroizable master key */
+	u32 lpzmkr6;	/* 0x84, zeroizable master key */
+	u32 lpzmkr7;	/* 0x88, zeroizable master key */
+	u8 spare_block[0xbf8 - 0x8c];	/* 0x8c */
+	u32 hpvidr1;	/* 0xbf8 */
+	u32 hpvidr2;	/* 0xbfc */
+};
+
 /* GPR1 bitfields */
 #define IOMUXC_GPR1_APP_CLK_REQ_N		BIT(30)
 #define IOMUXC_GPR1_PCIE_EXIT_L1		BIT(28)
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx7/clock.h u-boot-imx6/arch/arm/include/asm/arch-mx7/clock.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx7/clock.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx7/clock.h	2018-08-27 21:35:36.700806187 +0300
@@ -334,7 +334,7 @@
 #ifdef CONFIG_FEC_MXC
 int set_clk_enet(enum enet_freq type);
 #endif
-int set_clk_qspi(void);
+int set_clk_qspi(u32 freq);
 int set_clk_nand(void);
 #ifdef CONFIG_MXC_OCOTP
 void enable_ocotp_clk(unsigned char enable);
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx7/crm_regs.h u-boot-imx6/arch/arm/include/asm/arch-mx7/crm_regs.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx7/crm_regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx7/crm_regs.h	2018-08-27 21:35:36.700806187 +0300
@@ -2091,18 +2091,18 @@
 #define DRAM_CLK_ROOT_POST_DIV_MASK	0x00000007
 #define CLK_ROOT_POST_DIV_MASK	0x0000003f
 #define CLK_ROOT_POST_DIV_SHIFT	0
-#define CLK_ROOT_POST_DIV(n) ((n << CLK_ROOT_POST_DIV_SHIFT) & CLK_ROOT_POST_DIV_MASK)
+#define CLK_ROOT_POST_DIV(n) (((n) << CLK_ROOT_POST_DIV_SHIFT) & CLK_ROOT_POST_DIV_MASK)
 
 #define CLK_ROOT_AUTO_DIV_MASK	0x00000700
 #define CLK_ROOT_AUTO_DIV_SHIFT	8
-#define CLK_ROOT_AUTO_DIV(n) ((n << CLK_ROOT_AUTO_DIV_SHIFT) & CLK_ROOT_AUTO_DIV_MASK)
+#define CLK_ROOT_AUTO_DIV(n) (((n) << CLK_ROOT_AUTO_DIV_SHIFT) & CLK_ROOT_AUTO_DIV_MASK)
 
 #define CLK_ROOT_AUTO_EN_MASK	0x00001000
 #define CLK_ROOT_AUTO_EN	0x00001000
 
 #define CLK_ROOT_PRE_DIV_MASK	0x00070000
 #define CLK_ROOT_PRE_DIV_SHIFT	16
-#define CLK_ROOT_PRE_DIV(n) ((n << CLK_ROOT_PRE_DIV_SHIFT) & CLK_ROOT_PRE_DIV_MASK)
+#define CLK_ROOT_PRE_DIV(n) (((n) << CLK_ROOT_PRE_DIV_SHIFT) & CLK_ROOT_PRE_DIV_MASK)
 
 #define CLK_ROOT_MUX_MASK	0x07000000
 #define CLK_ROOT_MUX_SHIFT	24
diff -Nru u-boot-2017.07/arch/arm/include/asm/arch-mx7/imx-regs.h u-boot-imx6/arch/arm/include/asm/arch-mx7/imx-regs.h
--- u-boot-2017.07/arch/arm/include/asm/arch-mx7/imx-regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/arch-mx7/imx-regs.h	2018-08-27 21:35:36.700806187 +0300
@@ -56,6 +56,8 @@
 
 #define QSPI0_ARB_BASE_ADDR             0x60000000
 #define QSPI0_ARB_END_ADDR              0x6FFFFFFF
+#define QSPI0_AMBA_BASE		QSPI0_ARB_BASE_ADDR
+#define QSPI0_AMBA_END		QSPI0_ARB_END_ADDR
 #define PCIE_ARB_BASE_ADDR              0x40000000
 #define PCIE_ARB_END_ADDR               0x4FFFFFFF
 #define PCIE_REG_BASE_ADDR              0x33800000
@@ -194,6 +196,7 @@
 #define SIM1_IPS_BASE_ADDR              (AIPS3_OFF_BASE_ADDR+0x190000)
 #define SIM2_IPS_BASE_ADDR              (AIPS3_OFF_BASE_ADDR+0x1A0000)
 #define QSPI1_IPS_BASE_ADDR             (AIPS3_OFF_BASE_ADDR+0x1B0000)
+#define QSPI0_BASE_ADDR			QSPI1_IPS_BASE_ADDR
 #define WEIM_IPS_BASE_ADDR              (AIPS3_OFF_BASE_ADDR+0x1C0000)
 #define SDMA_PORT_IPS_HOST_BASE_ADDR    (AIPS3_OFF_BASE_ADDR+0x1D0000)
 #define ENET_IPS_BASE_ADDR              (AIPS3_OFF_BASE_ADDR+0x1E0000)
diff -Nru u-boot-2017.07/arch/arm/include/asm/imx-common/fbpanel.h u-boot-imx6/arch/arm/include/asm/imx-common/fbpanel.h
--- u-boot-2017.07/arch/arm/include/asm/imx-common/fbpanel.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/imx-common/fbpanel.h	2018-08-27 21:35:36.720806093 +0300
@@ -0,0 +1,1191 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __IMX_VIDEO_H_
+#define __IMX_VIDEO_H_
+
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+
+struct display_info_t {
+	int	bus;	/* (bus >> 8) is gpio to enable bus if <>0 */
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev, int enable);
+	void	(*pre_enable)(struct display_info_t const *dev);
+	int	pwm_period;
+#define FB_HDMI		0
+#define FB_LCD		1
+#define FB_LCD2		2
+#define FB_LVDS		3
+#define FB_LVDS2	4
+#define FB_COUNT	5
+	int	fbtype;
+
+#define FBF_MODESTR	1
+#define FBF_JEIDA	2
+#define FBF_SPLITMODE	4
+#define FBF_SPI		8
+#define FBF_BKLIT_LOW_ACTIVE	0x10
+#define FBF_BKLIT_DTB		0x20
+	int	fbflags;
+	struct	fb_videomode mode;
+};
+int ipu_set_ldb_clock(int rate);
+
+void board_enable_hdmi(const struct display_info_t *di, int enable);
+void board_enable_lcd(const struct display_info_t *di, int enable);
+void board_enable_lvds(const struct display_info_t *di, int enable);
+void board_enable_lvds2(const struct display_info_t *di, int enable);
+
+void fbp_enable_fb(struct display_info_t const *di, int enable);
+int fbp_detect_i2c(struct display_info_t const *di);
+void fbp_setup_display(const struct display_info_t *displays, int cnt);
+
+#define VD_1280_720M_60(_mode, _detect, _bus, _addr)	VDF_1280_720M_60(_mode, "1280x720M@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_1920_1080M_60(_mode, _detect, _bus, _addr)	VDF_1920_1080M_60(_mode, "1920x1080M@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_1024_768M_60(_mode, _detect, _bus, _addr)	VDF_1024_768M_60(_mode, "1024x768M@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_800_600MR_60(_mode, _detect, _bus, _addr)	VDF_800_600MR_60(_mode, "800x600MR@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_640_480M_60(_mode, _detect, _bus, _addr)	VDF_640_480M_60(_mode, "640x480M@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_720_480M_60(_mode, _detect, _bus, _addr)	VDF_720_480M_60(_mode, "720x480M@60", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_CLAA_WVGA(_mode, _detect, _bus, _addr)	VDF_CLAA_WVGA(_mode, "CLAA-WVGA", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_SHARP_WVGA(_mode, _detect, _bus, _addr)	VDF_SHARP_WVGA(_mode, "sharp-wvga", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_TFC_A9700LTWV35TC_C1(_mode, _detect, _bus, _addr)	VDF_TFC_A9700LTWV35TC_C1(_mode, "tfc-a9700ltwv35tc-c1", RGB24, 0, _detect, _bus, _addr)
+#define VD_800X300_565(_mode, _detect, _bus, _addr)	VDF_800X300(_mode, "800x300rgb565", RGB565, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_HITACHI_HVGA(_mode, _detect, _bus, _addr)	VDF_HITACHI_HVGA(_mode, "hitachi_hvga", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_HITACHI_HVGA565(_mode, _detect, _bus, _addr)	VDF_HITACHI_HVGA(_mode, "hitachi_hvga565", RGB565, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_NEON_TOUCH640X240(_mode, _detect, _bus, _addr) VDF_NEON_TOUCH640X240(_mode, "NeonTouch640x240", RGB565, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_DC050WX(_mode, _detect, _bus, _addr)		VDF_DC050WX(_mode, "DC050WX", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_INNOLUX_WXGA_14IN_12V(_mode, _detect, _bus, _addr) VDF_INNOLUX_WXGA_14IN_12V(_mode, "INNOLUX-WXGA-IN14-12V", RGB666, 0, _detect, _bus, _addr)
+#define VD_AUO_WXGA_11IN_12V(_mode, _detect, _bus, _addr) VDF_AUO_WXGA_11IN_12V(_mode, "AUO-WXGA-IN11-12V", RGB24, 0, _detect, _bus, _addr)
+#define VD_OSD_WSVGA(_mode, _detect, _bus, _addr)	VDF_OSD_WSVGA(_mode, "OSD-WSVGA", RGB666, 0, _detect, _bus, _addr)
+#define VD_INNOLUX_WVGA(_mode, _detect, _bus, _addr)	VDF_INNOLUX_WVGA(_mode, "INNOLUX-WVGA", RGB666, 0, _detect, _bus, _addr)
+#define VD_INNOLUX_WVGA_12V(_mode, _detect, _bus, _addr) VDF_INNOLUX_WVGA(_mode, "INNOLUX-WVGA-12V", RGB666, 0, _detect, _bus, _addr)
+#define VD_INNOLUX_WVGA_M(_mode, _detect, _bus, _addr)	VDF_INNOLUX_WVGA(_mode, "INNOLUX-WVGA", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_OKAYA_480_272(_mode, _detect, _bus, _addr)	VDF_OKAYA_480_272(_mode, "okaya_480x272", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_QVGA(_mode, _detect, _bus, _addr)		VDF_QVGA(_mode, "qvga", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_DT035BTFT(_mode, _detect, _bus, _addr)	VDF_DT035BTFT(_mode, "DT035BTFT", BGR24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_AT035GT_07ET3(_mode, _detect, _bus, _addr)	VDF_AT035GT_07ET3(_mode, "AT035GT-07ET3", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_AMP1024_600(_mode, _detect, _bus, _addr)	VDF_AMP1024_600(_mode, "amp1024x600", RGB666, 0, _detect, _bus, _addr)
+#define VD_ND1024_600(_mode, _detect, _bus, _addr)	VDF_ND1024_600(_mode, "ND-070PCAP-1024x600", RGB24, 0, _detect, _bus, _addr)
+#define VD_TM070JDHG30(_mode, _detect, _bus, _addr)	VDF_TM070JDHG30(_mode, "tm070jdhg30", RGB24, 0, _detect, _bus, _addr)
+#define VD_AUO_B101EW05(_mode, _detect, _bus, _addr)	VDF_AUO_B101EW05(_mode, "auo_b101ew05", RGB666, 0, _detect, _bus, _addr)
+#define VD_HANNSTAR7(_mode, _detect, _bus, _addr)	VDF_HANNSTAR7(_mode, "hannstar7", RGB666, 0, _detect, _bus, _addr)
+#define VD_LG1280_800(_mode, _detect, _bus, _addr)	VDF_HANNSTAR7(_mode, "lg1280x800", RGB666, 0, _detect, _bus, _addr)
+#define VD_M101NWWB(_mode, _detect, _bus, _addr)	VDF_HANNSTAR7(_mode, "M101NWWB", RGB24, 0, _detect, _bus, _addr)
+#define VD_LD101WX1(_mode, _detect, _bus, _addr)	VDF_HANNSTAR7(_mode, "ld101wx1", RGB24, 0, _detect, _bus, _addr)
+#define VD_DT070BTFT(_mode, _detect, _bus, _addr)	VDF_DT070BTFT(_mode, "dt070btft", RGB24, FBF_JEIDA, _detect, _bus, _addr)
+#define VD_WSVGA(_mode, _detect, _bus, _addr)		VDF_WSVGA(_mode, "wsvga", RGB666, 0, _detect, _bus, _addr)
+#define VD_ASIT500MA6F5D(_mode, _detect, _bus, _addr)	VDF_ASIT500MA6F5D(_mode, "ASIT500MA6F5D", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_FUSION7(_mode, _detect, _bus, _addr)		VDF_FUSION7(_mode, "fusion7", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_HANNSTAR(_mode, _detect, _bus, _addr)	VDF_HANNSTAR(_mode, "hannstar", RGB666, 0, _detect, _bus, _addr)
+#define VD_1024_600(_mode, _detect, _bus, _addr)	VDF_1024_600(_mode, "1024x600", RGB666, 0, _detect, _bus, _addr)
+#define VD_AFK1024600A02(_mode, _detect, _bus, _addr)	VDF_AFK1024600A02(_mode, "AFK1024600A02", RGB24, 0, _detect, _bus, _addr)
+#define VD_LG9_7(_mode, _detect, _bus, _addr)		VDF_LG9_7(_mode, "lg9.7", RGB666, 0, _detect, _bus, _addr)
+#define VD_1080P60(_mode, _detect, _bus, _addr)		VDF_1080P60(_mode, "1080P60", RGB24, FBF_SPLITMODE, _detect, _bus, _addr)
+#define VD_1080P60_J(_mode, _detect, _bus, _addr)	VDF_1080P60(_mode, "1080P60_J", RGB24, FBF_SPLITMODE | FBF_JEIDA, _detect, _bus, _addr)
+#define VD_DV210FBM(_mode, _detect, _bus, _addr)	VDF_DV210FBM(_mode, "dv210fbm", RGB24, FBF_SPLITMODE, _detect, _bus, _addr)
+#define VD_SHARP_LQ101K1LY04(_mode, _detect, _bus, _addr) VDF_SHARP_LQ101K1LY04(_mode, "sharp-LQ101K1LY04", RGB24, FBF_JEIDA, _detect, _bus, _addr)
+#define VD_WXGA(_mode, _detect, _bus, _addr)		VDF_WXGA(_mode, "wxga", RGB24, 0, _detect, _bus, _addr)
+#define VD_WXGA_J(_mode, _detect, _bus, _addr)		VDF_WXGA(_mode, "wxga_j", RGB24, FBF_JEIDA, _detect, _bus, _addr)
+#define VD_LD070WSVGA(_mode, _detect, _bus, _addr)	VDF_LD070WSVGA(_mode, "ld070wsvga", RGB24, 0, _detect, _bus, _addr)
+#define VD_SVGA(_mode, _detect, _bus, _addr)		VDF_SVGA(_mode, "svga", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_24(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_24", RGB24, 0, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_24H(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_24h", RGB24, FBF_BKLIT_DTB, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_24L(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_24l", RGB24, FBF_BKLIT_DTB | FBF_BKLIT_LOW_ACTIVE, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_18(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_18", RGB666, 0, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_18H(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_18h", RGB666, FBF_BKLIT_DTB, _detect, _bus, _addr)
+#define VD_WVGA_TX23D200_18L(_mode, _detect, _bus, _addr) VDF_WVGA_TX23D200(_mode, "tx23d200_18l", RGB666, FBF_BKLIT_DTB | FBF_BKLIT_LOW_ACTIVE, _detect, _bus, _addr)
+#define VD_WVGA(_mode, _detect, _bus, _addr)		VDF_WVGA(_mode, "wvga", RGB666, 0, _detect, _bus, _addr)
+#define VD_WVGA_J(_mode, _detect, _bus, _addr)		VDF_WVGA(_mode, "wvga_j", RGB24, FBF_JEIDA, _detect, _bus, _addr)
+#define VD_AA065VE11(_mode, _detect, _bus, _addr)	VDF_AA065VE11(_mode, "AA065VE11", RGB24, 0, _detect, _bus, _addr)
+#define VD_VGA(_mode, _detect, _bus, _addr)		VDF_VGA(_mode, "vga", RGB24, 0, _detect, _bus, _addr)
+#define VD_LSA40AT9001(_mode, _detect, _bus, _addr)	VDF_LSA40AT9001(_mode, "LSA40AT9001", RGB24, FBF_MODESTR, _detect, _bus, _addr)
+#define VD_AUO_G050(_mode, _detect, _bus, _addr)	VDF_AUO_G050(_mode, "AUO_G050", RGB24, FBF_MODESTR | FBF_SPI, _detect, _bus, _addr)
+#define VD_A030JN01_UPS051(_mode, _detect, _bus, _addr)	VDF_A030JN01_UPS051(_mode, "A030JN01_UPS051", UPS051, FBF_MODESTR | FBF_SPI, _detect, _bus, _addr)
+#define VD_A030JN01_YUV720(_mode, _detect, _bus, _addr) VDF_A030JN01_YUV720(_mode, "A030JN01_YUV720", YUYV, FBF_MODESTR | FBF_SPI, _detect, _bus, _addr)
+#define VD_KD024FM(_mode, _detect, _bus, _addr)		VDF_KD024FM(_mode, "KD024FM", RGB666, FBF_MODESTR, _detect, _bus, _addr)
+
+#define VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr) \
+	.bus	= _bus,\
+	.addr	= _addr,\
+	.pixfmt	= IPU_PIX_FMT_##_fmt,\
+	.detect	= _detect,\
+	.enable	= fbp_enable_fb,\
+	.fbtype = FB_##_mode,\
+	.fbflags = _flags
+
+/* hdmi settings */
+#define VDF_1280_720M_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 720,\
+		.pixclock       = 1000000000000ULL/((1280+216+72+80)*(720+22+3+5)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 110,\
+		.upper_margin   = 20,\
+		.lower_margin   = 5,\
+		.hsync_len      = 40,\
+		.vsync_len      = 5,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_1920_1080M_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1920,\
+		.yres           = 1080,\
+		.pixclock       = 1000000000000ULL/((1920+148+88+44)*(1080+36+4+5)*60),\
+		.left_margin    = 148,\
+		.right_margin   = 88,\
+		.upper_margin   = 36,\
+		.lower_margin   = 4,\
+		.hsync_len      = 44,\
+		.vsync_len      = 5,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+
+#define VDF_1024_768M_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 768,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(768+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_800_600MR_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((800+88+40+128)*(600+23+2+3)*60),\
+		.left_margin    = 88,\
+		.right_margin   = 40,\
+		.upper_margin   = 23,\
+		.lower_margin   = 2,	/* must be >=2 */\
+		.hsync_len      = 128,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_640_480M_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 640,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((640+48+16+96)*(480+33+10+2)*60),\
+		.left_margin    = 48,\
+		.right_margin   = 16,\
+		.upper_margin   = 33,\
+		.lower_margin   = 10,\
+		.hsync_len      = 96,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_720_480M_60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 720,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((720+60+16+62)*(480+30+9+6)*60),\
+		.left_margin    = 60,\
+		.right_margin   = 16,\
+		.upper_margin   = 30,\
+		.lower_margin   = 9,\
+		.hsync_len      = 62,\
+		.vsync_len      = 6,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* tsc2004 */
+#define VDF_CLAA_WVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 57,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 37037,\
+		.left_margin    = 40,\
+		.right_margin   = 60,\
+		.upper_margin   = 10,\
+		.lower_margin   = 10,\
+		.hsync_len      = 20,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* tsc2004 */
+/* keep compatible with LQ050Y3DC01 */
+#define VDF_SHARP_WVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+40+40+48)*(480+31+11+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 40,\
+		.upper_margin   = 31,\
+		.lower_margin   = 11,\
+		.hsync_len      = 48,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT |FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_TFC_A9700LTWV35TC_C1(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+40+40+48)*(480+29+13+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 40,\
+		.upper_margin   = 29,\
+		.lower_margin   = 13,\
+		.hsync_len      = 48,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT |FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+
+/*
+ * 800x300
+ * vsync = 60
+ * hsync = 260 * vsync = 15.6 Khz
+ * pixclk = 800 * hsync = 12.48 MHz
+ */
+#define VDF_800X300(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 800,\
+		.yres		= 300,\
+		.pixclock	= 1000000000000ULL / (800+50+1+110) / (300+8+3+1) / 60,\
+		.left_margin	= 50,\
+		.right_margin	= 1,\
+		.upper_margin	= 8,\
+		.lower_margin	= 3,\
+		.hsync_len	= 110,\
+		.vsync_len	= 1,\
+		.sync           = FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/*
+ * hitachi 640x240
+ * vsync = 60
+ * hsync = 260 * vsync = 15.6 Khz
+ * pixclk = 800 * hsync = 12.48 MHz
+ */
+#define VDF_HITACHI_HVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 640,\
+		.yres		= 240,\
+		.pixclock	= 1000000000000ULL / (640+34+1+125) / (240+8+3+9) / 60,\
+		.left_margin	= 34,\
+		.right_margin	= 1,\
+		.upper_margin	= 8,\
+		.lower_margin	= 3,\
+		.hsync_len	= 125,\
+		.vsync_len	= 9,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_NEON_TOUCH640X240(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 640,\
+		.yres		= 240,\
+		.pixclock	= 1000000000000ULL / (640+34+1+125) / (240+8+3+9) / 60,\
+		.left_margin	= 34,\
+		.right_margin	= 1,\
+		.upper_margin	= 8,\
+		.lower_margin	= 3,\
+		.hsync_len	= 125,\
+		.vsync_len	= 9,\
+		.sync           = FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* tsc2004 */
+#define VDF_DC050WX(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 33898,\
+		.left_margin    = 96,\
+		.right_margin   = 24,\
+		.upper_margin   = 3,\
+		.lower_margin   = 10,\
+		.hsync_len      = 40,\
+		.vsync_len      = 32,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+
+/* INNOLUX model N140BGE, 18 bit LVDS */
+#define VDF_INNOLUX_WXGA_14IN_12V(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 1366,\
+		.yres		= 768,\
+		.pixclock	= 1000000000000ULL / (1366+108+108+10) / (768+8+8+16) / 60,\
+		.left_margin	= 108,\
+		.right_margin	= 108,\
+		.upper_margin	= 8,\
+		.lower_margin	= 8,\
+		.hsync_len	= 10,\
+		.vsync_len	= 16,\
+		.sync		= FB_SYNC_EXT,\
+		.vmode		= FB_VMODE_NONINTERLACED,\
+	}\
+}
+
+/* AUO model B116XAN03.0, 11.6", 1366x768, 24 bit lvds */
+#define VDF_AUO_WXGA_11IN_12V(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 1366,\
+		.yres		= 768,\
+		.pixclock	= 1000000000000ULL / (1366+67+67+100) / (768+10+10+6) / 60,\
+		.left_margin	= 67,\
+		.right_margin	= 67,\
+		.upper_margin	= 10,\
+		.lower_margin	= 10,\
+		.hsync_len	= 100,\
+		.vsync_len	= 6,\
+		.sync		= FB_SYNC_EXT,\
+		.vmode		= FB_VMODE_NONINTERLACED,\
+	}\
+}
+
+/* OSD model OSD101T1315-45, 18 bit LVDS*/
+#define VDF_OSD_WSVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 1024,\
+		.yres		= 600,\
+		.pixclock	= 1000000000000ULL / (1024+45+210+1) / (600+22+132+1) / 60,\
+		.left_margin	= 45,\
+		.right_margin	= 210,\
+		.upper_margin	= 22,\
+		.lower_margin	= 132,\
+		.hsync_len	= 1,\
+		.vsync_len	= 1,\
+		.sync		= FB_SYNC_EXT,\
+		.vmode		= FB_VMODE_NONINTERLACED,\
+	}\
+}
+
+/* INNOLUX model AT070TN83, 800x480  18 bit RGB with or without LVDS converter board */
+#define VDF_INNOLUX_WVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 60,\
+		.xres		= 800,\
+		.yres		= 480,\
+		.pixclock	= 1000000000000ULL / (800+45+16+1) / (480+22+125+1) / 60,\
+		.left_margin	= 45,\
+		.right_margin	= 16,\
+		.upper_margin	= 22,\
+		.lower_margin	= 125,\
+		.hsync_len	= 1,\
+		.vsync_len	= 1,\
+		.sync		= FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode		= FB_VMODE_NONINTERLACED,\
+	}\
+}
+
+#define VDF_LB043(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 57,\
+		.xres           = 480,\
+		.yres           = 800,\
+		.pixclock       = 37037,\
+		.left_margin    = 40,\
+		.right_margin   = 60,\
+		.upper_margin   = 10,\
+		.lower_margin   = 10,\
+		.hsync_len      = 20,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	},\
+}
+
+#define VDF_OKAYA_480_272(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name		= _name,\
+		.refresh	= 57,\
+		.xres		= 480,\
+		.yres		= 272,\
+		.pixclock	= 97786,\
+		.left_margin	= 2,\
+		.right_margin	= 1,\
+		.upper_margin	= 3,\
+		.lower_margin	= 2,\
+		.hsync_len	= 41,\
+		.vsync_len	= 10,\
+		.sync		= FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode		= FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* tsc2004 */
+#define VDF_QVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 320,\
+		.yres           = 240,\
+		.pixclock       = 1000000000000ULL/((320+38+37+30)*(240+16+15+3)*60),\
+		.left_margin    = 38,\
+		.right_margin   = 37,\
+		.upper_margin   = 16,\
+		.lower_margin   = 15,\
+		.hsync_len      = 30,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_SPI_QVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 320,\
+		.yres           = 240,\
+		.pixclock       = 1000000000000ULL/((320+16+20+52)*(240+16+4+2)*60),\
+		.left_margin    = 16,\
+		.right_margin   = 20,\
+		.upper_margin   = 16,\
+		.lower_margin   = 4,\
+		.hsync_len      = 52,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* tsc2004 */
+#define VDF_DT035BTFT(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 320,\
+		.yres           = 240,\
+		.pixclock       = 1000000000000ULL/((320+40+18+30)*(240+10+9+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 18,\
+		.upper_margin   = 10,\
+		.lower_margin   = 9,\
+		.hsync_len      = 30,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_AT035GT_07ET3(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 320,\
+		.yres           = 240,\
+		.pixclock       = 1000000000000ULL/((320+40+18+30)*(240+10+9+3)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 18,\
+		.upper_margin   = 10,\
+		.lower_margin   = 9,\
+		.hsync_len      = 30,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ili210x touch screen */
+#define VDF_AMP1024_600(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(600+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ft5x06 touch screen */
+#define VDF_ND1024_600(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+160+80+80)*(600+19+8+8)*60),\
+		.left_margin    = 160,\
+		.right_margin   = 80,\
+		.upper_margin   = 19,\
+		.lower_margin   = 8,\
+		.hsync_len      = 80,\
+		.vsync_len      = 8,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ft5x06 touch screen */
+/* Tianma panel TM070JDHG30 is a 24 bit spwg panel */
+#define VDF_TM070JDHG30(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((1280+5+63+1)*(800+2+39+1)*60),\
+		.left_margin    = 5,\
+		.right_margin   = 63,\
+		.upper_margin   = 2,\
+		.lower_margin   = 39,\
+		.hsync_len      = 1,\
+		.vsync_len      = 1,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_AUO_B101EW05(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((1280+48+48+32)*(800+8+2+6)*60),\
+		.left_margin    = 48,\
+		.right_margin   = 48,\
+		.upper_margin   = 8,\
+		.lower_margin   = 2,\
+		.hsync_len      = 32,\
+		.vsync_len      = 6,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ft5x06_ts */
+/* lg1280x800(LP101WX1) == hannstar7 */
+/* LG panel LD101WX1 is a 24 bit spwg panel */
+#define VDF_HANNSTAR7(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((1280+80+48+32)*(800+15+2+6)*60),\
+		.left_margin    = 80,\
+		.right_margin   = 48,\
+		.upper_margin   = 15,\
+		.lower_margin   = 2,\
+		.hsync_len      = 32,\
+		.vsync_len      = 6,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ft5x06_ts */
+#define VDF_DT070BTFT(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(600+21+4+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 4,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* ft5x06_ts */
+#define VDF_WSVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(600+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* Also works for ER-TFT050-3 */
+#define VDF_ASIT500MA6F5D(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.pwm_period = 100000, \
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL / (800+88+40+48) / (480+32+13+3) / 60,\
+		.left_margin    = 88,\
+		.right_margin   = 40,\
+		.upper_margin   = 32,\
+		.lower_margin   = 13,\
+		.hsync_len      = 48,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* fusion7 */
+#define VDF_FUSION7(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+96+24+136)*(480+31+11+3)*60),\
+		.left_margin    = 96,\
+		.right_margin   = 24,\
+		.upper_margin   = 31,\
+		.lower_margin   = 11,\
+		.hsync_len      = 136,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* egalax_ts */
+#define VDF_HANNSTAR(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 768,\
+		.pixclock       = 1000000000000ULL/((1024+220+40+60)*(768+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_1024_600(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 20408,\
+		.left_margin    = 144,\
+		.right_margin   = 40,\
+		.upper_margin   = 3,\
+		.lower_margin   = 11,\
+		.hsync_len      = 104,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_AFK1024600A02(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+160+80+80)*(600+19+8+8)*60),\
+		.left_margin    = 160,\
+		.right_margin   = 80,\
+		.upper_margin   = 19,\
+		.lower_margin   = 8,\
+		.hsync_len      = 80,\
+		.vsync_len      = 8,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* egalax_ts */
+#define VDF_LG9_7(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1024,\
+		.yres           = 768,\
+		.pixclock       = 1000000000000ULL/((1024+480+260+250)*(768+16+6+10)*60),\
+		.left_margin    = 480,\
+		.right_margin   = 260,\
+		.upper_margin   = 16,\
+		.lower_margin   = 6,\
+		.hsync_len      = 250,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_1080P60(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1920,\
+		.yres           = 1080,\
+		.pixclock       = 1000000000000ULL/((1920+148+88+44)*(1080+36+4+5)*60),\
+		.left_margin    = 148,\
+		.right_margin   = 88,\
+		.upper_margin   = 36,\
+		.lower_margin   = 4,\
+		.hsync_len      = 44,\
+		.vsync_len      = 5,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_DV210FBM(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1920,\
+		.yres           = 1080, /* really 132 */\
+		.pixclock       = 1000000000000ULL/((1920+120+120+40)*(1080+22+22+1)*60),\
+		.left_margin    = 120,\
+		.right_margin   = 120,\
+		.upper_margin   = 22,\
+		.lower_margin   = 22,\
+		.hsync_len      = 44,\
+		.vsync_len      = 1,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_SHARP_LQ101K1LY04(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((1280+20+20+10)*(800+4+4+4)*60),\
+		.left_margin    = 20,\
+		.right_margin   = 20,\
+		.upper_margin   = 4,\
+		.lower_margin   = 4,\
+		.hsync_len      = 10,\
+		.vsync_len      = 4,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_WXGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 1280,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((1280+40+40+10)*(800+3+80+10)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 40,\
+		.upper_margin   = 3,\
+		.lower_margin   = 80,\
+		.hsync_len      = 10,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_LD070WSVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 55,\
+		.xres           = 1024,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((1024+160+160+10)*(600+23+12+3)*55),\
+		.left_margin    = 160,\
+		.right_margin   = 160,\
+		.upper_margin   = 23,\
+		.lower_margin   = 12,\
+		.hsync_len      = 10,\
+		.vsync_len      = 3,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_SVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 600,\
+		.pixclock       = 15385,\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* 40.0 ns (25 Mhz) to 28.6 ns (34.965 MHz)
+ * 35.35 ns(28.28 Mhz)
+ * 1000000000/1056/525/40 =  45.094 frames/second
+ * 1000000000/1056/525/35.35 = 51 frames/second
+ * 1000000000/1056/525/28.6 =  63.068 frames/second
+ */
+#define VDF_WVGA_TX23D200(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+220+18+18)*(480+21+14+10)*52),\
+		.left_margin    = 220,\
+		.right_margin   = 18,\
+		.upper_margin   = 21,\
+		.lower_margin   = 14,\
+		.hsync_len      = 18,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_WVGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((800+220+40+60)*(480+21+7+10)*60),\
+		.left_margin    = 220,\
+		.right_margin   = 40,\
+		.upper_margin   = 21,\
+		.lower_margin   = 7,\
+		.hsync_len      = 60,\
+		.vsync_len      = 10,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_AA065VE11(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 70,\
+		.xres           = 640,\
+		.yres           = 480,\
+		.pixclock       = 22858,	/* 23000 works 23100 doesn't */\
+		.left_margin    = 48 + 100,\
+		.right_margin   = 16 + 100,\
+		.upper_margin   = 33 + 50,\
+		.lower_margin   = 10 + 50,\
+		.hsync_len      = 96,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_VGA(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 640,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((640+48+16+96)*(480+33+10+2)*60),\
+		.left_margin    = 48,\
+		.right_margin   = 16,\
+		.upper_margin   = 33,\
+		.lower_margin   = 10,\
+		.hsync_len      = 96,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_LSA40AT9001(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 800,\
+		.yres           = 600,\
+		.pixclock       = 1000000000000ULL/((800+46+210+10)*(600+23+12+1)*60),\
+		.left_margin    = 46,\
+		.right_margin   = 210,\
+		.upper_margin   = 23,\
+		.lower_margin   = 12,\
+		.hsync_len      = 10,\
+		.vsync_len      = 1,\
+		.sync           = FB_SYNC_EXT | FB_SYNC_CLK_LAT_FALL,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* spi panels */
+#define VDF_AUO_G050(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 480,\
+		.yres           = 800,\
+		.pixclock       = 1000000000000ULL/((480+18+16+2)*(800+18+16+2)*60),\
+		.left_margin    = 18,\
+		.right_margin   = 16,\
+		.upper_margin   = 18,\
+		.lower_margin   = 16,\
+		.hsync_len      = 2,\
+		.vsync_len      = 2,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+//640 * 3/2 = 960, (1.5 clocks per pixel)
+//33.7M
+#define VDF_A030JN01_UPS051(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode	= {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 640,\
+		.yres           = 480,\
+		.pixclock       = 1000000000000ULL/((960+40+48+20)*(480+27+18+1)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 48,\
+		.upper_margin   = 27,\
+		.lower_margin   = 18,\
+		.hsync_len      = 20,\
+		.vsync_len      = 1,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+/* 27.11 MHz pixel clock */
+#define VDF_A030JN01_YUV720(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.mode   = {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 720,\
+		.yres           = 480,\
+		.pixclock       =  1000000000000ULL/((720+40+98+1)*(480+27+18+1)*60),\
+		.left_margin    = 40,\
+		.right_margin   = 98,\
+		.upper_margin   = 27,\
+		.lower_margin   = 18,\
+		.hsync_len      = 1,\
+		.vsync_len      = 1,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+
+#define VDF_KD024FM(_mode, _name, _fmt, _flags, _detect, _bus, _addr) \
+{\
+	VD_HEADER(_mode, _fmt, _flags, _detect, _bus, _addr),\
+	.pre_enable = board_pre_enable, \
+	.pwm_period = 100000, \
+	.mode   = {\
+		.name           = _name,\
+		.refresh        = 60,\
+		.xres           = 240,\
+		.yres           = 320,\
+		.pixclock       =  1000000000000ULL/((240+10+38+10)*(320+4+8+4)*60),\
+		.left_margin    = 10,\
+		.right_margin   = 38,\
+		.upper_margin   = 4,\
+		.lower_margin   = 8,\
+		.hsync_len      = 10,\
+		.vsync_len      = 4,\
+		.sync           = FB_SYNC_EXT,\
+		.vmode          = FB_VMODE_NONINTERLACED\
+	}\
+}
+#endif
diff -Nru u-boot-2017.07/arch/arm/include/asm/imx-common/iomux-v3.h u-boot-imx6/arch/arm/include/asm/imx-common/iomux-v3.h
--- u-boot-2017.07/arch/arm/include/asm/imx-common/iomux-v3.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/imx-common/iomux-v3.h	2018-08-27 21:35:36.720806093 +0300
@@ -267,4 +267,18 @@
 	imx_iomux_v3_setup_multiple_pads(x, ARRAY_SIZE(x))
 #endif
 
+
+#if defined(CONFIG_MX6QDL)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX6Q_PAD_##name, ctrl), \
+					NEW_PAD_CTRL(MX6DL_PAD_##name, ctrl)
+#elif defined(CONFIG_MX7D)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX7D_PAD_##name, ctrl)
+#elif defined(CONFIG_MX51)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX51_PAD_##name, ctrl)
+#elif defined(CONFIG_MX53)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX53_PAD_##name, ctrl)
+#else
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX6_PAD_##name, ctrl)
+#endif
+
 #endif	/* __MACH_IOMUX_V3_H__*/
diff -Nru u-boot-2017.07/arch/arm/include/asm/imx-common/mxc_i2c.h u-boot-imx6/arch/arm/include/asm/imx-common/mxc_i2c.h
--- u-boot-2017.07/arch/arm/include/asm/imx-common/mxc_i2c.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/imx-common/mxc_i2c.h	2018-08-27 21:35:36.720806093 +0300
@@ -7,6 +7,7 @@
 #define __ASM_ARCH_MXC_MXC_I2C_H__
 #include <asm-generic/gpio.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/arch/sys_proto.h>
 
 struct i2c_pin_ctrl {
 	iomux_v3_cfg_t i2c_mode;
@@ -16,6 +17,7 @@
 };
 
 struct i2c_pads_info {
+	int bus_index;
 	struct i2c_pin_ctrl scl;
 	struct i2c_pin_ctrl sda;
 };
@@ -49,8 +51,8 @@
 	int speed;
 	struct i2c_pads_info *pads_info;
 #ifndef CONFIG_DM_I2C
-	int (*idle_bus_fn)(void *p);
-	void *idle_bus_data;
+	int (*idle_bus_fn)(const void *p);
+	const void *idle_bus_data;
 #else
 	struct udevice *bus;
 	/* Use gpio to force bus idle when bus state is abnormal */
@@ -59,6 +61,80 @@
 #endif
 };
 
+#define NI2C1	0
+#define NI2C2	1
+#define NI2C3	2
+#define NI2C4	3
+
+#define _I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,	       \
+		sda_pad, sda_bank, sda_gp, ctrl, join_io) {		       \
+    .bus_index = N##i2cnum,						       \
+    .scl = {								       \
+	.i2c_mode = NEW_PAD_CTRL(cpu##_PAD_##scl_pad##__##i2cnum##_SCL, ctrl), \
+	.gpio_mode = NEW_PAD_CTRL(					       \
+		cpu##_PAD_##scl_pad##__GPIO##scl_bank##join_io##scl_gp, ctrl), \
+	.gp = IMX_GPIO_NR(scl_bank, scl_gp)				       \
+    },									       \
+    .sda = {								       \
+	.i2c_mode = NEW_PAD_CTRL(cpu##_PAD_##sda_pad##__##i2cnum##_SDA, ctrl), \
+	.gpio_mode = NEW_PAD_CTRL(					       \
+		cpu##_PAD_##sda_pad##__GPIO##sda_bank##join_io##sda_gp, ctrl), \
+	.gp = IMX_GPIO_NR(sda_bank, sda_gp)				       \
+    }									       \
+}
+
+#ifdef CONFIG_MX6SX
+#define I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,	       \
+		sda_pad, sda_bank, sda_gp, ctrl) 			       \
+		_I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,     \
+				sda_pad, sda_bank, sda_gp, ctrl, _IO_)
+
+#elif defined(CONFIG_MX51) || defined(CONFIG_MX53)
+#define I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,	       \
+		sda_pad, sda_bank, sda_gp, ctrl) 			       \
+		_I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,     \
+				sda_pad, sda_bank, sda_gp, ctrl, _)
+#else
+#define I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,	       \
+		sda_pad, sda_bank, sda_gp, ctrl) 			       \
+		_I2C_PADS_INFO_CPU(cpu, i2cnum, scl_pad, scl_bank, scl_gp,     \
+				sda_pad, sda_bank, sda_gp, ctrl, _IO)
+#endif
+
+#if defined(CONFIG_MX6QDL)
+#define I2C_PADS_INFO_ENTRY(i2cnum, scl_pad, scl_bank, scl_gp,		\
+		sda_pad, sda_bank, sda_gp, ctrl)			\
+	I2C_PADS_INFO_CPU(MX6Q, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl),			\
+	I2C_PADS_INFO_CPU(MX6DL, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl)
+#define I2C_PADS_INFO_ENTRY_SPACING 2
+#elif defined(CONFIG_MX51)
+#define I2C_PADS_INFO_ENTRY(i2cnum, scl_pad, scl_bank, scl_gp,		\
+		sda_pad, sda_bank, sda_gp, ctrl)			\
+	I2C_PADS_INFO_CPU(MX51, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl)
+#define I2C_PADS_INFO_ENTRY_SPACING 1
+#elif defined(CONFIG_MX53)
+#define I2C_PADS_INFO_ENTRY(i2cnum, scl_pad, scl_bank, scl_gp,		\
+		sda_pad, sda_bank, sda_gp, ctrl)			\
+	I2C_PADS_INFO_CPU(MX53, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl)
+#define I2C_PADS_INFO_ENTRY_SPACING 1
+#elif defined(CONFIG_MX7D)
+#define I2C_PADS_INFO_ENTRY(i2cnum, scl_pad, scl_bank, scl_gp,		\
+		sda_pad, sda_bank, sda_gp, ctrl)			\
+	I2C_PADS_INFO_CPU(MX7D, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl)
+#define I2C_PADS_INFO_ENTRY_SPACING 1
+#else
+#define I2C_PADS_INFO_ENTRY(i2cnum, scl_pad, scl_bank, scl_gp,		\
+		sda_pad, sda_bank, sda_gp, ctrl)			\
+	I2C_PADS_INFO_CPU(MX6, i2cnum, scl_pad, scl_bank, scl_gp,	\
+		sda_pad, sda_bank, sda_gp, ctrl)
+#define I2C_PADS_INFO_ENTRY_SPACING 1
+#endif
+
 #if defined(CONFIG_MX6QDL)
 #define I2C_PADS(name, scl_i2c, scl_gpio, scl_gp, sda_i2c, sda_gpio, sda_gp) \
 	struct i2c_pads_info mx6q_##name = {		\
@@ -93,9 +169,20 @@
 #endif
 
 int setup_i2c(unsigned i2c_index, int speed, int slave_addr,
-	      struct i2c_pads_info *p);
+	      const struct i2c_pads_info *p);
 void bus_i2c_init(int index, int speed, int slave_addr,
-		int (*idle_bus_fn)(void *p), void *p);
-int force_idle_bus(void *priv);
+		int (*idle_bus_fn)(const void *p), const void *p);
+int force_idle_bus(const void *priv);
 int i2c_idle_bus(struct mxc_i2c_bus *i2c_bus);
+
+static inline int i2c_get_info_entry_offset(void) {
+#if defined(CONFIG_MX6QDL)
+	int cpu = get_cpu_type();
+
+	if ((cpu != MXC_CPU_MX6Q) && (cpu != MXC_CPU_MX6D))
+		return 1;
+#endif
+	return 0;
+}
+
 #endif
diff -Nru u-boot-2017.07/arch/arm/include/asm/imx-common/sys_proto.h u-boot-imx6/arch/arm/include/asm/imx-common/sys_proto.h
--- u-boot-2017.07/arch/arm/include/asm/imx-common/sys_proto.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/include/asm/imx-common/sys_proto.h	2018-08-27 21:35:36.724139410 +0300
@@ -109,6 +109,10 @@
 u32 get_periph_clk(void);
 
 void lcdif_power_down(void);
+struct fb_videomode;
+int mxsfb_init(struct fb_videomode const *mode, uint32_t pixfmt);
+void *mxsfb_init2(void);
+
 
 int mxs_reset_block(struct mxs_register_32 *reg);
 int mxs_wait_mask_set(struct mxs_register_32 *reg, u32 mask, u32 timeout);
diff -Nru u-boot-2017.07/arch/arm/lib/cache.c u-boot-imx6/arch/arm/lib/cache.c
--- u-boot-2017.07/arch/arm/lib/cache.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/lib/cache.c	2018-08-27 21:35:36.730806045 +0300
@@ -56,7 +56,7 @@
 	if (stop & (CONFIG_SYS_CACHELINE_SIZE - 1))
 		ok = 0;
 
-	if (!ok) {
+	if (!ok && dcache_status()) {
 		warn_non_spl("CACHE: Misaligned operation at range [%08lx, %08lx]\n",
 			     start, stop);
 	}
diff -Nru u-boot-2017.07/arch/arm/lib/relocate.S u-boot-imx6/arch/arm/lib/relocate.S
--- u-boot-2017.07/arch/arm/lib/relocate.S	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/arch/arm/lib/relocate.S	2018-08-27 21:35:36.734139362 +0300
@@ -78,6 +78,7 @@
  */
 
 ENTRY(relocate_code)
+	stmdb   sp!, {lr}
 	ldr	r1, =__image_copy_start	/* r1 <- SRC &__image_copy_start */
 	subs	r4, r0, r1		/* r4 <- relocation offset */
 	beq	relocate_done		/* skip relocation */
@@ -100,6 +101,20 @@
 	cmp	r1, #R_ARM_RELATIVE
 	bne	fixnext
 
+	tst	r0, #3
+	beq	1f
+	sub	r0, r2, #8
+	bl	prhex
+	mov	r0, #':'
+	bl	pr_c
+	ldr	r0,[r2, #-8]
+	bl	prhex
+	mov	r0, #'_'
+	bl	pr_c
+	ldr	r0,[r2, #-4]
+	bl	prhex
+	b	fixnext
+1:
 	/* relative fix: increase location by offset */
 	add	r0, r0, r4
 	ldr	r1, [r0]
@@ -125,7 +140,81 @@
 #ifdef __ARM_ARCH_4__
 	mov	pc, lr
 #else
-	bx	lr
+	ldmia	sp!, {pc}
 #endif
 
 ENDPROC(relocate_code)
+
+ENTRY(prhex)
+	stmdb   sp!, {r0-r6,lr}
+	mov	r6, #8
+	mov	r5, r0
+1:	mov	r0, r5, lsr #28
+	cmp	r0, #10
+	addlt	r0, r0, #'0'
+	addge	r0, r0, #'a' - 10
+	bl	pr_c
+	mov	r5, r5, lsl #4
+	subs	r6, r6, #1
+	bne	1b
+
+	mov	r0,#'\n'
+	bl	pr_c
+	mov	r0,#'\r'
+	bl	pr_c
+	ldmia	sp!, {r0-r6,pc}
+ENDPROC(prhex)
+
+#define UTXD		0x40
+#define UTS		0xb4
+#define UTS_TXEMPTY	(1<<6)
+
+ENTRY(pr_c)
+	stmdb   sp!, {r0-r1,lr}
+	ldr	r1, =CONFIG_MXC_UART_BASE
+	str	r0, [r1,#UTXD]
+
+1:	ldr	r0, [r1,#UTS]
+	tst	r0, #UTS_TXEMPTY
+	beq	1b
+	ldmia	sp!, {r0-r1,pc}
+ENDPROC(pr_c)
+
+#if 0
+ENTRY(verify_relocate_table)
+	stmdb   sp!, {lr}
+	/*
+	 * check .rel.dyn relocations
+	 */
+	ldr	r2, =__rel_dyn_start	/* r2 <- SRC &__rel_dyn_start */
+	ldr	r3, =__rel_dyn_end	/* r3 <- SRC &__rel_dyn_end */
+1:
+	ldmia	r2!, {r0-r1}		/* (r0,r1) <- (SRC location,fixup) */
+	and	r1, r1, #0xff
+	cmp	r1, #R_ARM_RELATIVE
+	bne	3f
+
+	tst	r0, #3
+	beq	2f
+	sub	r0, r2, #8
+	bl	prhex
+	mov	r0, #':'
+	bl	pr_c
+	ldr	r0,[r2, #-8]
+	bl	prhex
+	mov	r0, #'_'
+	bl	pr_c
+	ldr	r0,[r2, #-4]
+	bl	prhex
+	mov	r0, #1
+	ldmia	sp!, {pc}
+2:
+3:
+	cmp	r2, r3
+	blo	1b
+
+	mov	r0, #0
+	ldmia	sp!, {pc}
+
+ENDPROC(verify_relocate_table)
+#endif
diff -Nru u-boot-2017.07/board/boundary/a/6x_bootscript.txt u-boot-imx6/board/boundary/a/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/a/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/6x_bootscript.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,29 @@
+setenv bootargs enable_wait_mode=off
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+kernel=/boot/uImage
+ramdisk=/boot/uramdisk.img
+
+if kbd ; then
+    if itest.s "xF" == "x$keybd" ; then
+        kernel=/boot/uImage-usbwrite
+        ramdisk=/boot/uramdisk-usbwrite
+    fi
+fi
+
+if itest.s "x" != "x$asix"; then
+    setenv bootargs $bootargs asix.ethaddr1=$asix;
+fi
+
+setenv bootargs $bootargs console=ttymxc1,115200
+if ${fs}load ${dtype} 0:1 10800000 $kernel ; then
+    if ${fs}load ${dtype} 0:1 12800000 $ramdisk ; then
+        bootm 10800000 12800000
+    else
+        echo "Error loading RAM disk $ramdisk"
+    fi
+else
+    echo "Error loading kernel image $kernel"
+fi
diff -Nru u-boot-2017.07/board/boundary/a/6x_bootscript-upgrade-usbotg.txt u-boot-imx6/board/boundary/a/6x_bootscript-upgrade-usbotg.txt
--- u-boot-2017.07/board/boundary/a/6x_bootscript-upgrade-usbotg.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/6x_bootscript-upgrade-usbotg.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,8 @@
+for n in 51 52 53 54 ; do gpio clear $n ; done
+load usb 0 10008000 /restore-to-emmc-amp.img.gz
+	&& time gzwrite mmc 0 10008000 0x$filesize 400000 0
+	&& gpio set 51 
+	&& gpio set 52 
+	&& while itest.l 0 -eq 0 ; do ;; done
+gpio set 54
+
diff -Nru u-boot-2017.07/board/boundary/a/6x_bootscript-writeable-rootfs.txt u-boot-imx6/board/boundary/a/6x_bootscript-writeable-rootfs.txt
--- u-boot-2017.07/board/boundary/a/6x_bootscript-writeable-rootfs.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/6x_bootscript-writeable-rootfs.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,21 @@
+setenv bootargs enable_wait_mode=off
+setenv bootargs $bootargs console=ttymxc1,115200
+
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+if itest.s "x" != "x$asix"; then
+    setenv bootargs $bootargs asix.ethaddr1=$asix;
+fi
+
+if kbd ; then
+    if itest.s "xF" == "x$keybd" ; then
+        ums 0 mmc 0;
+    fi
+fi
+
+if ${fs}load ${dtype} 0:1 10800000 /uImage ; then
+    setenv bootargs $bootargs rootwait root=/dev/mmcblk0p2 init=/sbin/init
+    bootm 10800000
+fi
diff -Nru u-boot-2017.07/board/boundary/a/a.c u-boot-imx6/board/boundary/a/a.c
--- u-boot-2017.07/board/boundary/a/a.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/a.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <asm/arch/crm_regs.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static iomux_v3_cfg_t const init_pads[] = {
+	/* AUDMUX - mu609 usb modem */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS		IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+	/* gpio_keys */
+#define GP_S0_FACTORY_RESET	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),	/* S0: factory reset */
+#define GP_J57_INPUT	IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLUP),	/* J57: pin3 input switch */
+#define GP_S1_LOOPBACK	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),	/* S1:1 - Loopback request switch */
+#define GP_S1_DIAG1	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),	/* S1:2 - Diagnostic Switch 1 */
+#define GP_S1_DIAG2	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),	/* S1:3 - Diagnostic Switch 2 */
+#define GP_S1_INPUT	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),	/* S1:4 */
+
+	/* i2c1 rtc rv4162 */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+
+	/* led outputs*/
+	/*
+	 * From antenna connector toward USB OTG
+	 * connector, there are four LEDS in the
+	 * order listed below.
+	 */
+#define GP_LED0		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLDN),	/* Led 4 */
+#define GP_LED1		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLDN),	/* Led 3 */
+#define GP_LEDRED	IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLDN),	/* Led 1 */
+#define GP_LED2		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLDN),	/* Led 2 */
+#define GP_RXACT	IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),	/* RX_ACT led */
+#define GP_TXACT	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),	/* TX_ACT led */
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG	IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	/* RS485 RX Enable */
+#define GP_UART3_RX_EN	IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLDN),
+	/* RS485 TX Enable */
+#define GP_UART3_TX_EN	IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLDN),
+	/* RS485/RS232 Select 2.5V */
+#define GP_UART3_RS485_EN	IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLDN),
+	/* ON - meaning depends on others */
+#define GP_UART3_AON		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN),
+
+	/* UART4 - mu609 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+#define GP_AX88772A_RESET	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),
+
+	/* USBH1 - mu609*/
+#define GP_MODEM_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP), 	/* Modem nRESET */
+#define GP_MODEM_OFF	IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, OUTPUT_40OHM),   	/* Modem OFF */
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP), 	/* Modem Sleep stat */
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, OUTPUT_40OHM),	/* Modem Wakeup Out */
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP), 	/* Modem Wakeup In */
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, USDHC_PAD_CTRL),	/* USBOTG ID pin */
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),	/* USBOTG OC pin */
+
+	/* USDHC4 */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP), /* RESET (rev 1) */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C2 RV4162 RTC */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	1
+
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USBH1_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USBH1_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8, .gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_LED0,
+	GP_LED1,
+	GP_LEDRED,
+	GP_LED2,
+	GP_REG_USBOTG, 			/* disable USB otg power */
+	GP_MODEM_RESET,			/* assert MODEM nRESET */
+	GP_EMMC_RESET,			/* assert eMMC reset*/
+	GP_UART3_RX_EN,
+	GP_UART3_TX_EN,
+	GP_UART3_RS485_EN,
+	GP_UART3_AON,
+	GP_USBH1_HUB_RESET,
+	GP_AX88772A_RESET,		/* disable USB ethernet */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,		/* SS1 of spi nor */
+	GP_FLEXCAN_STANDBY,
+	GP_RXACT,
+	GP_TXACT,
+	GP_MODEM_OFF,			/* assert MODEM off */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_S0_FACTORY_RESET,		/* S0: factory reset */
+	GP_J57_INPUT,			/* J57: pin3 input switch */
+	GP_S1_LOOPBACK,			/* S1:1 - Loopback request switch */
+	GP_S1_DIAG1,			/* S1:2 - Diagnostic Switch 1 */
+	GP_S1_DIAG2,			/* S1:3 - Diagnostic Switch 2 */
+	GP_S1_INPUT,			/* S1:4 */
+	GPIRQ_RTC_RV4162,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			NULL, 0, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"factory",	GP_S0_FACTORY_RESET,	'F', 1},
+	{"input",	GP_J57_INPUT,	'I', 1},
+#if 0
+	{"D1",	GP_S1_LOOPBACK,	'1', 0},	/* S1:1 - Loopback request switch */
+	{"D2",	GP_S1_DIAG1,	'2', 0},	/* S1:2 - Diagnostic Switch 1 */
+	{"D3",	GP_S1_DIAG2,	'3', 0},	/* S1:3 - Diagnostic Switch 2 */
+	{"D4",	GP_S1_INPUT,	'4', 0},	/* S1:4 */
+#endif
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)}, /* usdhc4 */
+	{NULL,		0},
+};
+#endif
+
+#define PROGRESS_BITS 3
+
+static int const leds[] = {
+	GP_LED0,
+	GP_LED1,
+	GP_LEDRED,
+	GP_LED2
+};
+
+void gzwrite_progress_init(u64 expected_size)
+{
+	int i;
+	putc('\n');
+	for (i = 0; i < ARRAY_SIZE(leds); i++)
+		gpio_direction_output(leds[i], 0);
+}
+
+void gzwrite_progress(int iteration,
+		     u64 bytes_written,
+		     u64 total_bytes)
+{
+	int i;
+	if (0 == (iteration & 3))
+		printf("%llu/%llu\r", bytes_written, total_bytes);
+
+	for (i = 0; i < 2; i++)
+		gpio_set_value(leds[i], (iteration & 1) == i);
+}
+
+void gzwrite_progress_finish(int returnval, /* 0 == success */
+			    u64 totalwritten,
+                            u64 totalsize,
+                            u32 expected_crc,
+                            u32 calculated_crc)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(leds); i++)
+		gpio_set_value(leds[i], 0);
+
+	if (0 == returnval) {
+		printf("\n\t%llu bytes, crc 0x%08x\n",
+		       totalwritten, calculated_crc);
+		gpio_set_value(leds[3], 1);
+	} else {
+		printf("\n\tuncompressed %llu of %llu\n"
+		       "\tcrcs == 0x%08x/0x%08x\n",
+		       totalwritten, totalsize,
+		       expected_crc, calculated_crc);
+		gpio_set_value(leds[2], 1);
+	}
+}
diff -Nru u-boot-2017.07/board/boundary/a/a_s512m.cfg u-boot-imx6/board/boundary/a/a_s512m.cfg
--- u-boot-2017.07/board/boundary/a/a_s512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/a_s512m.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/a/Kconfig u-boot-imx6/board/boundary/a/Kconfig
--- u-boot-2017.07/board/boundary/a/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,20 @@
+if TARGET_A
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "a"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "a"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/a/MAINTAINERS u-boot-imx6/board/boundary/a/MAINTAINERS
--- u-boot-2017.07/board/boundary/a/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+A BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/a/
+F:	include/configs/a.h
+F:	configs/a_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/a/Makefile u-boot-imx6/board/boundary/a/Makefile
--- u-boot-2017.07/board/boundary/a/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/a/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := a.o
diff -Nru u-boot-2017.07/board/boundary/acl/acl2g.cfg u-boot-imx6/board/boundary/acl/acl2g.cfg
--- u-boot-2017.07/board/boundary/acl/acl2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/acl2g.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* This configuration not yet produced */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/acl/acl512m.cfg u-boot-imx6/board/boundary/acl/acl512m.cfg
--- u-boot-2017.07/board/boundary/acl/acl512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/acl512m.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42380238
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02210222
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4445484e
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x36342c2b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x003d0045
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0034003c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/acl/acl.c u-boot-imx6/board/boundary/acl/acl.c
--- u-boot-2017.07/board/boundary/acl/acl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/acl.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,534 @@
+/*
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define OUTPUT_40OHM	(PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Buzzer */
+#define GP_GPIO3_CLKO2	IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+#define GP_ECSPI2_NOR_CS0	IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+#define GP_ECSPI2_NOR_CS1	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+
+	/* ECSPI4 */
+	IOMUX_PAD_CTRL(EIM_D21__ECSPI4_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D28__ECSPI4_MOSI, SPI_PAD_CTRL),
+
+#ifndef CONFIG_MX6S
+	/* ECSPI5 */
+	IOMUX_PAD_CTRL(SD2_CLK__ECSPI5_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__ECSPI5_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__ECSPI5_MISO, SPI_PAD_CTRL),
+#define GP_ECSPI5_NOR_CS	IMX_GPIO_NR(1, 14)
+	IOMUX_PAD_CTRL(SD2_DAT1__GPIO1_IO14, WEAK_PULLUP),
+#endif
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* Fan */
+#define GPIRQ_FAN		IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),
+#define GP_FAN_ON		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* Hogs */
+#define GP_TP73			IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* I2C2 RV4172 RTC */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* I2C3 ADS7924 ADC */
+#define GPIRQ_ADC_INTR		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),
+#define GP_ADC_RESET		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN),
+
+	/* I2C3 ADT75 Temperature */
+#define GPIRQ_TEMP_ALERT	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* Motors */
+#define GP_DOOR1		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLDN),
+#define GP_MOTOR_HOME1A		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN),
+#define GP_MOTOR_HOME1B		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),
+#define GP_MOTOR_HOME2		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLDN),
+#define GP_STEP1_RESET		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLDN),
+#define GP_STEP1_BUSY		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+#define GP_STEP1_FLAG		IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLDN),
+#define GP_STEP1_SW		IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLDN),
+#define GP_STEP2_RESET		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLDN),
+#define GP_STEP2_BUSY		IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLDN),
+#define GP_STEP2_FLAG		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),
+#define GP_STEP2_SW		IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN),
+
+	/* PWM1 - Step motor 1 */
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM2 - Step motor 2 */
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* PWM3 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* PWM4 - Cartridge optics */
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* Printer */
+#define GP_PRINT_BDCAY		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GP_PRINT_ADCAY		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_PRINT_TOFF		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_PRINT_ATE		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_PRINT_SLEEP_N	IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),
+#define GP_PRINT_BEN		IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLUP),
+#define GP_PRINT_BPH		IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLUP),
+#define GP_PRINT_AEN		IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLUP),
+#define GP_PRINT_APH		IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLUP),
+#define GP_PRINT_STROBE1	IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+#define GP_PRINT_STROBE2	IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_PRINT_STROBE3	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_PRINT_STROBE4	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_PRINT_STROBE5	IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_PRINT_STROBE6	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_PRINT_LATCH_B	IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+#define GP_PRINT_ALERT		IMX_GPIO_NR(5, 20)
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, WEAK_PULLUP),
+#define GP_PRINT_TRQ0		IMX_GPIO_NR(5, 22)
+	IOMUX_PAD_CTRL(CSI0_DAT4__GPIO5_IO22, WEAK_PULLUP),
+#define GP_PRINT_TRQ1		IMX_GPIO_NR(5, 23)
+	IOMUX_PAD_CTRL(CSI0_DAT5__GPIO5_IO23, WEAK_PULLUP),
+#define GP_PRINT_FAULT		IMX_GPIO_NR(5, 24)
+	IOMUX_PAD_CTRL(CSI0_DAT6__GPIO5_IO24, WEAK_PULLUP),
+#define GP_PRINT_DO		IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(SD2_DAT2__GPIO1_IO13, WEAK_PULLUP),
+#define GP_PAPER_OUT		IMX_GPIO_NR(1, 12)
+	IOMUX_PAD_CTRL(SD2_DAT3__GPIO1_IO12, WEAK_PULLUP),
+#define GP_STAT_LED1		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN),
+#define GP_STAT_LED2		IMX_GPIO_NR(2, 29)
+	IOMUX_PAD_CTRL(EIM_EB1__GPIO2_IO29, WEAK_PULLDN),
+#define GP_DRDY			IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLDN),
+
+	/* Scanner */
+#define GP_SCAN_AIM		IMX_GPIO_NR(5, 19)
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),
+#define GP_SCAN_TRIG		IMX_GPIO_NR(5, 18)
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__GPIO5_IO18, WEAK_PULLUP),
+#define GP_SCAN_STA		IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLDN),
+#define GP_SCAN_DNLOAD		IMX_GPIO_NR(6, 3)
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLUP),
+
+	/* Solenoids */
+#define GP_SOLENOID1_ON		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GP_SOLENOID2_ON		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_SOLENOID3_ON		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_SPARE		IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GPIRQ_SOLENOID_FAULT	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+
+	/* Touch */
+#define GP_TOUCH_WAKE		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+#define GPIRQ_TOUCH		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW4__UART5_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT18__UART5_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb666_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb24_pads[] = {
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C2 - touch / RTC / ADC */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3 - ADC / temperature */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	2
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4, .gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8, .gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb666_pads);
+		if (di->pixfmt == IPU_PIX_FMT_RGB24)
+			SETUP_IOMUX_PADS(rgb24_pads);
+		mdelay(100); /* let panel sync up before enabling backlight */
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+}
+
+void board_pre_enable(const struct display_info_t *di)
+{
+	SETUP_IOMUX_PADS(rgb666_pads);
+}
+
+static const struct display_info_t displays[] = {
+	VD_ASIT500MA6F5D(LCD, NULL, 1, 0x40),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_ADC_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_EMMC_RESET,
+	GP_FAN_ON,
+	GP_GPIO3_CLKO2,
+	GP_PRINT_SLEEP_N,
+	GP_PRINT_STROBE1,
+	GP_PRINT_STROBE2,
+	GP_PRINT_STROBE3,
+	GP_PRINT_STROBE4,
+	GP_PRINT_STROBE5,
+	GP_PRINT_STROBE6,
+	GP_REG_USBOTG,
+	GP_SCAN_STA,
+	GP_SOLENOID1_ON,
+	GP_SOLENOID2_ON,
+	GP_SOLENOID3_ON,
+	GP_STAT_LED1,
+	GP_STAT_LED2,
+	GP_STEP1_RESET,
+	GP_STEP2_RESET,
+	GP_SPARE,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_NOR_CS0,
+	GP_ECSPI2_NOR_CS1,
+#ifndef CONFIG_MX6S
+	GP_ECSPI5_NOR_CS,
+#endif
+	GP_SCAN_AIM,
+	GP_SCAN_DNLOAD,
+	GP_SCAN_TRIG,
+	GP_TOUCH_WAKE,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ADC_INTR,
+	GPIRQ_ENET_PHY,
+	GPIRQ_FAN,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_SOLENOID_FAULT,
+	GPIRQ_TEMP_ALERT,
+	GPIRQ_TOUCH,
+	GP_DOOR1,
+	GP_MOTOR_HOME1A,
+	GP_MOTOR_HOME1B,
+	GP_MOTOR_HOME2,
+	GP_PAPER_OUT,
+	GP_PRINT_ALERT,
+	GP_PRINT_DO,
+	GP_PRINT_FAULT,
+	GP_PRINT_LATCH_B,
+	GP_STEP1_BUSY,
+	GP_STEP1_FLAG,
+	GP_STEP1_SW,
+	GP_STEP2_BUSY,
+	GP_STEP2_FLAG,
+	GP_STEP2_SW,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp73",	GP_TP73,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/acl/Kconfig u-boot-imx6/board/boundary/acl/Kconfig
--- u-boot-2017.07/board/boundary/acl/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,14 @@
+if TARGET_ACL
+
+config SYS_BOARD
+	default "acl"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_CONFIG_NAME
+	default "acl"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/acl/MAINTAINERS u-boot-imx6/board/boundary/acl/MAINTAINERS
--- u-boot-2017.07/board/boundary/acl/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,6 @@
+ACL BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/acl/
+F:	include/configs/acl.h
+F:	configs/acl_defconfig
diff -Nru u-boot-2017.07/board/boundary/acl/Makefile u-boot-imx6/board/boundary/acl/Makefile
--- u-boot-2017.07/board/boundary/acl/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/acl/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := acl.o
diff -Nru u-boot-2017.07/board/boundary/ap/ap.c u-boot-imx6/board/boundary/ap/ap.c
--- u-boot-2017.07/board/boundary/ap/ap.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/ap.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,620 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* GPIO_KEYS assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_SEARCH	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hogs */
+#define GP_GPIO_1		IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+#define GP_GPIO_2		IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+#define GP_GPIO_3		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+#define GP_GPIO_4		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+#define GP_GPIO_5		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_GPIO_6		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_GPIO_7		IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+#define GP_GPIO_8		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+#define GP_GPIO_9		IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+#define GP_GPIO_10		IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+#define GP_GPIO_11		IMX_GPIO_NR(5, 11)
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+#define GP_GPIO_12		IMX_GPIO_NR(5, 6)
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+#define GP_GPIO_13		IMX_GPIO_NR(5, 10)
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+#define GP_GPIO_14		IMX_GPIO_NR(5, 7)
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+#define GP_GPIO_15		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+#define GP_GPIO_16		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+
+#define GP_BT_CLK_REQ		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLUP),
+#define GP_BT_HOST_WAKE		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP),
+
+	/* Hog Test points */
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP101		IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, WEAK_PULLUP),
+#define GP_TP102		IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+	/* i2c1a_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* Rev 0, needs to be gpio input */
+#define GP_I2C1_ALT_SCL	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+#define GP_I2C1_ALT_SDA	IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+
+	/* I2C1b - scl alternate */
+	IOMUX_PAD_CTRL(CSI0_DAT9__GPIO5_IO27, WEAK_PULLUP),
+	/* I2C1b - sda alternate */
+	IOMUX_PAD_CTRL(CSI0_DAT8__GPIO5_IO26, WEAK_PULLUP),
+
+	/* I2C1a -  WM8960 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, WEAK_PULLDN),
+
+	/* I2C2 - DS90UB927QSQ serializer 2 */
+	/*
+	 * Used to enable LP8860 on deserializer board,
+	 * DISP1_CONTRAST on schematic
+	 */
+#define GP_SER2_GPIO5		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_SER2_GPIO6		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_SER2_FAN_OK		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+#define GPIRQ_SER2		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+	/* I2C2 - serializer 2, gt911 touch controller */
+#define GPIRQ_I2C2_SER2_TOUCH	IMX_GPIO_NR(1, 16)		/* GP0 */
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLDN),
+#define GP_I2C2_GT911_RESET	IMX_GPIO_NR(1, 19)		/* GP3 */
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* I2C2 - serializer 2, LP8860 backlight */
+#define GP_LVDS2_LP8860_RESET	IMX_GPIO_NR(2, 23)		/* GP1 */
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN),
+
+	/* I2C3 - DS90UB927QSQ serializer 1 */
+	/*
+	 * Used to enable LP8860 on deserializer board,
+	 * DISP0_CONTRAST on schematic
+	 */
+#define GP_SER1_GPIO5		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GP_SER1_GPIO6		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_SER1_FAN_OK		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GPIRQ_SER1		IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+
+	/* I2C3 - serializer 1, gt911 touch controller */
+#define GPIRQ_I2C3_SER1_TOUCH	IMX_GPIO_NR(1, 9)		/* GP0 */
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLDN),
+#define GP_I2C3_GT911_RESET	IMX_GPIO_NR(1, 18)		/* GP3 */
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* I2C3 - serializer 1, LP8860 backlight */
+#define GP_LVDS_LP8860_RESET	IMX_GPIO_NR(2, 0)		/* GP1 */
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLDN),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLDN),
+
+
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 - J58, J63 (RS485 half duplex)  */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+#define GP_UART4_TX_EN		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLDN),
+
+
+	/* UART5 - J54, J63 (RS485 half duplex)  */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+	/* RS485 RX Enable */
+#define GP_UART5_RX_EN		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLDN),
+	/* RS485 TX Enable */
+#define GP_UART5_TX_EN		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),
+	/* RS485/RS232 Select 2.5V */
+#define GP_UART5_RS485_EN	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN),
+	/* ON - meaning depends on others */
+#define GP_UART5_AON		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLDN),
+
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1a, RV4162(rtc, 0x68) */
+	/* I2C1b, wm8960 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 PCIe, hdmi edid, serializer 2(0x0c) */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, serializer 1 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+static unsigned char setup_serializer_remote[] = {
+	0x0c, 0x03, 0xda,	/* passthough i2c accesses to de-serialized/backlight */
+	0x0c, 0x07, 0x5a,	/* setup backlight lp8860 address */
+	0x0c, 0x08, 0x5a,
+	0x0c, 0x77, 0xba,	/* setup gt911 touch controller address */
+	0x0c, 0x70, 0xba,
+	0x0c, 0x0d, 0x05,	/* gpio0 output from de-serializer */
+};
+
+static unsigned char setup_serializer_data[] = {
+	0x2c, 0x1d, 0x03,
+	0x0c, 0x0f, 0x03,	/* gpio3 output to de-serializer */
+	0x2c, 0x1f, 0x05,
+#if 1
+	0x0c, 0x0e, 0x03,	/* gpio1 output to de-serializer */
+	0x2c, 0x1e, 0x05,
+#else
+	0x2c, 0x1e, 0x01,	/* gpio1 local to de-serializer, low */
+	0x2c, 0x1e, 0x09,	/* gpio1 local to de-serializer, high */
+#endif
+};
+
+static unsigned char enable_backlight_data[] = {
+	0x2d, 0x00, 0xff,	/* 100% brightness */
+	0x2d, 0x01, 0xff,
+};
+
+void write_i2c_table(unsigned char *p, int size)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < size; i += 3, p += 3) {
+		int retry = 0;
+		while (1) {
+			ret = i2c_write(p[0], p[1], 1, &p[2], 1);
+			if (!ret)
+				break;
+			if (retry++ > 10) {
+				printf("error writing 0x%02x:0x%02x = 0x%02x\n",
+					p[0], p[1], p[2]);
+				break;
+			}
+			mdelay(100);
+		}
+	}
+}
+
+void enable_backlight(const struct display_info_t *di, int enable, int gp_lp8860)
+{
+	if (di->addr == 0x0c) {
+		/* enable lp8860 backlight */
+		int ret = i2c_set_bus_num(di->bus & 0xff);
+
+		if (ret)
+			return;
+
+		gpio_direction_output(gp_lp8860, 0);
+		if (!enable)
+			return;
+
+		write_i2c_table(setup_serializer_remote,
+			sizeof(setup_serializer_remote));
+		write_i2c_table(setup_serializer_data,
+			sizeof(setup_serializer_data));
+		mdelay(2);
+		gpio_direction_output(gp_lp8860, enable);
+		mdelay(60);
+
+		write_i2c_table(enable_backlight_data,
+			sizeof(enable_backlight_data));
+	}
+}
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	enable_backlight(di, enable, GP_LVDS_LP8860_RESET);
+}
+
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+	enable_backlight(di, enable, GP_LVDS2_LP8860_RESET);
+}
+
+int fbp_detect_serializer(struct display_info_t const *di)
+{
+	int ret;
+	int gp = di->bus >> 8;
+
+	if (gp)
+		gpio_set_value(gp, 1);
+	ret = i2c_set_bus_num(di->bus & 0xff);
+	if (ret == 0) {
+		int gp_lp8860 = (di->fbtype == FB_LVDS2) ? GP_LVDS2_LP8860_RESET :
+				GP_LVDS_LP8860_RESET;
+		ret = i2c_probe(di->addr);
+		if (!ret) {
+			gpio_direction_output(gp_lp8860, 0);
+			write_i2c_table(setup_serializer_remote,
+				sizeof(setup_serializer_remote));
+			ret = i2c_probe(0x2c);
+			if (!ret)
+				write_i2c_table(setup_serializer_data,
+						sizeof(setup_serializer_data));
+		}
+	}
+	if (gp)
+		gpio_set_value(gp, 0);
+	return (ret == 0);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* 0x0c is a serializer */
+	VD_TFC_A9700LTWV35TC_C1(LVDS, fbp_detect_serializer, 2, 0x0c),
+	VD_TFC_A9700LTWV35TC_C1(LVDS2, fbp_detect_serializer, 1, 0x0c),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_RGMII_PHY_RESET,
+	GP_LVDS2_LP8860_RESET,	/* Serializer2 gpio1 */
+	GP_LVDS_LP8860_RESET,	/* Serializer1 gpio1 */
+	GP_PCIE_RESET,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_UART4_TX_EN,
+	GP_UART5_RX_EN,		/* power down uart5 */
+	GP_UART5_TX_EN,
+	GP_UART5_RS485_EN,
+	GP_UART5_AON,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_SEARCH,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GP_GPIO_1,
+	GP_GPIO_2,
+	GP_GPIO_3,
+	GP_GPIO_4,
+	GP_GPIO_5,
+	GP_GPIO_6,
+	GP_GPIO_7,
+	GP_GPIO_8,
+	GP_GPIO_9,
+	GP_GPIO_10,
+	GP_GPIO_11,
+	GP_GPIO_12,
+	GP_GPIO_13,
+	GP_GPIO_14,
+	GP_GPIO_15,
+	GP_GPIO_16,
+	GP_BT_CLK_REQ,
+	GP_BT_HOST_WAKE,
+	GP_WIFI_QOW,
+	GP_TP71,
+	GP_TP74,
+	GP_TP101,
+	GP_TP102,
+	GPIRQ_RTC_RV4162,
+	GP_I2C1_ALT_SCL,
+	GP_I2C1_ALT_SDA,
+	GPIRQ_I2C2_SER2_TOUCH,
+	GP_SER2_GPIO5,
+	GP_SER2_GPIO6,
+	GP_SER2_FAN_OK,
+	GP_I2C2_GT911_RESET,
+	GPIRQ_SER2,
+	GPIRQ_I2C3_SER1_TOUCH,
+	GP_SER1_GPIO5,
+	GP_SER1_GPIO6,
+	GP_SER1_FAN_OK,
+	GP_I2C3_GT911_RESET,
+	GPIRQ_SER1,
+	GP_PCIE_DISABLE,
+	GPIRQ_WIFI,
+	GP_WIFI_WAKE,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_SEARCH,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/ap/ap_q2g.cfg u-boot-imx6/board/boundary/ap/ap_q2g.cfg
--- u-boot-2017.07/board/boundary/ap/ap_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/ap_q2g.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 6 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x430c031c
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03080301
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x030d031f
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0312025d
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x41333843
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3f3a3145
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x35373d31
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4231453c
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x000d0015
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001a0012
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000d001e
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000c0018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ap/bootscript_lp8860_eprom.txt u-boot-imx6/board/boundary/ap/bootscript_lp8860_eprom.txt
--- u-boot-2017.07/board/boundary/ap/bootscript_lp8860_eprom.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/bootscript_lp8860_eprom.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,60 @@
+gpio set 32
+gpio set 55
+vals="28 2f dc 7c 5f e5 f2 77 77 e1 bf ff 17 ef b0 04  cf 72 20 04 35 ae de cf 3e"
+setexpr addr 0x10080000
+setexpr addr2 0x10090000
+#
+for v in ${vals} ; do
+  mw.b ${addr} $v
+  setexpr addr ${addr} + 1
+done
+setexpr addr 0x10080000
+#
+for bus in 1 2 ; do
+  i2c dev ${bus}
+#
+  mw.b ${addr2} 0 19
+  i2c read 2d 60.1 19 ${addr2}
+#
+  if cmp.b ${addr} ${addr2} 19 ; then
+    echo "bus ${bus} already programmed"
+  else
+    echo "programming bus ${bus}"
+    for v in 8 ba ef ; do
+      if i2c mw 2d 1a.1 ${v} 1 ; then
+#        echo "${bus} unlock ${v}"
+      else
+        echo "error ${bus} unlock ${v}"
+      fi
+    done
+#
+    setexpr reg 0x60
+    for v in ${vals} ; do
+      if i2c mw 2d ${reg}.1 ${v} ; then
+#        echo "${bus} wrote ${reg} ${v}"
+      else
+        echo "error ${bus} writing ${reg} ${v}"
+      fi
+      setexpr reg ${reg} + 1
+    done
+#
+    for v in 2 0 ; do
+      if i2c mw 2d 19.1 ${v} 1 ; then
+#        echo "${bus} program ${v}"
+      else
+        echo "error ${bus} program ${v}"
+      fi
+      sleep 1
+    done
+#
+    i2c read 2d 60.1 19 ${addr2}
+#
+    if cmp.b ${addr} ${addr2} 19 ; then
+      echo "bus ${bus} verified"
+    else
+      echo "error bus ${bus} verify FAILED"
+    fi
+  fi
+done
+#
+exit
diff -Nru u-boot-2017.07/board/boundary/ap/Kconfig u-boot-imx6/board/boundary/ap/Kconfig
--- u-boot-2017.07/board/boundary/ap/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,24 @@
+if TARGET_AP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ap"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ap"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ap/MAINTAINERS u-boot-imx6/board/boundary/ap/MAINTAINERS
--- u-boot-2017.07/board/boundary/ap/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+AP BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ap/
+F:	include/configs/ap.h
+F:	configs/ap_q2g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/ap/Makefile u-boot-imx6/board/boundary/ap/Makefile
--- u-boot-2017.07/board/boundary/ap/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ap/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ap.o
diff -Nru u-boot-2017.07/board/boundary/ash/ash.c u-boot-imx6/board/boundary/ash/ash.c
--- u-boot-2017.07/board/boundary/ash/ash.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash/ash.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP_OUTPUT),
+
+	/* GPIO output assignments */
+#define GP_POWER_OFF		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLDN_OUTPUT),	/* 0 is on */
+#define GP_RBL			IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN_OUTPUT),
+#define GP_FAN1			IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLDN_OUTPUT),
+#define GP_FAN2			IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLDN_OUTPUT),
+#define GP_FAN3			IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_TIME_ACTIVE		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L3		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L2		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L1		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN_OUTPUT),
+#define GP_RESET_RBL		IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLDN_OUTPUT),
+#define GP_TEST_RBL		IMX_GPIO_NR(6, 3)
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_ENABLE_BSL_CB	IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_ENABLE_BSL_OB	IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_BSL_CB_ON_OFF	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_CALIBRATION_FLAG	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLDN_OUTPUT),
+
+	/* GPIO_KEYS assignments */
+#define GP_GPIOKEY_SW1		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),
+#define GP_GPIOKEY_SW2		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_GPIOKEY_SW3		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_GPIOKEY_SW4		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_GPIOKEY_SW5		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+#define GP_GPIOKEY_CH_ON_RBL	IMX_GPIO_NR(5, 27)
+	IOMUX_PAD_CTRL(CSI0_DAT9__GPIO5_IO27, WEAK_PULLUP),
+#define GP_GPIOKEY_SG_ON_RBL	IMX_GPIO_NR(5, 28)
+	IOMUX_PAD_CTRL(CSI0_DAT10__GPIO5_IO28, WEAK_PULLUP),
+#define GP_GPIOKEY_DOOR_CLOSED	IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hog Test points */
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP84			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_TP85			IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+	/* i2c1_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_TDA7491P_GAIN0	IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_GAIN1	IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_STBY	IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_MUTE	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_MIC_DET		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* i2c2 AR1021 */
+#define GPIRQ_AR1021		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),	/* High active */
+#define GP_AR1021_5WIRE		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* i2c2 ov5640 Mipi Camera */
+	IOMUX_PAD_CTRL(NANDF_CS2__CCM_CLKO2, OUTPUT_40OHM),
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET	IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+
+	/* i2c3 J6 */
+#define GPIRQ_I2C3_J6		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+#define GPIRQ_I2C3_RGB		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLDN),
+
+	/* PWM1 - Backlight on RGB connector: J15, pin 37 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/*
+	 * PWM4 - Backlight on LVDS connector: J4, pin 3
+	 * 0 is bright, 1 is dim
+	 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+	/* 0 is 8 bit */
+#define GP_8BIT_LVDS		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_BACKLIGHT_LVDS_EN	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+#define GP_UART1_RX_EN		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN_OUTPUT),	/* RS485 RX Enable: pull down */
+#define GP_UART1_TX_EN		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN_OUTPUT),	/* RS485 DEN: pull down */
+#define GP_UART1_RS485_EN	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN_OUTPUT),	/* RS485/!RS232 Select: pull down (rs232) */
+#define GP_UART1_AON		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLDN_OUTPUT),	/* ON: pull down */
+#define GP_UART1_RS485_TERM	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLDN_OUTPUT),	/* pull down */
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#define GP_USDHC3_POWER_EN	IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),	/* Pullup so that bmod mmc0 works */
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const iomux_v3_cfg_t sd3_usdhc3_pads[] = {
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+};
+
+/* This powers down the sd card faster */
+static const iomux_v3_cfg_t sd3_gpio_pads[] = {
+#define GP_USDHC3_CLK	IMX_GPIO_NR(7, 3)
+	IOMUX_PAD_CTRL(SD3_CLK__GPIO7_IO03, WEAK_PULLDN),
+#define GP_USDHC3_CMD	IMX_GPIO_NR(7, 2)
+	IOMUX_PAD_CTRL(SD3_CMD__GPIO7_IO02, WEAK_PULLDN),
+#define GP_USDHC3_DAT0	IMX_GPIO_NR(7, 4)
+	IOMUX_PAD_CTRL(SD3_DAT0__GPIO7_IO04, WEAK_PULLDN),
+#define GP_USDHC3_DAT1	IMX_GPIO_NR(7, 5)
+	IOMUX_PAD_CTRL(SD3_DAT1__GPIO7_IO05, WEAK_PULLDN),
+#define GP_USDHC3_DAT2	IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DAT2__GPIO7_IO06, WEAK_PULLDN),
+#define GP_USDHC3_DAT3	IMX_GPIO_NR(7, 7)
+	IOMUX_PAD_CTRL(SD3_DAT3__GPIO7_IO07, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int power_init_board(void)
+{
+	mdelay(3);
+	SETUP_IOMUX_PADS(sd3_usdhc3_pads);
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD, .gp_reset = GP_USDHC3_POWER_EN},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_8BIT_LVDS,
+			(di->pixfmt == IPU_PIX_FMT_RGB666) ? 1 : 0);
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable ^
+			((di->fbflags & FBF_BKLIT_LOW_ACTIVE) ? 1 : 0));
+	gpio_set_value(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_set_value(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* lvds */
+	VD_WVGA_TX23D200_18L(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_18H(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_24L(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_24H(LVDS, NULL, 0, 0x00),
+
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_POWER_OFF,
+	GP_RBL,
+	GP_FAN1,
+	GP_FAN2,
+	GP_FAN3,
+	GP_TIME_ACTIVE,
+	GP_PRG_L3,
+	GP_PRG_L2,
+	GP_PRG_L1,
+	GP_RESET_RBL,
+	GP_TEST_RBL,
+	GP_ENABLE_BSL_CB,
+	GP_ENABLE_BSL_OB,
+	GP_BSL_CB_ON_OFF,
+	GP_CALIBRATION_FLAG,
+	GP_TDA7491P_GAIN0,
+	GP_TDA7491P_GAIN1,
+	GP_TDA7491P_STBY,
+	GP_TDA7491P_MUTE,
+	GP_OV5640_MIPI_RESET,	/* camera reset */
+	GP_PCIE_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_8BIT_LVDS,
+	GP_BACKLIGHT_LVDS_EN,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_UART1_RX_EN,
+	GP_UART1_TX_EN,
+	GP_UART1_RS485_EN,
+	GP_UART1_AON,
+	GP_UART1_RS485_TERM,
+	GP_USDHC3_CLK,
+	GP_USDHC3_CMD,
+	GP_USDHC3_DAT0,
+	GP_USDHC3_DAT1,
+	GP_USDHC3_DAT2,
+	GP_USDHC3_DAT3,
+	GP_USDHC3_POWER_EN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_FLEXCAN_STANDBY,
+	GP_OV5640_MIPI_POWER_DOWN,	/* camera power down */
+	GP_BACKLIGHT_LVDS,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEY_SW1,
+	GP_GPIOKEY_SW2,
+	GP_GPIOKEY_SW3,
+	GP_GPIOKEY_SW4,
+	GP_GPIOKEY_SW5,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_CH_ON_RBL,
+	GP_GPIOKEY_SG_ON_RBL,
+	GP_GPIOKEY_DOOR_CLOSED,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_MIC_DET,
+	GPIRQ_AR1021,
+	GP_AR1021_5WIRE,
+	GPIRQ_I2C3_J6,
+	GP_PCIE_DISABLE,
+	GP_TP74,
+	GP_TP84,
+	GP_TP85,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(sd3_gpio_pads);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	/*
+	 * make all sd3 lines low so that voltage drops quicker.
+	 * Without this 10ms delay was not enough, now 2 is enough.
+	 */
+	SETUP_IOMUX_PADS(sd3_gpio_pads);
+	gpio_set_value(GP_USDHC3_POWER_EN, 0);
+	mdelay(2);
+	gpio_set_value(GP_POWER_OFF, 1);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"sw1",		GP_GPIOKEY_SW1,		'1', 1},
+	{"sw2",		GP_GPIOKEY_SW2,		'2', 1},
+	{"sw3",		GP_GPIOKEY_SW3,		'3', 1},
+	{"sw4",		GP_GPIOKEY_SW4,		'4', 1},
+	{"sw5",		GP_GPIOKEY_SW5,		'5', 1},
+	{"power",	GP_GPIOKEY_POWER,	'P', 1},
+	{"ch",		GP_GPIOKEY_CH_ON_RBL,	'C', 1},
+	{"sg",		GP_GPIOKEY_SG_ON_RBL,	'S', 1},
+	{"door",	GP_GPIOKEY_DOOR_CLOSED, 'D', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/ash/ash.cfg u-boot-imx6/board/boundary/ash/ash.cfg
--- u-boot-2017.07/board/boundary/ash/ash.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash/ash.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42310231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02180219
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x420c0214
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02030207
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42474b4e
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x46464a41
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x39342c29
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3232322e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040004b
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0035003d
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001e0022
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00220031
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ash/Kconfig u-boot-imx6/board/boundary/ash/Kconfig
--- u-boot-2017.07/board/boundary/ash/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,20 @@
+if TARGET_ASH
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ash"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ash"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ash/MAINTAINERS u-boot-imx6/board/boundary/ash/MAINTAINERS
--- u-boot-2017.07/board/boundary/ash/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ash/
+F:	include/configs/ash.h
+F:	configs/ash_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/ash/Makefile u-boot-imx6/board/boundary/ash/Makefile
--- u-boot-2017.07/board/boundary/ash/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ash.o
diff -Nru u-boot-2017.07/board/boundary/ash2/ash2.c u-boot-imx6/board/boundary/ash2/ash2.c
--- u-boot-2017.07/board/boundary/ash2/ash2.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash2/ash2.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,534 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP_OUTPUT),
+
+	/* GPIO output assignments */
+#define GP_POWER_OFF		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLDN_OUTPUT),	/* 0 is on */
+#define GP_RBL			IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN_OUTPUT),
+#define GP_FAN1			IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLDN_OUTPUT),
+#define GP_FAN2			IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLDN_OUTPUT),
+#define GP_FAN3			IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_TIME_ACTIVE		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L3		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L2		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN_OUTPUT),
+#define GP_PRG_L1		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN_OUTPUT),
+#define GP_RESET_RBL		IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLDN_OUTPUT),
+#define GP_TEST_RBL		IMX_GPIO_NR(6, 3)
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_ENABLE_BSL_CB	IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_ENABLE_BSL_OB	IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_BSL_CB_ON_OFF	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_CALIBRATION_FLAG	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLDN_OUTPUT),
+
+	/* GPIO_KEYS assignments */
+#define GP_GPIOKEY_SW1		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),
+#define GP_GPIOKEY_SW2		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_GPIOKEY_SW3		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_GPIOKEY_SW4		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_GPIOKEY_SW5		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GP_GPIOKEY_SW6		IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLUP),
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+#define GP_GPIOKEY_CH_ON_RBL	IMX_GPIO_NR(5, 27)
+	IOMUX_PAD_CTRL(CSI0_DAT9__GPIO5_IO27, WEAK_PULLUP),
+#define GP_GPIOKEY_SG_ON_RBL	IMX_GPIO_NR(5, 28)
+	IOMUX_PAD_CTRL(CSI0_DAT10__GPIO5_IO28, WEAK_PULLUP),
+#define GP_GPIOKEY_DOOR_CLOSED	IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hog Test points */
+#define GP_TP_R5		IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP84			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_TP85			IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+	/* i2c1_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_TDA7491P_GAIN0	IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_GAIN1	IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_STBY	IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_MUTE	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_MIC_DET		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* i2c2 AR1021 */
+#define GPIRQ_AR1021		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),	/* High active */
+#define GP_AR1021_5WIRE		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* i2c2 ov5640 Mipi Camera */
+	IOMUX_PAD_CTRL(NANDF_CS2__CCM_CLKO2, OUTPUT_40OHM),
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET	IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+
+	/* i2c3 J6 */
+#define GPIRQ_I2C3_J6		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/*
+	 * PWM4 - Backlight on LVDS connector: J4, pin 3
+	 * 0 is bright, 1 is dim
+	 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+	/* 0 is 8 bit */
+#define GP_8BIT_LVDS		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_BACKLIGHT_LVDS_EN	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+#define GP_UART1_RX_EN		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN_OUTPUT),	/* RS485 RX Enable: pull down */
+#define GP_UART1_TX_EN		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN_OUTPUT),	/* RS485 DEN: pull down */
+#define GP_UART1_RS485_EN	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN_OUTPUT),	/* RS485/!RS232 Select: pull down (rs232) */
+#define GP_UART1_AON		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLDN_OUTPUT),	/* ON: pull down */
+#define GP_UART1_RS485_TERM	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLDN_OUTPUT),	/* pull down */
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4  */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2  */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC2 - wlan */
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+#define GP_BT_HOST_WAKE		IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLDN),
+#define GP_BT_CLK_REQ		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#define GP_USDHC3_POWER_EN	IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),	/* Pullup so that bmod mmc0 works */
+};
+
+static const iomux_v3_cfg_t sd3_usdhc3_pads[] = {
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+};
+
+/* This powers down the sd card faster */
+static const iomux_v3_cfg_t sd3_gpio_pads[] = {
+#define GP_USDHC3_CLK	IMX_GPIO_NR(7, 3)
+	IOMUX_PAD_CTRL(SD3_CLK__GPIO7_IO03, WEAK_PULLDN),
+#define GP_USDHC3_CMD	IMX_GPIO_NR(7, 2)
+	IOMUX_PAD_CTRL(SD3_CMD__GPIO7_IO02, WEAK_PULLDN),
+#define GP_USDHC3_DAT0	IMX_GPIO_NR(7, 4)
+	IOMUX_PAD_CTRL(SD3_DAT0__GPIO7_IO04, WEAK_PULLDN),
+#define GP_USDHC3_DAT1	IMX_GPIO_NR(7, 5)
+	IOMUX_PAD_CTRL(SD3_DAT1__GPIO7_IO05, WEAK_PULLDN),
+#define GP_USDHC3_DAT2	IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DAT2__GPIO7_IO06, WEAK_PULLDN),
+#define GP_USDHC3_DAT3	IMX_GPIO_NR(7, 7)
+	IOMUX_PAD_CTRL(SD3_DAT3__GPIO7_IO07, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int power_init_board(void)
+{
+	mdelay(3);
+	SETUP_IOMUX_PADS(sd3_usdhc3_pads);
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD, .gp_reset = GP_USDHC3_POWER_EN},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_8BIT_LVDS,
+			(di->pixfmt == IPU_PIX_FMT_RGB666) ? 1 : 0);
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable ^
+			((di->fbflags & FBF_BKLIT_LOW_ACTIVE) ? 1 : 0));
+	gpio_set_value(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* lvds */
+	VD_WVGA_TX23D200_18L(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_18H(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_24L(LVDS, NULL, 0, 0x00),
+	VD_WVGA_TX23D200_24H(LVDS, NULL, 0, 0x00),
+
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_POWER_OFF,
+	GP_RBL,
+	GP_FAN1,
+	GP_FAN2,
+	GP_FAN3,
+	GP_TIME_ACTIVE,
+	GP_PRG_L3,
+	GP_PRG_L2,
+	GP_PRG_L1,
+	GP_RESET_RBL,
+	GP_TEST_RBL,
+	GP_ENABLE_BSL_CB,
+	GP_ENABLE_BSL_OB,
+	GP_BSL_CB_ON_OFF,
+	GP_CALIBRATION_FLAG,
+	GP_TDA7491P_GAIN0,
+	GP_TDA7491P_GAIN1,
+	GP_TDA7491P_STBY,
+	GP_TDA7491P_MUTE,
+	GP_OV5640_MIPI_RESET,	/* camera reset */
+	GP_8BIT_LVDS,
+	GP_BACKLIGHT_LVDS_EN,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,
+	GP_UART1_RX_EN,
+	GP_UART1_TX_EN,
+	GP_UART1_RS485_EN,
+	GP_UART1_AON,
+	GP_UART1_RS485_TERM,
+	GP_USDHC3_CLK,
+	GP_USDHC3_CMD,
+	GP_USDHC3_DAT0,
+	GP_USDHC3_DAT1,
+	GP_USDHC3_DAT2,
+	GP_USDHC3_DAT3,
+	GP_USDHC3_POWER_EN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_FLEXCAN_STANDBY,
+	GP_OV5640_MIPI_POWER_DOWN,	/* camera power down */
+	GP_BACKLIGHT_LVDS,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEY_SW1,
+	GP_GPIOKEY_SW2,
+	GP_GPIOKEY_SW3,
+	GP_GPIOKEY_SW4,
+	GP_GPIOKEY_SW5,
+	GP_GPIOKEY_SW6,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_CH_ON_RBL,
+	GP_GPIOKEY_SG_ON_RBL,
+	GP_GPIOKEY_DOOR_CLOSED,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_MIC_DET,
+	GPIRQ_AR1021,
+	GP_AR1021_5WIRE,
+	GPIRQ_I2C3_J6,
+	GP_TP_R5,
+	GP_TP74,
+	GP_TP84,
+	GP_TP85,
+	GP_USDHC3_CD,
+	GPIRQ_WIFI,
+	GP_WIFI_WAKE,
+	GP_WIFI_QOW,
+	GP_BT_HOST_WAKE,
+	GP_BT_CLK_REQ,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(sd3_gpio_pads);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	/*
+	 * make all sd3 lines low so that voltage drops quicker.
+	 * Without this 10ms delay was not enough, now 2 is enough.
+	 */
+	SETUP_IOMUX_PADS(sd3_gpio_pads);
+	gpio_set_value(GP_USDHC3_POWER_EN, 0);
+	mdelay(2);
+	gpio_set_value(GP_POWER_OFF, 1);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"sw1",		GP_GPIOKEY_SW1,		'1', 1},
+	{"sw2",		GP_GPIOKEY_SW2,		'2', 1},
+	{"sw3",		GP_GPIOKEY_SW3,		'3', 1},
+	{"sw4",		GP_GPIOKEY_SW4,		'4', 1},
+	{"sw5",		GP_GPIOKEY_SW5,		'5', 1},
+	{"sw6",		GP_GPIOKEY_SW6,		'6', 1},
+	{"power",	GP_GPIOKEY_POWER,	'P', 1},
+	{"ch",		GP_GPIOKEY_CH_ON_RBL,	'C', 1},
+	{"sg",		GP_GPIOKEY_SG_ON_RBL,	'S', 1},
+	{"door",	GP_GPIOKEY_DOOR_CLOSED, 'D', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/ash2/ash2.cfg u-boot-imx6/board/boundary/ash2/ash2.cfg
--- u-boot-2017.07/board/boundary/ash2/ash2.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash2/ash2.cfg	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL       0x42340232
+#define MX6_MMDC_P0_MPDGCTRL1_VAL       0x0219021f
+#define MX6_MMDC_P1_MPDGCTRL0_VAL       0x4214021e
+#define MX6_MMDC_P1_MPDGCTRL1_VAL       0x020c0210
+#define MX6_MMDC_P0_MPRDDLCTL_VAL       0x4145474d
+#define MX6_MMDC_P1_MPRDDLCTL_VAL       0x49464845
+#define MX6_MMDC_P0_MPWRDLCTL_VAL       0x36352c2a
+#define MX6_MMDC_P1_MPWRDLCTL_VAL       0x3433352e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL     0x003b0047
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL     0x0035003b
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL     0x00200024
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL     0x00220032
+#define WALAT   1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ash2/Kconfig u-boot-imx6/board/boundary/ash2/Kconfig
--- u-boot-2017.07/board/boundary/ash2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash2/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,20 @@
+if TARGET_ASH2
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ash2"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ash2"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ash2/MAINTAINERS u-boot-imx6/board/boundary/ash2/MAINTAINERS
--- u-boot-2017.07/board/boundary/ash2/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash2/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ash2/
+F:	include/configs/ash2.h
+F:	configs/ash2_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/ash2/Makefile u-boot-imx6/board/boundary/ash2/Makefile
--- u-boot-2017.07/board/boundary/ash2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ash2/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ash2.o
diff -Nru u-boot-2017.07/board/boundary/bootscripts/bootscript-mainline.txt u-boot-imx6/board/boundary/bootscripts/bootscript-mainline.txt
--- u-boot-2017.07/board/boundary/bootscripts/bootscript-mainline.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/bootscript-mainline.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,150 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+a_base=0x10000000
+if itest.s x51 == "x${imx_cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x80000000
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${fdt_file}" ; then
+	if itest.s x6SOLO == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${imx_cpu}" ; then
+		fdt_file=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${imx_cpu}" ; then
+		fdt_file=imx6sx-${board}.dtb;
+	elif itest.s x7D == "x${imx_cpu}" ; then
+		fdt_file=imx7d-${board}.dtb;
+	elif itest.s x51 == "x${imx_cpu}" ; then
+		fdt_file=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${imx_cpu}" ; then
+		fdt_file=imx53-${board}${m4}.dtb;
+	else
+		fdt_file=imx6q-${board}.dtb;
+	fi
+fi
+
+if load ${devtype} ${devnum}:1 ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+
+if itest.s x${distro_bootpart} == x ; then
+	distro_bootpart=1
+fi
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_fdt} ${prefix}${fdt_file} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${prefix}${fdt_file}";
+	exit;
+fi
+
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+fi
+
+## HDMI ##
+if itest.s "xoff" == "x$fb_hdmi" ; then
+	setenv bootargs $bootargs video=HDMI-A-1:d
+else
+	if itest.s "x" != "x$force_edid" ; then
+		echo "------ forcing EDID to /lib/firmware/$force_edid"
+		setenv bootargs $bootargs drm_kms_helper.edid_firmware=$force_edid
+	fi
+fi
+
+## LVDS ##
+if itest.s "xoff" == "x$fb_lvds" ; then
+	setenv bootargs $bootargs video=LVDS-1:d
+elif itest.s "xhannstar7" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "hannstar,hsd070pww1"
+elif itest.s "xtm070jdhg30" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "tianma,tm070jdhg30"
+elif itest.s "xdt070btft" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "innolux,zj070na-01p"
+fi
+
+if itest.s "xoff" == "x$fb_lvds2" ; then
+	setenv bootargs $bootargs video=LVDS-2:d
+elif itest.s "xhannstar7" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "hannstar,hsd070pww1"
+elif itest.s "xtm070jdhg30" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "tianma,tm070jdhg30"
+elif itest.s "xdt070btft" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "innolux,zj070na-01p"
+fi
+
+## LCD ##
+if itest.s "xoff" == "x$fb_lcd" ; then
+	setenv bootargs $bootargs video=VGA-1:d
+fi
+
+if itest.s x${rfspart} == x ; then
+	rfspart=2
+fi
+
+if itest.s "x" == "x${root}"; then
+	part uuid ${devtype} ${devnum}:${rfspart} uuid
+	if itest.s "x" != "x${uuid}"; then
+		root=PARTUUID=${uuid}
+	elif test "sata" = "${devtype}" || test "usb" = "${devtype}" ; then
+		root=/dev/sda${rfspart}
+	else
+		root=/dev/mmcblk${devnum}p${rfspart}
+	fi
+fi
+
+if itest.s "x" == "x$cma" ; then
+	cma=256M
+fi
+
+if itest.s "x" == "x$vmalloc" ; then
+	vmalloc=400M
+fi
+
+if itest.s "x" != "x$show_fdt" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x$show_env" ; then
+	printenv
+fi
+
+setenv bootargs "$bootargs console=${console},115200 vmalloc=${vmalloc}"
+setenv bootargs "$bootargs cma=${cma} consoleblank=0 root=${root} rootwait"
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+setenv bootargs ${bootargs} snd.slots=,snd-soc-imx-hdmi
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_zImage} ${prefix}zImage ; then
+	bootz ${a_zImage} - ${a_fdt}
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/bootscripts/bootscript-ubuntu.txt u-boot-imx6/board/boundary/bootscripts/bootscript-ubuntu.txt
--- u-boot-2017.07/board/boundary/bootscripts/bootscript-ubuntu.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/bootscript-ubuntu.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,213 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+m4=''
+a_base=0x10000000
+if itest.s x51 == "x${imx_cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x80000000
+	if itest.s "x1" == "x$m4enabled" ; then
+		run m4boot;
+		m4='-m4';
+	fi
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${fdt_file}" ; then
+	if itest.s x6SOLO == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${imx_cpu}" ; then
+		fdt_file=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${imx_cpu}" ; then
+		fdt_file=imx6sx-${board}${m4}.dtb;
+	elif itest.s x7D == "x${imx_cpu}" ; then
+		fdt_file=imx7d-${board}${m4}.dtb;
+	elif itest.s x51 == "x${imx_cpu}" ; then
+		fdt_file=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${imx_cpu}" ; then
+		fdt_file=imx53-${board}${m4}.dtb;
+	else
+		fdt_file=imx6q-${board}.dtb;
+	fi
+fi
+
+if itest.s x${distro_bootpart} == x ; then
+	distro_bootpart=1
+fi
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+
+if itest.s x${console} != x ; then
+	setenv bootargs ${bootargs} console=${console},115200
+fi
+setenv bootargs ${bootargs} vmalloc=400M consoleblank=0 rootwait fixrtc cpu=${imx_cpu} board=${board}
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_fdt} ${prefix}${fdt_file} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${prefix}${fdt_file}";
+	exit;
+fi
+
+cmd_xxx_present=
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" != "x${cmd_hdmi}" ; then
+	run cmd_hdmi
+	cmd_xxx_present=1;
+	if itest.s x == x${allow_noncea} ; then
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+fi
+
+if itest.s "x" != "x${cmd_lcd}" ; then
+	run cmd_lcd
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lcd2}" ; then
+	run cmd_lcd2
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds}" ; then
+	run cmd_lvds
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds2}" ; then
+	run cmd_lvds2
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" == "x${cmd_xxx_present}" ; then
+	echo "!!!!!!!!!!!!!!!!"
+	echo "warning: your u-boot may be outdated, please upgrade"
+	echo "!!!!!!!!!!!!!!!!"
+fi
+
+setexpr b0 ${distro_bootpart} % 0x0a;
+setexpr b1 ${distro_bootpart} / 0x0a;
+#this is to show a decimal number when really hex is output
+setexpr bpart ${b1} * 0x10
+setexpr bpart ${bpart} + ${b0};
+
+if test "sata" = "${devtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+elif test "usb" = "${devtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+else
+	setenv bootargs "${bootargs} root=/dev/mmcblk${devnum}p${bpart}"
+fi
+
+if itest.s "x" != "x${disable_msi}" ; then
+	setenv bootargs ${bootargs} pci=nomsi
+fi;
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs ${bootargs} fec.disable_giga=1
+fi
+
+if itest.s "x" != "x${wlmac}" ; then
+	setenv bootargs ${bootargs} wlan.mac=${wlmac} wlcore.mac=${wlmac}
+fi
+
+if itest.s "x" != "x${bd_addr}" ; then
+	setenv bootargs ${bootargs} bd_addr=${bd_addr}
+fi
+
+if itest.s "x" != "x${gpumem}" ; then
+	setenv bootargs ${bootargs} galcore.contiguousSize=${gpumem}
+fi
+
+
+if itest.s "no" != "${dosplash}" ; then
+	if itest.s "x" == "x${loglevel}" ; then
+		loglevel=4
+	fi
+	setenv bootargs ${bootargs} splash plymouth.ignore-serial-consoles
+fi
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+
+if itest.s "x" != "x${overlayfs}" ; then
+	setenv bootargs ${bootargs} overlayfs=${overlayfs}
+	if itest.s "x" != "x${ofs-size}" ; then
+		setenv bootargs ${bootargs} ofs-size=${ofs-size}
+	fi
+fi
+
+if itest.s "x" != "x${cma}" ; then
+	setenv bootargs ${bootargs} cma=${cma}
+fi
+setenv bootargs ${bootargs} snd.slots=,snd-soc-imx-hdmi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if kbd ; then
+        if itest.s "xv" == "x${keybd}" ; then
+                load ${devtype} ${devnum}:${distro_bootpart} ${a_zImage} ${prefix}uImage-recovery &&
+                load ${devtype} ${devnum}:${distro_bootpart} ${a_ramdisk} ${prefix}uramdisk-recovery.img &&
+                bootm ${a_zImage} ${a_ramdisk};
+                echo "--- error launching recovery!"
+                exit;
+        fi
+fi
+
+echo "----------- trying to load /initrd.img";
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_initrd} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+if itest.s x${haverd} == x ; then
+	if load ${devtype} ${devnum}:${distro_bootpart} ${a_zImage} /vmlinuz ; then
+		setenv bootargs ${bootargs} rw
+		bootz ${a_zImage} - ${a_fdt}
+	fi
+else
+	if load ${devtype} ${devnum}:${distro_bootpart} ${a_zImage} /vmlinuz ; then
+		bootz ${a_zImage} ${a_initrd}:${initrd_size} ${a_fdt} ;
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/bootscripts/bootscript-yocto.txt u-boot-imx6/board/boundary/bootscripts/bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/bootscripts/bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/bootscript-yocto.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,165 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+m4=''
+a_base=0x10000000
+if itest.s x51 == "x${imx_cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x80000000
+	if itest.s "x1" == "x$m4enabled" ; then
+		run m4boot;
+		m4='-m4';
+	fi
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${fdt_file}" ; then
+	if itest.s x6SOLO == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${imx_cpu}" ; then
+		fdt_file=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${imx_cpu}" ; then
+		fdt_file=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${imx_cpu}" ; then
+		fdt_file=imx6sx-${board}${m4}.dtb;
+	elif itest.s x7D == "x${imx_cpu}" ; then
+		fdt_file=imx7d-${board}${m4}.dtb;
+	elif itest.s x51 == "x${imx_cpu}" ; then
+		fdt_file=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${imx_cpu}" ; then
+		fdt_file=imx53-${board}${m4}.dtb;
+	else
+		fdt_file=imx6q-${board}.dtb;
+	fi
+fi
+
+if itest.s x${distro_bootpart} == x ; then
+	distro_bootpart=1
+fi
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+setenv bootargs ${bootargs} console=${console},115200 vmalloc=400M consoleblank=0 rootwait fixrtc cpu=${imx_cpu} board=${board}
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_fdt} ${prefix}${fdt_file} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${prefix}${fdt_file}";
+	exit;
+fi
+
+cmd_xxx_present=
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" != "x${cmd_hdmi}" ; then
+	run cmd_hdmi
+	cmd_xxx_present=1;
+	if itest.s x == x${allow_noncea} ; then
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+fi
+
+if itest.s "x" != "x${cmd_lcd}" ; then
+	run cmd_lcd
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lcd2}" ; then
+	run cmd_lcd2
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds}" ; then
+	run cmd_lvds
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds2}" ; then
+	run cmd_lvds2
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" == "x${cmd_xxx_present}" ; then
+	echo "!!!!!!!!!!!!!!!!"
+	echo "warning: your u-boot may be outdated, please upgrade"
+	echo "!!!!!!!!!!!!!!!!"
+fi
+
+bpart=2
+
+if test "sata" = "${devtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+elif test "usb" = "${devtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+else
+	setenv bootargs "${bootargs} root=/dev/mmcblk${devnum}p${bpart}"
+fi
+
+if itest.s "x" != "x${disable_msi}" ; then
+	setenv bootargs ${bootargs} pci=nomsi
+fi;
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs ${bootargs} fec.disable_giga=1
+fi
+
+if itest.s "x" != "x${wlmac}" ; then
+	setenv bootargs ${bootargs} wlan.mac=${wlmac} wlcore.mac=${wlmac}
+fi
+
+if itest.s "x" != "x${bd_addr}" ; then
+	setenv bootargs ${bootargs} bd_addr=${bd_addr}
+fi
+
+if itest.s "x" != "x${gpumem}" ; then
+	setenv bootargs ${bootargs} galcore.contiguousSize=${gpumem}
+fi
+
+if itest.s "x" != "x${cma}" ; then
+	setenv bootargs ${bootargs} cma=${cma}
+fi
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+setenv bootargs ${bootargs} snd.slots=,snd-soc-imx-hdmi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if load ${devtype} ${devnum}:${distro_bootpart} ${a_zImage} ${prefix}zImage ; then
+	bootz ${a_zImage} - ${a_fdt}
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/bootscripts/net_upgrade_fs.txt u-boot-imx6/board/boundary/bootscripts/net_upgrade_fs.txt
--- u-boot-2017.07/board/boundary/bootscripts/net_upgrade_fs.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/net_upgrade_fs.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,73 @@
+# remove from environment so they won't override local values
+setenv upgraded_fs
+setenv a_base
+setenv imagefile
+
+upgraded_fs=0
+a_base=0x10200000
+
+if itest.s x51 == "x${imx_cpu}"; then
+	a_base=0x90200000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x70200000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x80200000
+fi
+
+if itest.s x != "x${upgrade_file}" ; then
+	imagefile=${upgrade_file}
+else
+	imagefile=trusty.img.gz
+fi
+
+echo "Trying to load ${imagefile} (about 5...10 minutes)"
+if itest.s x == "x${upgrade_device}" ; then
+	upgrade_device="mmc 1"
+fi
+ 
+setexpr i 0;
+setexpr offset 0;
+while test ${i} -le 99
+do
+	if tftp ${a_base} ${imagefile}.${i} ; then
+		echo "Extracting file ${imagefile}.${i} to ${upgrade_device}"
+		setexpr end ${a_base} + ${filesize}
+		setexpr end ${end} - 1
+		setexpr.b sz3 *${end} * 0x1000000
+		setexpr end ${end} - 1
+		setexpr.b sz2 *${end} * 0x10000
+		setexpr end ${end} - 1
+		setexpr.b sz1 *${end} * 0x100
+		setexpr end ${end} - 1
+		setexpr.b sz0 *${end}
+		setexpr sz ${sz3} + ${sz2}
+		setexpr sz ${sz} + ${sz1}
+		setexpr sz ${sz} + ${sz0}
+		if gzwrite ${upgrade_device} ${a_base} 0x${filesize} 0x100000 0x${offset} 0x${sz}; then
+			echo "Successfully wrote segment ${i} of ${sz} bytes"
+			setexpr i ${i} + 1;
+			setexpr rem ${i} % 0x10;
+			if test ${rem} -eq 0x0a ; then
+				#this is to show a decimal number when really hex is output
+				setexpr i ${i} + 6;
+			fi;
+			setexpr offset ${offset} + ${sz}
+		else
+			echo "Error writing segment ${i} of ${sz} bytes"
+			setexpr i ${i} + 1000;
+		fi
+	else
+		if test ${i} -eq 0 ; then
+			echo "image file not found or its too big to fit in the memory";
+			echo "expected file name : ${imagefile}.${i}";
+			echo "exiting..."
+			setexpr i ${i} + 1000;
+		else
+			upgraded_fs=1
+			echo "---- ${upgrade_device} upgraded"
+			echo ; echo
+			sleep 2
+			setexpr i ${i} + 1000;
+		fi
+	fi
+done
diff -Nru u-boot-2017.07/board/boundary/bootscripts/net_upgradeu_fs.txt u-boot-imx6/board/boundary/bootscripts/net_upgradeu_fs.txt
--- u-boot-2017.07/board/boundary/bootscripts/net_upgradeu_fs.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/net_upgradeu_fs.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,35 @@
+# if upgrade_device is set in environment, it will override the value here
+# if net_upgrade_fs is set in environment, it will override the value here
+#
+# remove from environment so they won't override local values
+setenv a_script
+
+a_script=0x1000c000
+if itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_script=0x8000c000
+fi
+# uncomment below to force upgrade to eMMC,
+# regardless of where script was sourced.
+# devtype=mmc
+# devnum=1
+if itest.s "x${devtype}" == "x" ; then
+	# loading from network, default to eMMC
+	# may have to start script twice if loading from network
+	devtype=mmc
+	devnum=1
+fi
+run clearenv
+
+upgrade_device="${devtype} ${devnum}"
+net_upgrade_fs=net_upgrade_fs.scr;
+dhcp ${a_script} ${net_upgrade_fs} && source ${a_script}
+if itest.s "x${upgraded_fs}" == "x1" ; then
+	# file system has changed, load new bootscript
+	# and execute
+	${devtype} dev ${devnum}
+	load ${devtype} ${devnum}:${distro_bootpart} ${a_script} /boot.scr &&
+	source ${a_script}
+fi
+while echo "---- FS upgrade FAILED!!!" ; do
+	sleep 120
+done
diff -Nru u-boot-2017.07/board/boundary/bootscripts/net_upgradeu.txt u-boot-imx6/board/boundary/bootscripts/net_upgradeu.txt
--- u-boot-2017.07/board/boundary/bootscripts/net_upgradeu.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/net_upgradeu.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,168 @@
+if itest.s a${uboot_defconfig} == a; then
+        echo "Please set uboot_defconfig to the appropriate value"
+        exit
+fi
+
+# remove from environment so they won't override local values
+setenv offset
+setenv erase_size
+setenv qspi_offset
+setenv a_base
+setenv qspi_match
+setenv n
+
+offset=0x400
+erase_size=0xC0000
+qspi_offset=0x0
+a_base=0x10100000
+
+if itest.s x51 == "x${imx_cpu}"; then
+	a_base=0x90100000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x70100000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x80100000
+fi
+
+qspi_match=1
+setexpr a_qspi1 ${a_base}
+setexpr a_qspi2 ${a_qspi1} + 0x400000
+setexpr a_uImage1 ${a_qspi1} + 0x400
+setexpr a_uImage2 ${a_qspi2} + 0x400
+setexpr a_script ${a_base}
+
+setenv stdout serial,vga
+
+if sf probe || sf probe || sf probe 1 27000000 || sf probe 1 27000000 ; then
+	echo "probed SPI ROM" ;
+else
+	echo "Error initializing EEPROM"
+	exit
+fi
+
+if itest.s "x${sfname}" == "xat45db041d" ; then
+	erase_size=0x7e000
+fi
+
+if itest.s x7D == "x${imx_cpu}"; then
+	echo "check qspi parameter block" ;
+	if tftp ${a_qspi1} qspi-${sfname}.${uboot_defconfig} ; then
+	else
+		echo "parameter file qspi-${sfname}.${uboot_defconfig} not found on TFTP server"
+		exit
+	fi
+	if itest ${filesize} != 0x200 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} 0x${filesize} != 0x200 bytes" ;
+		exit
+	fi
+	setexpr a_marker ${a_qspi1} + 0x1fc
+	if itest *${a_marker} != c0ffee01 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} c0ffee01 marker missing" ;
+		exit
+	fi
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error reading qspi parameter from EEPROM"
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+		echo "------- qspi parameters match"
+	else
+		echo "------- qspi parameters mismatch"
+		qspi_match=0
+	fi
+fi
+
+echo "check U-Boot" ;
+
+if tftp ${a_uImage1} u-boot.${uboot_defconfig} ; then
+else
+	echo "File u-boot.${uboot_defconfig} not found on TFTP server" ;
+	exit
+fi
+echo "read ${filesize} bytes" ;
+if sf read ${a_uImage2} ${offset} ${filesize} ; then
+else
+	echo "Error reading boot loader from EEPROM" ;
+	exit
+fi
+
+if cmp.b ${a_uImage1} ${a_uImage2} ${filesize} ; then
+	echo "------- U-Boot versions match" ;
+	if itest.s "${qspi_match}" == "1" ; then
+		echo "------- u-boot upgrade not needed" ;
+		if itest.s x != "x${net_upgrade_fs}" ; then
+			if tftp ${a_base} ${net_upgrade_fs} ; then
+				echo "------- running ${net_upgrade_fs}" ;
+				source ${a_base}
+			else
+				echo "------- ${net_upgrade_fs} not found on TFTP server" ;
+			fi
+		fi
+		exit
+	fi
+	erase_size=0x1000
+	if itest.s xMX25L6405D == "x${sfname}"; then
+		erase_size=0x10000
+	fi
+	setexpr filesize ${erase_size} - ${offset}
+fi
+
+echo "Need U-Boot upgrade" ;
+echo "Program in 5 seconds" ;
+for n in 5 4 3 2 1 ; do
+	echo ${n} ;
+	sleep 1 ;
+done
+echo "erasing" ;
+sf erase 0 ${erase_size} ;
+
+# two steps to prevent bricking
+echo "programming" ;
+setexpr a1 ${a_uImage1} + 0x400
+setexpr o1 ${offset} + 0x400
+setexpr s1 ${filesize} - 0x400
+sf write ${a1} ${o1} ${s1} ;
+sf write ${a_uImage1} ${offset} 0x400 ;
+
+if itest.s x7D == "x${imx_cpu}"; then
+	sf write ${a_qspi1} ${qspi_offset} 0x200
+fi
+
+echo "verifying" ;
+if sf read ${a_uImage2} ${offset} ${filesize} ; then
+else
+	echo "Error re-reading EEPROM" ;
+	exit
+fi
+if cmp.b ${a_uImage1} ${a_uImage2} ${filesize} ; then
+else
+	echo "Read verification error" ;
+	exit
+fi
+
+if itest.s x7D == "x${imx_cpu}"; then
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error re-reading qspi" ;
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+	else
+		echo "qspi parameter block verification error" ;
+		exit
+	fi
+fi
+
+if itest.s "x" != "x${next}" ; then
+	if tftp ${a_script} ${next} ; then
+		source ${a_script}
+	else
+		echo "${next} not found"
+	fi
+fi
+
+echo "---- U-Boot upgraded. resetting"
+sleep 2
+reset
+
diff -Nru u-boot-2017.07/board/boundary/bootscripts/prog_fuses.txt u-boot-imx6/board/boundary/bootscripts/prog_fuses.txt
--- u-boot-2017.07/board/boundary/bootscripts/prog_fuses.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/prog_fuses.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,27 @@
+for f in fuse1 fuse2 fuse_mac1b fuse_mac1a ; do
+	setenv t "fuse=0x\${${f}}; fuse_val=0x\${${f}_val}"
+	run t
+
+	if itest.s "0x" != "${fuse}" ; then
+		if itest.s "0x" == "${fuse_val}" ; then
+			echo ${f}_val is not set
+			exit
+		fi
+		fuse read ${fuse}
+		if itest.s "0x" == "0x${fuse_read_val0}" ; then
+			echo "uboot version too old"
+			exit
+		fi
+		if itest.s "0x${fuse_read_val0}" == "${fuse_val}" ; then
+			echo "fuse ${fuse} verified"
+		else
+			if itest.s "${fuse_read_val0}" == "00000000" ; then
+				fuse prog -y ${fuse} ${fuse_val}
+				echo fuse prog ${fuse} ${fuse_val}
+			else
+				echo "fuse ${fuse} already set to 0x${fuse_read_val0}, aborting write of ${fuse_val}"
+				exit
+			fi
+		fi
+	fi
+done
diff -Nru u-boot-2017.07/board/boundary/bootscripts/README.md u-boot-imx6/board/boundary/bootscripts/README.md
--- u-boot-2017.07/board/boundary/bootscripts/README.md	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/README.md	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,19 @@
+Boot scripts
+============
+
+This folder contains all the boot scripts for booting / upgrading any OS:
+* `bootscript-mainline.txt`: boot script for any OS using mainline-based kernel
+* `bootscript-ubuntu.txt`: boot script for Ubuntu OS using NXP-based kernel
+* `bootscript-yocto.txt`: boot script for Yocto OS using NXP-based kernel
+* `net_upgrade_fs.txt`: downloads `${upgrade_file}` over TFTP and flashes it into `${upgrade_device}`
+* `net_upgradeu_fs.txt`: downloads `${net_upgrade_fs}` over TFTP and executes it
+* `net_upgradeu.txt`: downloads `u-boot.${uboot_defconfig}` over TFTP and flashes it into NOR flash
+* `prog_fuses.txt`: program the fuses for both MAC address and boot selection
+* `upgrade.txt`: downloads `u-boot.${uboot_defconfig}` from local media and flashes it into NOR flash
+
+Those `.txt` files need to be transformed into U-Boot scripts (`.scr`) using `mkimage`.
+
+Here is an example for generating a `boot.scr` for Yocto OS:
+```
+mkimage -A arm -O linux -T script -C none -a 0 -e 0 -n "bootscript" -d bootscript-yocto.txt boot.scr
+```
diff -Nru u-boot-2017.07/board/boundary/bootscripts/upgrade.txt u-boot-imx6/board/boundary/bootscripts/upgrade.txt
--- u-boot-2017.07/board/boundary/bootscripts/upgrade.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bootscripts/upgrade.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,158 @@
+if itest.s a$uboot_defconfig == a; then
+        echo "Please set uboot_defconfig to the appropriate value"
+        exit
+fi
+
+offset=0x400
+erase_size=0xC0000
+qspi_offset=0x0
+a_base=0x12000000
+
+if itest.s x51 == "x${imx_cpu}"; then
+	a_base=0x92000000
+elif itest.s x53 == "x${imx_cpu}"; then
+	a_base=0x72000000
+elif itest.s x6SX == "x${imx_cpu}" || itest.s x7D == "x${imx_cpu}"; then
+	a_base=0x82000000
+fi
+
+qspi_match=1
+setexpr a_qspi1 ${a_base}
+setexpr a_qspi2 ${a_qspi1} + 0x400000
+setexpr a_uImage1 ${a_qspi1} + 0x400
+setexpr a_uImage2 ${a_qspi2} + 0x400
+setexpr a_script ${a_base}
+
+setenv stdout serial,vga
+
+if sf probe || sf probe || sf probe 1 27000000 || sf probe 1 27000000 ; then
+	echo "probed SPI ROM" ;
+else
+	echo "Error initializing EEPROM"
+	exit
+fi
+
+if itest.s "x${sfname}" == "xat45db041d" ; then
+	erase_size=0x7e000
+fi
+
+if itest.s x7D == "x${imx_cpu}"; then
+	echo "check qspi parameter block" ;
+	if ${fs}load ${devtype} ${devnum}:${distro_bootpart} ${a_qspi1} qspi-${sfname}.${uboot_defconfig} ; then
+	else
+		echo "parameter file qspi-${sfname}.${uboot_defconfig} not found on SD card"
+		exit
+	fi
+	if itest ${filesize} != 0x200 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} 0x${filesize} != 0x200 bytes" ;
+		exit
+	fi
+	setexpr a_marker ${a_qspi1} + 0x1fc
+	if itest *${a_marker} != c0ffee01 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} c0ffee01 marker missing" ;
+		exit
+	fi
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error reading qspi parameter from EEPROM"
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+		echo "------- qspi parameters match"
+	else
+		echo "------- qspi parameters mismatch"
+		qspi_match=0
+	fi
+fi
+
+echo "check U-Boot" ;
+
+if ${fs}load ${devtype} ${devnum}:${distro_bootpart} ${a_uImage1} u-boot.$uboot_defconfig ; then
+else
+	echo "File u-boot.$uboot_defconfig not found on SD card" ;
+	exit
+fi
+echo "read $filesize bytes from SD card" ;
+if sf read ${a_uImage2} $offset $filesize ; then
+else
+	echo "Error reading boot loader from EEPROM" ;
+	exit
+fi
+
+if cmp.b ${a_uImage1} ${a_uImage2} $filesize ; then
+	echo "------- U-Boot versions match" ;
+	if itest.s "${qspi_match}" == "1" ; then
+		echo "------- upgrade not needed" ;
+		if itest.s "x" != "x${next}" ; then
+			if ${fs}load ${devtype} ${devnum}:${distro_bootpart} ${a_script} ${next} ; then
+				source ${a_script}
+			else
+				echo "${next} not found on SD card"
+			fi
+		fi
+		exit
+	fi
+	erase_size=0x1000
+	if itest.s xMX25L6405D == "x${sfname}"; then
+		erase_size=0x10000
+	fi
+	setexpr filesize ${erase_size} - ${offset}
+fi
+
+echo "Need U-Boot upgrade" ;
+echo "Program in 5 seconds" ;
+for n in 5 4 3 2 1 ; do
+	echo $n ;
+	sleep 1 ;
+done
+echo "erasing" ;
+sf erase 0 ${erase_size} ;
+
+# two steps to prevent bricking
+echo "programming" ;
+setexpr a1 ${a_uImage1} + 0x400
+setexpr o1 ${offset} + 0x400
+setexpr s1 ${filesize} - 0x400
+sf write ${a1} ${o1} ${s1} ;
+sf write ${a_uImage1} $offset 0x400 ;
+
+if itest.s x7D == "x${imx_cpu}"; then
+	sf write ${a_qspi1} ${qspi_offset} 0x200
+fi
+
+echo "verifying" ;
+if sf read ${a_uImage2} $offset $filesize ; then
+else
+	echo "Error re-reading EEPROM" ;
+	exit
+fi
+if cmp.b ${a_uImage1} ${a_uImage2} $filesize ; then
+else
+	echo "Read verification error" ;
+	exit
+fi
+
+if itest.s x7D == "x${imx_cpu}"; then
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error re-reading qspi" ;
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+	else
+		echo "qspi parameter block verification error" ;
+		exit
+	fi
+fi
+
+if itest.s "x" != "x${next}" ; then
+	if ${fs}load ${devtype} ${devnum}:${distro_bootpart} ${a_script} ${next} ; then
+		source ${a_script}
+	else
+		echo "${next} not found on ${devtype} ${devnum}:${distro_bootpart}"
+	fi
+fi
+
+while echo "---- U-Boot upgraded. reset" ; do
+	sleep 120
+done
diff -Nru u-boot-2017.07/board/boundary/bt/6x_bootscript.txt u-boot-imx6/board/boundary/bt/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/bt/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/6x_bootscript.txt	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,9 @@
+setenv bootargs enable_wait_mode=off video=mxcfb0:dev=hdmi,1280x720M@60,if=RGB24
+setenv bootargs $bootargs video=mxcfb1:off video=mxcfb2:off video=mxcfb3:off
+setenv bootargs $bootargs fbmem=28M console=ttymxc1,115200 vmalloc=400M
+setenv bootargs $bootargs consoleblank=0 mxc_hdmi.only_cea=1
+setenv bootargs $bootargs rootwait root=/dev/mmcblk${disk}p1
+ext2load mmc ${disk}:1 0x10800000 /boot/uImage &&
+        ext2load mmc ${disk}:1 0x12800000 /boot/uramdisk.img &&
+        bootm 10800000 12800000
+echo "Error launching kernel /boot/uImage"
diff -Nru u-boot-2017.07/board/boundary/bt/bt2g.cfg u-boot-imx6/board/boundary/bt/bt2g.cfg
--- u-boot-2017.07/board/boundary/bt/bt2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/bt2g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K256M16HA-125 IT:E */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/bt/bt4g.cfg u-boot-imx6/board/boundary/bt/bt4g.cfg
--- u-boot-2017.07/board/boundary/bt/bt4g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/bt4g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03400338
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03400304
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x423A3E4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x443A3648
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383E4238
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x42364A3E
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001f0024
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00240021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00150028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x0009001c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 1
+#define BUS_WIDTH 64
+/* MT41K512M16TNA-125 IT:E */
+#include "../common/mx6/1066mhz_256mx16-hynix.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/bt/bt.c u-boot-imx6/board/boundary/bt/bt.c
--- u-boot-2017.07/board/boundary/bt/bt.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/bt.c	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,573 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CSI_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),	/* SS1 */
+
+	/* ECSPI3 - GS2971 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),	/* pin E7 - SDOUT */
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),	/* pin E8 - SDIN */
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),	/* pin F8 - SCLK */
+#define GP_ECSPI3_GS2971_CS	IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),	/* 0 - pin F7 - CS0 */
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),	/* Micrel RGMII Phy Interrupt */
+
+	/* gpios J91  */
+	/* grounds, 1,2,11,12,29,46,47,48,49,50 */
+#define GP_BT_GPIO1	IMX_GPIO_NR(2, 15)
+	IOMUX_PAD_CTRL(SD4_DAT7__GPIO2_IO15, WEAK_PULLUP),	/* bt_gpio1, pin 3 */
+#define GP_BT_GPIO2	IMX_GPIO_NR(2, 14)
+	IOMUX_PAD_CTRL(SD4_DAT6__GPIO2_IO14, WEAK_PULLUP),	/* bt_gpio2, pin 4 */
+#define GP_BT_GPIO3	IMX_GPIO_NR(2, 13)
+	IOMUX_PAD_CTRL(SD4_DAT5__GPIO2_IO13, WEAK_PULLUP),	/* bt_gpio3, pin 5 */
+#define GP_BT_GPIO4	IMX_GPIO_NR(2, 12)
+	IOMUX_PAD_CTRL(SD4_DAT4__GPIO2_IO12, WEAK_PULLUP),	/* bt_gpio4, pin 6 */
+#define GP_BT_GPIO5	IMX_GPIO_NR(2, 11)
+	IOMUX_PAD_CTRL(SD4_DAT3__GPIO2_IO11, WEAK_PULLUP),	/* bt_gpio5, pin 7 */
+#define GP_BT_GPIO6	IMX_GPIO_NR(2, 10)
+	IOMUX_PAD_CTRL(SD4_DAT2__GPIO2_IO10, WEAK_PULLUP),	/* bt_gpio6, pin 8 */
+#define GP_BT_GPIO7	IMX_GPIO_NR(2, 9)
+	IOMUX_PAD_CTRL(SD4_DAT1__GPIO2_IO09, WEAK_PULLUP),	/* bt_gpio7, pin 9 */
+#define GP_BT_GPIO8	IMX_GPIO_NR(2, 8)
+	IOMUX_PAD_CTRL(SD4_DAT0__GPIO2_IO08, WEAK_PULLUP),	/* bt_gpio8, pin 10 */
+#define GP_BT_GPIO9	IMX_GPIO_NR(7, 9)
+	IOMUX_PAD_CTRL(SD4_CMD__GPIO7_IO09, WEAK_PULLUP),	/* bt_gpio9, pin 13 */
+#define GP_BT_GPIO10	IMX_GPIO_NR(7, 10)
+	IOMUX_PAD_CTRL(SD4_CLK__GPIO7_IO10, WEAK_PULLUP),	/* bt_gpio10, pin 14 */
+#define GP_BT_GPIO11	IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),	/* bt_gpio11, pin 15 */
+#define GP_BT_GPIO12	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),	/* bt_gpio12, pin 16 */
+#define GP_BT_GPIO13	IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP),	/* bt_gpio13, pin 17 */
+#define GP_BT_GPIO14	IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLUP),	/* bt_gpio14, pin 18 */
+#define GP_BT_GPIO15	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),	/* bt_gpio15, pin 19 */
+#define GP_BT_GPIO16	IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),	/* bt_gpio16, pin 20 */
+#define GP_BT_GPIO17	IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),	/* bt_gpio17, pin 21 */
+#define GP_BT_GPIO18	IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),	/* bt_gpio18, pin 22 */
+#define GP_BT_GPIO19	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),	/* bt_gpio19, pin 23 */
+#define GP_BT_GPIO20	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),	/* bt_gpio20, pin 24 */
+#define GP_BT_GPIO21	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),	/* bt_gpio21, pin 25 */
+#define GP_BT_GPIO22	IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLUP),	/* bt_gpio22, pin 26 */
+#define GP_BT_GPIO23	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLUP),	/* bt_gpio23, pin 27 */
+#define GP_BT_GPIO24	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLUP),	/* bt_gpio24, pin 28 */
+#define GP_BT_GPIO25	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLUP),	/* bt_gpio25, pin 30 */
+#define GP_BT_GPIO26	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLUP),	/* bt_gpio26, pin 31 */
+#define GP_BT_GPIO27	IMX_GPIO_NR(5, 30)
+	IOMUX_PAD_CTRL(CSI0_DAT12__GPIO5_IO30, WEAK_PULLUP),	/* bt_gpio27, pin 32 */
+#define GP_BT_GPIO28	IMX_GPIO_NR(5, 31)
+	IOMUX_PAD_CTRL(CSI0_DAT13__GPIO5_IO31, WEAK_PULLUP),	/* bt_gpio28, pin 33 */
+#define GP_BT_GPIO29	IMX_GPIO_NR(5, 24)
+	IOMUX_PAD_CTRL(CSI0_DAT6__GPIO5_IO24, WEAK_PULLUP),	/* bt_gpio29, pin 34 */
+#define GP_BT_GPIO30	IMX_GPIO_NR(5, 25)
+	IOMUX_PAD_CTRL(CSI0_DAT7__GPIO5_IO25, WEAK_PULLUP),	/* bt_gpio30, pin 35 */
+#define GP_BT_GPIO31	IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLUP),	/* bt_gpio31, pin 36 */
+#define GP_BT_GPIO32	IMX_GPIO_NR(6, 3)
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLUP),	/* bt_gpio32, pin 37 */
+#define GP_BT_GPIO33	IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLUP),	/* bt_gpio33, pin 38 */
+#define GP_BT_GPIO34	IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLUP),	/* bt_gpio34, pin 39 */
+#define GP_BT_GPIO35	IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLUP),	/* bt_gpio35, pin 40 */
+#define GP_BT_GPIO36	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),	/* bt_gpio36, pin 41 */
+#define GP_BT_GPIO37	IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),	/* bt_gpio37, pin 42 */
+#define GP_BT_GPIO38	IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),	/* bt_gpio38, pin 43 */
+#define GP_BT_GPIO39	IMX_GPIO_NR(5, 26)
+	IOMUX_PAD_CTRL(CSI0_DAT8__GPIO5_IO26, WEAK_PULLUP),	/* bt_gpio39, pin 44 */
+#define GP_BT_GPIO40	IMX_GPIO_NR(5, 27)
+	IOMUX_PAD_CTRL(CSI0_DAT9__GPIO5_IO27, WEAK_PULLUP),	/* bt_gpio40, pin 45 */
+
+	/* Power control, high is off */
+	/* Pull-up so that reset will leave high */
+#define GP_PWR_J1	IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),	/* J1 Power enable */
+#define GP_PWR_J2	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),	/* J2 */
+#define GP_PWR_J3	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),	/* J3 */
+#define GP_PWR_J4	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),	/* J4 */
+#define GP_PWR_J5V	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),	/* J7 */
+#define GP_PWR_J12V	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),	/* J6 */
+
+	/* Dry Contact */
+	/* J92 pins */
+#define GP_J92_PIN7	IMX_GPIO_NR(3, 31)
+	IOMUX_PAD_CTRL(EIM_D31__GPIO3_IO31, WEAK_PULLUP),	/* OUT_1 - Dry contact to J92 pin 7 */
+#define GP_J92_PIN9	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),	/* OUT_2 - Dry contact to J92 pin 9 */
+#define GP_J92_PIN10	IMX_GPIO_NR(5, 22)
+	IOMUX_PAD_CTRL(CSI0_DAT4__GPIO5_IO22, WEAK_PULLUP),	/* GPI_1 - J92 - pin 10 */
+#define GP_J92_PIN12	IMX_GPIO_NR(5, 23)
+	IOMUX_PAD_CTRL(CSI0_DAT5__GPIO5_IO23, WEAK_PULLUP),	/* GPI_2 - J92 - pin 12 */
+
+	/* Test points */
+#define GP_TP81		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+
+	/*
+	 * PCIe - tw6869 dedicated,
+	 * VIN1-4 used,
+	 * AIN1-2 amplified, AIN3-4 not amplified
+	 */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, OUTPUT_40OHM),
+
+	/* i2c1 rtc rv4162 */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+
+	/* I2C3_Adv7391 */
+#define GP_ADV7391_RESET	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),		/* Adv7391 reset */
+
+	/* SDI - gs2971 on CSI1 */
+#if defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
+	/* Dualite/Solo doesn't have IPU2 */
+	IOMUX_PAD_CTRL(EIM_A24__IPU1_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU1_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU1_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU1_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU1_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU1_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU1_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU1_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU1_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU1_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU1_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU1_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU1_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU1_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU1_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU1_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU1_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU1_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU1_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA9__IPU1_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU1_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] */
+#else
+	IOMUX_PAD_CTRL(EIM_A24__IPU2_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU2_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU2_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU2_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU2_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU2_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU2_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU2_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU2_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU2_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU2_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU2_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU2_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU2_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU2_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU2_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU2_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU2_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU2_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA9__IPU2_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU2_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] - pin A8 */
+#endif
+
+	/* Not used, but MUST be in GPIO mode */
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),	/* IPU2_CSI1_DATA_EN not used (pin B5 stat2) */
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),	/* HSYNC - pin A5 stat0 */
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),	/* VSYNC - pin A6 stat1 */
+
+#define GP_GS2971_SMPTE_BYPASS	IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),	/* pin G7 - i/o SMPTE bypass */
+#define GP_GS2971_RESET		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, OUTPUT_40OHM),	/* 0 - pin C7 - reset */
+#define GP_GS2971_DVI_LOCK	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),	/* pin B6 - stat3 - DVI_LOCK */
+#define GP_GS2971_DATA_ERR	IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),	/* pin C6 - stat5 - DATA error */
+#define GP_GS2971_LB_CONT	IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* pin A3 - LB control - float, analog input */
+#define GP_GS2971_Y_1ANC	IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),	/* pin C5 - stat4 - 1ANC - Y signal detect */
+#define GP_GS2971_RC_BYPASS	IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, OUTPUT_40OHM),	/* 0 - pin G3 - RC bypass - output is buffered(low) */
+#define GP_GS2971_IOPROC_EN	IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, OUTPUT_40OHM),	/* 0 - pin H8 - io(A/V) processor enable */
+#define GP_GS2971_AUDIO_EN	IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, OUTPUT_40OHM),	/* 0 - pin H3 - Audio Enable */
+#define GP_GS2971_TIM_861	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, OUTPUT_40OHM),	/* 0 - pin H5 - TIM861 timing format, 0-use HSYNC/VSYNC */
+#define GP_GS2971_SW_EN		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, OUTPUT_40OHM),	/* 0 - pin D7 - SW_EN - line lock enable */
+#define GP_GS2971_STANDBY	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, OUTPUT_40OHM),	/* 1 - pin K2 - Standby */
+#define GP_GS2971_DVB_ASI	IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),	/* pin G8 i/o DVB_ASI */
+
+	IOMUX_PAD_CTRL(KEY_ROW1__AUD5_RXD, AUD_PAD_CTRL),	/* pin J3 - AOUT1/2 */
+	IOMUX_PAD_CTRL(DISP0_DAT14__AUD5_RXC, AUD_PAD_CTRL),	/* pin J4 - ACLK*/
+	IOMUX_PAD_CTRL(DISP0_DAT13__AUD5_RXFS, AUD_PAD_CTRL),	/* pin H4 - WCLK*/
+
+	/* UART1  */
+	IOMUX_PAD_CTRL(CSI0_DAT10__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT11__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 for debug */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* UART6/7 on sc16is752 on i2c2 */
+#define GP_SC16IS752_IRQ		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),	/* irq */
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, OUTPUT_40OHM),	/* USB Hub Reset for USB2512 4 port hub */
+	/*
+	 * port1 - 10/100 ethernet using AX88772A on J90
+	 * port2 - usb connector on J26
+	 * port3 - usb connector on J25
+	 * port4 - usb connector on J96
+	 */
+#define GP_AX88772A_RESET	IMX_GPIO_NR(5, 20)
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, OUTPUT_40OHM),
+
+	/* USBOTG - J80 */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, OUTPUT_40OHM),
+
+	/* USDHC1: Full size SD card holder - J88 */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT0__SD1_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT1__SD1_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT2__SD1_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT3__SD1_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC1_CD		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_USDHC1_WP		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+	/* Needs to invert and use key_col1 */
+#define GP_USDHC1_POWER_SEL	IMX_GPIO_NR(7, 13)		/* low 1.8V, high 3.3V */
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, OUTPUT_40OHM),
+
+	/* USDHC2:  micro sd - J87 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC2_CD		IMX_GPIO_NR(3, 23)
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+
+	/* USDHC3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, OUTPUT_40OHM),	/* eMMC reset */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	/* Reset USB hub */
+	if (port) {
+		gpio_set_value(GP_USB_HUB_RESET, 0);
+		gpio_set_value(GP_AX88772A_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+		gpio_set_value(GP_AX88772A_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC1_CD},
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC2_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_AX88772A_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_PCIE_RESET,
+	GP_GS2971_RESET,
+	GP_GS2971_RC_BYPASS,
+	GP_GS2971_IOPROC_EN,
+	GP_GS2971_AUDIO_EN,
+	GP_GS2971_TIM_861,
+	GP_GS2971_SW_EN,
+	GP_GS2971_DVB_ASI,
+	GP_ADV7391_RESET,
+	GP_J92_PIN9,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_PWR_J1,
+	GP_PWR_J2,
+	GP_PWR_J3,
+	GP_PWR_J4,
+	GP_PWR_J5V,
+	GP_PWR_J12V,
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI3_GS2971_CS,
+	GP_USDHC1_POWER_SEL,	/* high=3.3v */
+	GP_GS2971_STANDBY,
+	GP_J92_PIN7,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_USDHC1_CD,
+	GP_USDHC2_CD,
+	GP_GS2971_SMPTE_BYPASS,
+	GP_GS2971_DVI_LOCK,
+	GP_GS2971_DATA_ERR,
+	GP_GS2971_LB_CONT,
+	GP_GS2971_Y_1ANC,
+	GP_J92_PIN10,
+	GP_J92_PIN12,
+	GP_BT_GPIO1,
+	GP_BT_GPIO2,
+	GP_BT_GPIO3,
+	GP_BT_GPIO4,
+	GP_BT_GPIO5,
+	GP_BT_GPIO6,
+	GP_BT_GPIO7,
+	GP_BT_GPIO8,
+	GP_BT_GPIO9,
+	GP_BT_GPIO10,
+	GP_BT_GPIO11,
+	GP_BT_GPIO12,
+	GP_BT_GPIO13,
+	GP_BT_GPIO14,
+	GP_BT_GPIO15,
+	GP_BT_GPIO16,
+	GP_BT_GPIO17,
+	GP_BT_GPIO18,
+	GP_BT_GPIO19,
+	GP_BT_GPIO20,
+	GP_BT_GPIO21,
+	GP_BT_GPIO22,
+	GP_BT_GPIO23,
+	GP_BT_GPIO24,
+	GP_BT_GPIO25,
+	GP_BT_GPIO26,
+	GP_BT_GPIO27,
+	GP_BT_GPIO28,
+	GP_BT_GPIO29,
+	GP_BT_GPIO30,
+	GP_BT_GPIO31,
+	GP_BT_GPIO32,
+	GP_BT_GPIO33,
+	GP_BT_GPIO34,
+	GP_BT_GPIO35,
+	GP_BT_GPIO36,
+	GP_BT_GPIO37,
+	GP_BT_GPIO38,
+	GP_BT_GPIO39,
+	GP_BT_GPIO40,
+	GP_TP81,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp81",	GP_TP81,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/bt/Kconfig u-boot-imx6/board/boundary/bt/Kconfig
--- u-boot-2017.07/board/boundary/bt/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/Kconfig	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,20 @@
+if TARGET_BT
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "bt"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "bt"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/bt/MAINTAINERS u-boot-imx6/board/boundary/bt/MAINTAINERS
--- u-boot-2017.07/board/boundary/bt/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/MAINTAINERS	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,8 @@
+BT BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/bt/
+F:	include/configs/bt.h
+F:	configs/bt2g_defconfig
+F:	configs/bt4g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/bt/Makefile u-boot-imx6/board/boundary/bt/Makefile
--- u-boot-2017.07/board/boundary/bt/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/Makefile	2018-08-27 21:35:36.937471730 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := bt.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff -Nru u-boot-2017.07/board/boundary/bt/spl.c u-boot-imx6/board/boundary/bt/spl.c
--- u-boot-2017.07/board/boundary/bt/spl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt/spl.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/mx6-ddr.h>
+#include <asm/imx-common/boot_mode.h>
+
+#include <i2c.h>
+#include <spl.h>
+
+#if 0
+void board_init_f(ulong dummy)
+{
+#if 0
+	arch_cpu_init();
+	board_early_init_f();
+	timer_init();
+	preloader_console_init();
+
+	print_cpuinfo();
+	board_init_r(NULL, 0);
+#endif
+}
+#endif
+
+void spl_board_init(void)
+{
+#if 0
+	int i;
+	u32 const *regs ;
+	int num_regs;
+	unsigned char mac_address[6];
+        imx_get_mac_from_fuse(0,mac_address);
+	printf("ethaddr: %pM\n", mac_address);
+
+	if (is_cpu_type(MXC_CPU_MX6Q)) {
+#if 1
+		regs = mx6q_1g;
+		num_regs = ARRAY_SIZE(mx6q_1g);
+#else
+		regs = mx6q_2g;
+		num_regs = ARRAY_SIZE(mx6q_2g);
+#endif
+	} else {
+#if CONFIG_DDR_MB == 512
+		regs = mx6dl_512m;
+		num_regs = ARRAY_SIZE(mx6dl_512m);
+printf("Configuring for 512MiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 1024
+		regs = mx6dl_1gn;
+		num_regs = ARRAY_SIZE(mx6dl_1gn);
+printf("Configuring for 1GiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 2048
+		regs = mx6dl_2g;
+		num_regs = ARRAY_SIZE(mx6dl_2g);
+printf("Configuring for 2GiB wide memory bus\n");
+#endif
+	}
+	for (i=0; i < num_regs; i+=2) {
+		writel(regs[i+1],regs[i]);
+	}
+        dram_init();
+#endif
+	printf("%s\n", __func__);
+}
+
+u32 spl_boot_device(void)
+{
+	printf("%s\n", __func__);
+#if 0
+	unsigned reg;
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	printf("%s: sbmr1 == 0x%08x\n", __func__, psrc->sbmr1);
+	printf("%s: gpr9  == 0x%08x\n", __func__, psrc->gpr9);
+	printf("%s: gpr10 == 0x%08x\n", __func__, psrc->gpr10);
+	return BOOT_DEVICE_USB;
+#endif
+#if 1
+	return BOOT_DEVICE_SPI;
+#endif
+}
+
+#if 0
+void spl_usb_load_image(void)
+{
+	boot_mode_apply(MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00));
+	reset_cpu(0);
+}
+
+#endif
diff -Nru u-boot-2017.07/board/boundary/bt2/6x_bootscript.txt u-boot-imx6/board/boundary/bt2/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/bt2/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/6x_bootscript.txt	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,9 @@
+setenv bootargs enable_wait_mode=off video=mxcfb0:dev=hdmi,1280x720M@60,if=RGB24
+setenv bootargs $bootargs video=mxcfb1:off video=mxcfb2:off video=mxcfb3:off
+setenv bootargs $bootargs fbmem=28M console=ttymxc1,115200 vmalloc=400M
+setenv bootargs $bootargs consoleblank=0 mxc_hdmi.only_cea=1
+setenv bootargs $bootargs rootwait root=/dev/mmcblk${disk}p1
+ext2load mmc ${disk}:1 0x10800000 /boot/uImage &&
+        ext2load mmc ${disk}:1 0x12800000 /boot/uramdisk.img &&
+        bootm 10800000 12800000
+echo "Error launching kernel /boot/uImage"
diff -Nru u-boot-2017.07/board/boundary/bt2/bt2.c u-boot-imx6/board/boundary/bt2/bt2.c
--- u-boot-2017.07/board/boundary/bt2/bt2.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/bt2.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,555 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define CSI_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define OUTPUT_40OHM_PULLDN	(PAD_CTL_PUS_100K_DOWN |	\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_SLOW)
+
+#define OUTPUT_40OHM_PULLUP	(PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_SLOW)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC1_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC2_PAD_CTRL	USDHC1_PAD_CTRL
+
+#define USDHC3_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC4_PAD_CTRL	USDHC3_PAD_CTRL
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Aud5 - GS2971 audio input */
+	IOMUX_PAD_CTRL(KEY_ROW1__AUD5_RXD, AUD_PAD_CTRL),	/* pin J3 - AOUT1/2 */
+	IOMUX_PAD_CTRL(DISP0_DAT14__AUD5_RXC, AUD_PAD_CTRL),	/* pin J4 - ACLK*/
+	IOMUX_PAD_CTRL(DISP0_DAT13__AUD5_RXFS, AUD_PAD_CTRL),	/* pin H4 - WCLK*/
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),	/* SS1 */
+
+	/* ECSPI3 - GS2971 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),	/* pin E7 - SDOUT */
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),	/* pin E8 - SDIN */
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),	/* pin F8 - SCLK */
+#define GP_ECSPI3_GS2971_CS	IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),	/* 0 - pin F7 - CS0 */
+
+	/* ecspi3 - gs2971, SDI on CSI1 */
+#if defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
+	/* Dualite/Solo doesn't have IPU2 */
+	IOMUX_PAD_CTRL(EIM_DA9__IPU1_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU1_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU1_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU1_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU1_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU1_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU1_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU1_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU1_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU1_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU1_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU1_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU1_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU1_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU1_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU1_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU1_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU1_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU1_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A24__IPU1_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU1_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] */
+#else
+	IOMUX_PAD_CTRL(EIM_DA9__IPU2_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU2_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU2_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU2_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU2_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU2_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU2_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU2_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU2_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU2_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU2_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU2_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU2_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU2_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU2_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU2_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU2_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU2_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU2_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A24__IPU2_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU2_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] - pin A8 */
+#endif
+
+	/* Not used, but MUST be in GPIO mode */
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),	/* IPU2_CSI1_DATA_EN not used (pin B5 stat2) */
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),	/* HSYNC - pin A5 stat0 */
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),	/* VSYNC - pin A6 stat1 */
+
+#define GP_GS2971_STANDBY	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, OUTPUT_40OHM_PULLUP), /* 1 - pin K2 - Standby */
+#define GP_GS2971_RESET		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, OUTPUT_40OHM_PULLDN), /* 0 - pin C7 - reset */
+#define GP_GS2971_RC_BYPASS	IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, OUTPUT_40OHM),	/* 0 - pin G3 - RC bypass - output is buffered(low) */
+#define GP_GS2971_IOPROC_EN	IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, OUTPUT_40OHM),	/* 0 - pin H8 - io(A/V) processor enable */
+#define GP_GS2971_AUDIO_EN	IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, OUTPUT_40OHM),	/* 0 - pin H3 - Audio Enable */
+#define GP_GS2971_TIM_861	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, OUTPUT_40OHM),	/* 0 - pin H5 - TIM861 timing format, 0-use HSYNC/VSYNC */
+#define GP_GS2971_SW_EN		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, OUTPUT_40OHM),	/* 0 - pin D7 - SW_EN - line lock enable */
+#define GP_GS2971_DVB_ASI	IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),	/* pin G8 i/o DVB_ASI */
+#define GP_GS2971_SMPTE_BYPASS	IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),	/* pin G7 - i/o SMPTE bypass */
+#define GP_GS2971_DVI_LOCK	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),	/* pin B6 - stat3 - DVI_LOCK */
+#define GP_GS2971_DATA_ERR	IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),	/* pin C6 - stat5 - DATA error */
+#define GP_GS2971_LB_CONT	IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* pin A3 - LB control - float, analog input */
+#define GP_GS2971_Y_1ANC	IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),	/* pin C5 - stat4 - 1ANC - Y signal detect */
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),	/* Micrel RGMII Phy Interrupt */
+
+	/* Hogs - Power control, high is off */
+	/* Pull-up so that reset will leave high */
+#define GP_PWR_J1	IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+#define GP_PWR_J2	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_PWR_J3	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+#define GP_PWR_J4	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+#define GP_PWR_J5V	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),	/* J6 new, J7 old board */
+#define GP_PWR_J12V	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),	/* J7 new, J6 old board */
+
+	/* Hogs - TW6869 mic bias */
+#define GP_TW6869_MIC_BIAS_EN	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, OUTPUT_40OHM_PULLDN),
+
+	/* Hogs - Dry Contact */
+	/* J92 pins */
+#define GP_J92_PIN7	IMX_GPIO_NR(3, 31)
+	IOMUX_PAD_CTRL(EIM_D31__GPIO3_IO31, WEAK_PULLUP),	/* OUT_1 - Dry contact to J92 pin 7 */
+#define GP_J92_PIN9	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),	/* OUT_2 - Dry contact to J92 pin 9 */
+#define GP_J92_PIN10	IMX_GPIO_NR(5, 22)
+	IOMUX_PAD_CTRL(CSI0_DAT4__GPIO5_IO22, WEAK_PULLUP),	/* GPI_1 - J92 - pin 10 */
+#define GP_J92_PIN12	IMX_GPIO_NR(5, 23)
+	IOMUX_PAD_CTRL(CSI0_DAT5__GPIO5_IO23, WEAK_PULLUP),	/* GPI_2 - J92 - pin 12 */
+
+	/* Hogs - Test point */
+#define GP_TP77			IMX_GPIO_NR(5, 6)
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+#define GP_TP81			IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+#define GP_TP82			IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, OUTPUT_40OHM),
+
+	/* i2c1 rtc rv4162 */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+
+	/* I2C3_Adv7391 */
+#define GP_ADV7391_RESET	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, OUTPUT_40OHM_PULLDN),	/* Adv7391 reset */
+
+	/* i2c3 max-7w - GPS */
+	IOMUX_PAD_CTRL(CSI0_DAT12__GPIO5_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT13__GPIO5_IO31, WEAK_PULLUP),
+#define GP_GPS_HEART_BEAT	IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GPIRQ_GPS		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+#define GP_GPS_RESET		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLDN),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/*
+	 * PCIe - tw6869 dedicated,
+	 * VIN1-4 used,
+	 * AIN1-2 amplified, AIN3-4 not amplified
+	 */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, OUTPUT_40OHM),
+
+	/* regulator usgotg */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, OUTPUT_40OHM_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM_PULLDN),
+
+	/* UART1 - J1 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT11__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 for debug */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 - J2 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+
+	/* UART4 - J3 */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 - J4 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, OUTPUT_40OHM),	/* USB Hub Reset for USB2512 4 port hub */
+	/*
+	 * port1 - 10/100 ethernet using XR22800 on J90
+	 * port2 - usb connector on J26
+	 * port3 - usb connector on J25
+	 * port4 - usb connector on J96
+	 */
+
+	/* USBOTG - J80 */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC1: Full size SD card holder - J88 */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT0__SD1_DATA0, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT1__SD1_DATA1, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT2__SD1_DATA2, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT3__SD1_DATA3, USDHC1_PAD_CTRL),
+#define GP_USDHC1_CD		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_USDHC1_WP		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+	/* USDHC2:  Full size sd - J87 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC2_PAD_CTRL),
+#define GP_USDHC2_CD		IMX_GPIO_NR(3, 23)
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+#define GP_USDHC2_WP		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+
+	/* USDHC3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC3_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, OUTPUT_40OHM),	/* eMMC reset */
+
+	/* USDHC4 - Broadcom GB863021 */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+
+#define GPIRQ_WL	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+/* Adv7391 uses DSIP0_DAT16-23 */
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	/* Reset USB hub */
+	if (port) {
+		gpio_set_value(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC1_CD},
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC2_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_GS2971_RESET,
+	GP_GS2971_RC_BYPASS,
+	GP_GS2971_IOPROC_EN,
+	GP_GS2971_AUDIO_EN,
+	GP_GS2971_TIM_861,
+	GP_GS2971_SW_EN,
+	GP_GS2971_DVB_ASI,
+	GP_RGMII_PHY_RESET,
+	GP_TW6869_MIC_BIAS_EN,
+	GP_J92_PIN9,
+	GP_ADV7391_RESET,
+	GP_PCIE_RESET,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,
+	GP_GPS_RESET,
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI3_GS2971_CS,
+	GP_GS2971_STANDBY,
+	GP_PWR_J1,
+	GP_PWR_J2,
+	GP_PWR_J3,
+	GP_PWR_J4,
+	GP_PWR_J5V,
+	GP_PWR_J12V,
+	GP_J92_PIN7,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GS2971_SMPTE_BYPASS,
+	GP_GS2971_DVI_LOCK,
+	GP_GS2971_DATA_ERR,
+	GP_GS2971_LB_CONT,
+	GP_GS2971_Y_1ANC,
+	GPIRQ_ENET_PHY,
+	GP_J92_PIN10,
+	GP_J92_PIN12,
+	GP_TP77,
+	GP_TP81,
+	GP_TP82,
+	GPIRQ_RTC_RV4162,
+	GP_GPS_HEART_BEAT,
+	GPIRQ_GPS,
+	GP_USDHC1_CD,
+	GP_USDHC1_WP,
+	GP_USDHC2_CD,
+	GP_USDHC2_WP,
+	GPIRQ_WL,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp81",	GP_TP81,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/bt2/bt2g.cfg u-boot-imx6/board/boundary/bt2/bt2g.cfg
--- u-boot-2017.07/board/boundary/bt2/bt2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/bt2g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K256M16HA-125 IT:E */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/bt2/bt4g.cfg u-boot-imx6/board/boundary/bt2/bt4g.cfg
--- u-boot-2017.07/board/boundary/bt2/bt4g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/bt4g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03400338
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03400304
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x423A3E4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x443A3648
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383E4238
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x42364A3E
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001f0024
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00240021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00150028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x0009001c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K512M16HA-107 IT:A */
+#include "../common/mx6/1066mhz_512mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/bt2/Kconfig u-boot-imx6/board/boundary/bt2/Kconfig
--- u-boot-2017.07/board/boundary/bt2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,24 @@
+if TARGET_BT2
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "bt2"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "bt"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/bt2/MAINTAINERS u-boot-imx6/board/boundary/bt2/MAINTAINERS
--- u-boot-2017.07/board/boundary/bt2/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,8 @@
+BT BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/bt2/
+F:	include/configs/bt.h
+F:	configs/bt2_2g_defconfig
+F:	configs/bt2_4g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/bt2/Makefile u-boot-imx6/board/boundary/bt2/Makefile
--- u-boot-2017.07/board/boundary/bt2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/bt2/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := bt2.o
diff -Nru u-boot-2017.07/board/boundary/cad/cad.c u-boot-imx6/board/boundary/cad/cad.c
--- u-boot-2017.07/board/boundary/cad/cad.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/cad.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <spi.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "spi_display.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#if 0
+/* RH320240T-3X5WP-A2, Display Mode Setting */
+#define SPI_MOSI_PAD_CTRL  (SPI_PAD_CTRL | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE)
+#else
+/* RH320240T-3X5AP-A, Display Mode Setting */
+#define SPI_MOSI_PAD_CTRL  (SPI_PAD_CTRL | PAD_CTL_PUS_22K_UP)
+#endif
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC4_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),	    /* P5:pin 10, P6:pin 49 */
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_MOSI_PAD_CTRL),  /* P5:pin 12, P6:pin 50 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_MOSI_PAD_CTRL), /* P5:pin 11, P6:pin 50 */
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),	    /* P5:pin  9, P6:pin 43 */
+#define GP_LCD_DISABLE		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLUP),	    /* P5:pin 42, P6:pin 48 (SHUT) */
+#define GP_TOUCH_IRQ	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+#define POWERDOWN_REPLY		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, OUTPUT_40OHM),	/* powerdown_reply - output to latch power */
+#define POWERLOW		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),	/* powerlow - input reflecting power state */
+#define POWERDOWN_NOTICE	IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO_6__GPIO1_IO06, WEAK_PULLUP),	/* powerdown_notice - input reflecting button press */
+#define BUZZER			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),	/* buzzer */
+#define IR_STATUS		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),	/* IR status */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)		/* PWM1 */
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USDHC2 - emmc */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, NO_PAD_CTRL),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+//	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+//	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, Touch screen, ADV7997 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS :  (cs >> 8) ? (cs >> 8) : -1;
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+		if (di->fbflags & FBF_SPI) {
+			unsigned cs_gpio = GP_ECSPI2_CS;
+			unsigned disable_gpio = GP_LCD_DISABLE;
+
+			debug("%s\n", __func__);
+			gpio_direction_output(cs_gpio, 1);
+			gpio_direction_output(disable_gpio, 1);
+			udelay(200);
+			gpio_direction_output(disable_gpio, 0);
+			mdelay(200);
+			enable_spi_rgb(di);
+		}
+	} else {
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VDF_SPI_QVGA(LCD, "qvga", RGB24, FBF_MODESTR | FBF_SPI, NULL, 1, 0x70)
+};
+#define display_cnt	ARRAY_SIZE(displays)
+
+static const unsigned short gpios_out_low[] = {
+	GP_BACKLIGHT_RGB,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	POWERDOWN_REPLY,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_USDHC3_CD,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	gpio_set_value(GP_BACKLIGHT_RGB, 0);
+	gpio_set_value(POWERDOWN_REPLY, 0);
+	mdelay(500);
+	return 1;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/cad/cad.cfg u-boot-imx6/board/boundary/cad/cad.cfg
--- u-boot-2017.07/board/boundary/cad/cad.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/cad.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* BOM removed, not supported */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cad/Kconfig u-boot-imx6/board/boundary/cad/Kconfig
--- u-boot-2017.07/board/boundary/cad/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,20 @@
+if TARGET_CAD
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "cad"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cad"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cad/MAINTAINERS u-boot-imx6/board/boundary/cad/MAINTAINERS
--- u-boot-2017.07/board/boundary/cad/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,6 @@
+CAD BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cad/
+F:	include/configs/cad.h
+F:	configs/cad_defconfig
diff -Nru u-boot-2017.07/board/boundary/cad/Makefile u-boot-imx6/board/boundary/cad/Makefile
--- u-boot-2017.07/board/boundary/cad/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cad.o
+obj-$(CONFIG_MXC_SPI_DISPLAY) += spi_display.o
\      
diff -Nru u-boot-2017.07/board/boundary/cad/spi_display.c u-boot-imx6/board/boundary/cad/spi_display.c
--- u-boot-2017.07/board/boundary/cad/spi_display.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/spi_display.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,269 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/video.h>
+#include <spi.h>
+#include "spi_display.h"
+
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+#define SPI_FREQ	1000000
+
+static int spi_display_cmds(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+		uint val;
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = 0x70;
+			buf[1] = reg >> 8;
+			buf[2] = reg;
+			ret = spi_xfer(spi, 3 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			if (!len) {
+				debug("spi: reg:%04x\n", reg);
+				break;
+			}
+			val = (cmds[0] << 8) | cmds[1];
+			cmds += 2;
+			buf[0] = 0x72;
+			buf[1] = val >> 8;
+			buf[2] = val;
+			ret = spi_xfer(spi, 3 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to write val 0x%x=0x%x, %d\n", __func__, reg, val, ret);
+				return ret;
+			}
+			debug("spi: reg:%04x=%04x\n", reg, val);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+int spi_read_register(struct spi_slave *spi, int reg)
+{
+	int val;
+	int ret;
+	u8 buf[4];
+	u8 rx_buf[4];
+
+	buf[0] = 0x70;
+	buf[1] = reg >> 8;
+	buf[2] = reg;
+	ret = spi_xfer(spi, 3 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0x73;
+	buf[1] = 0xff;
+	buf[2] = 0xff;
+	rx_buf[0] = 0xff;
+	rx_buf[1] = 0xff;
+	rx_buf[2] = 0xff;
+	ret = spi_xfer(spi, 3 * 8, buf, rx_buf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to read val from reg 0x%x %d\n", __func__, reg, ret);
+		return ret;
+	}
+	val = (rx_buf[1] << 8) | rx_buf[2];
+	debug("spi: (0x%02x)reg:%04x=%04x\n", rx_buf[0], reg, val);
+	return val;
+}
+
+#define A(reg, cnt) (reg >> 8), (reg & 0xff), cnt
+#define VAL(val) (val >> 8), (val & 0xff)
+
+static u8 display_init_cmds[] = {
+/* RH320240T-3X5WP-A2, Display Mode Setting */
+#if 1
+	A(0x0001, 5), VAL(0x7300), VAL(0x0200), VAL(0x6164), VAL(0x04c7), VAL(0xfc80),
+	A(0x000a, 1), VAL(0x4008),
+	A(0x000d, 2), VAL(0x3229), VAL(0x3200),
+#else
+//defaults
+//	A(0x0001, 5), VAL(0x7300), VAL(0x0200), VAL(0x6464), VAL(0x0447), VAL(0xb4c4),
+//	A(0x000a, 1), VAL(0x4008),
+//	A(0x000d, 2), VAL(0x3229), VAL(0x1200),
+#endif
+	A(0, 0)
+};
+
+void enable_spi_rgb(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret;
+
+	gpio_direction_output(cs_gpio, 1);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, cs_gpio << 8, SPI_FREQ, SPI_MODE_3);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	ret = spi_display_cmds(spi, display_init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return;
+}
+
+static int do_spid(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret = 0;
+	int arg = 2;
+	int bus = 1;
+	int index = 3;
+	uint reg;
+	u8 buf[80];
+
+	if (argc < 2)
+		return 1;
+	gpio_direction_output(cs_gpio, 1);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, cs_gpio << 8, SPI_FREQ, SPI_MODE_3);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto exit1;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	buf[0] = reg >> 8;
+	buf[1] = reg;
+	buf[2] = argc - arg;
+	while (arg < argc) {
+		int val = simple_strtoul(argv[arg], NULL, 16);;
+		buf[index++] = val >> 8;
+		buf[index++] = val;
+		if (index >= ARRAY_SIZE(buf) - 4)
+			break;
+		arg++;
+	}
+	buf[index++] = 0;
+	buf[index++] = 0;
+	buf[index++] = 0;
+	spi_display_cmds(spi, buf);
+	spi_release_bus(spi);
+exit1:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spid, 70, 0, do_spid,
+	"write cmd, data to spi display",
+	"reg16 [word]"
+);
+
+static int do_spidr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret = 0;
+	int bus = 1;
+	uint reg;
+	int val;
+
+	if (argc != 2)
+		return 1;
+
+	gpio_direction_output(cs_gpio, 1);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, cs_gpio << 8, SPI_FREQ, SPI_MODE_3);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto exit1;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	val = spi_read_register(spi, reg);
+	printf("reg %04x=0x%04x\n", reg, val);
+	spi_release_bus(spi);
+exit1:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spidr, 70, 0, do_spidr,
+	"read data from spi display",
+	"reg16"
+);
diff -Nru u-boot-2017.07/board/boundary/cad/spi_display.h u-boot-imx6/board/boundary/cad/spi_display.h
--- u-boot-2017.07/board/boundary/cad/spi_display.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cad/spi_display.h	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,2 @@
+int detect_spi(struct display_info_t const *dev);
+void enable_spi_rgb(struct display_info_t const *dev);
diff -Nru u-boot-2017.07/board/boundary/cid/cid.c u-boot-imx6/board/boundary/cid/cid.c
--- u-boot-2017.07/board/boundary/cid/cid.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid/cid.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,649 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Audmux 3 */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* Audmux 4 */
+	IOMUX_PAD_CTRL(DISP0_DAT20__AUD4_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__AUD4_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__AUD4_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__AUD4_RXD, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),
+
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+	/* Rev 3 */
+#define GP_GPIOKEY_RESET	IMX_GPIO_NR(6, 18)
+	IOMUX_PAD_CTRL(SD3_DAT6__GPIO6_IO18, WEAK_PULLUP),
+	/* Rev 1, not on Rev 0*/
+	/* Goes low when USB_OTG_VBUS goes high */
+#define GP_GPIOKEY_VBUS_STATUS	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+
+	/* GPS */
+#define GP_GPS_HEARTBEAT	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+#define GP_GPS_INT		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_GPS_RESET		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+	/* Modem pins */
+#define GP_SLEEP_STAT		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+#define GP_MODEM_RESET		IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+
+#ifdef CONFIG_REV_OLD
+	/* Polarity has changed between revs */
+#define LED_ACTIVE_BLUE		0
+#define LED_ACTIVE_GREEN	0
+#define LED_ACTIVE_RED		0
+#define PULL_BLUE		WEAK_PULLUP
+#define PULL_GREEN		WEAK_PULLUP
+#define PULL_RED		WEAK_PULLUP
+#else
+#define LED_ACTIVE_BLUE		1		/* Blue - high active */
+#ifdef CONFIG_GREEN_HIGH
+#define LED_ACTIVE_GREEN	1		/* Green - cid, high active */
+#else
+#define LED_ACTIVE_GREEN	0		/* Green - cid2, low active */
+#endif
+#define LED_ACTIVE_RED		1		/* Red - high active */
+#define PULL_BLUE		WEAK_PULLDN
+#define PULL_GREEN		WEAK_PULLUP
+#define PULL_RED		WEAK_PULLDN
+#endif
+
+#define GP_LED_BLUE		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, PULL_BLUE),
+	/* Green led on means USB powered, not charging */
+#define GP_LED_GREEN		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, PULL_GREEN),
+#define GP_LED_CTRL_GREEN	IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, OUTPUT_40OHM),
+	/* Red led on means USB powered, charging */
+#define GP_LED_RED		IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, PULL_RED),
+#define GP_LED_CTRL_RED		IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, OUTPUT_40OHM),
+#define GP_MODEM_ON_OFF		IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	/* SIM */
+#define GP_SIM_DETECT		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+	/* Regulators */
+#define GP_3P7_BYPASS_EN	IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),
+#define GP_3P7_EN		IMX_GPIO_NR(5, 11)
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+#define GP_REG_2P8V_EN		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+	/* Vibrator */
+#define GP_VIBRATOR_EN		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLDN),
+	/* TODO Wireless control pins */
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+	/* main power on/ use pmic_on_req instead */
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* New rev,  not shorted with TAMPER */
+#define GPIRQ_TAMPER		IMX_GPIO_NR(6, 17)
+	IOMUX_PAD_CTRL(SD3_DAT7__GPIO6_IO17, WEAK_PULLUP),
+	/* Old rev, shorted with TAMPER */
+#define GPIRQ_TAMPER_OLD	IMX_GPIO_NR(4, 18)
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLDN),
+
+	/* TP68 */
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+	/* TP71 */
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+	/* TP72 */
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+	/* TP74 */
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLDN),
+	/* TP84 */
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+	/* TP85 */
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+	/* TP86 */
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	/* TP87 */
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	/* TP91 */
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+	/* TP92 */
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+	/* TP93 */
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLUP),
+	/* TP94 */
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLUP),
+	/* TP95 */
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+	/* TP96 */
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	/* TP97 */
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+	/* TP105 */
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLUP),
+	/* TP106 */
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+	/* TP110 */
+	IOMUX_PAD_CTRL(KEY_COL4__GPIO4_IO14, WEAK_PULLUP),
+	/* Let max77818 control this directly by turning on/off CHGIN */
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	/*
+	 * TP111 on rev 1,
+	 * power enable on rev 0 that should not be used, so keep pull down
+	 */
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+	/* TP131 */
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLUP),
+
+	/* I2C1 - mux */
+#define GP_I2C1MUX_A0		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN),
+#define GP_I2C1MUX_A1		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN),
+#define GP_I2C1MUX_RESET	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN),
+
+	/* I2C1(mux 0) - wm8960 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, WEAK_PULLDN),
+#define GP_WM8960_MIC_DET		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+#define GP_WM8960_HP_DET		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+
+	/* I2C1(mux 1) - accelerometer */
+#define GPIRQ_MPU9250_INT	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLUP),
+
+	/* I2C1(mux 2) - finger sensor */
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_MCLK__IPU1_CSI0_HSYNC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_VSYNC__IPU1_CSI0_VSYNC, WEAK_PULLUP),
+#define GP_FP_CSI0_RESET_N	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_FP_SENSOR_STAT	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+#define GP_FP_LE_EN		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+#define GP_FP_LE_5V_EN		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),
+#define GP_FP_CSI_3P3V_EN	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+
+	/* I2C1(mux 3) - ov5640 mipi */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+
+	/* I2C2 - EEPROM */
+#define GPIRQ_EEPROM_INTR	IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLUP),
+#define GP_EEPROM_ADDRESS	IMX_GPIO_NR(2, 29)
+	IOMUX_PAD_CTRL(EIM_EB1__GPIO2_IO29, WEAK_PULLDN),
+
+	/* I2C2 - RTC */
+#define GPIRQ_RTC	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* I2C3 - Touch */
+#define GPIRQ_TOUCH	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+#define GP_TOUCH_RESET	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+
+	/* I2C3 - LM3643 */
+#define GP_FLASH_STROBE		IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLUP),
+#define GP_FLASH_HW_EN		IMX_GPIO_NR(5, 6)
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+#define GP_TORCH_EN		IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+#define GP_FLASH_TX		IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+
+	/* I2C3 - max77818 */
+#define GPIRQ_MAX77818_WCHG_VALID_INT	IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GPIRQ_MAX77818_WCHG_VALID	IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GPIRQ_MAX77818_CHG_INT		IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+
+	/* MIPI display */
+#define GP_MIPI_DSI_RESET	IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLDN),
+#define GP_MIPI_TE		IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLDN),
+#define GP_MIPI_ID		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLDN),
+
+	/* PWM1, backlight (MIPI display) */
+#define GP_PWM1			IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+#define GP_MIPI_BACKLIGHT_EN	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLDN),
+
+	/* PWM2, FP_MCLK */
+#define GP_PWM2			IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLUP),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* Rev 1 only, not on rev 0 */
+#define GP_USB_NFC_PWR_EN	IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLDN),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* UART3 for BT */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+
+	/* USDHC2 - Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		gpio_set_value(GP_USB_NFC_PWR_EN, 1);
+
+		/* Reset USB hub */
+		gpio_set_value(GP_USBH1_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USBH1_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	max77823_otg_power(on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET,
+	GP_EEPROM_ADDRESS,
+	GP_FLASH_HW_EN,
+	GP_FP_CSI0_RESET_N,
+	GP_FP_LE_EN,
+	GP_FP_LE_5V_EN,
+	GP_FP_CSI_3P3V_EN,
+	GP_GPS_RESET,
+	GP_I2C1MUX_A0,
+	GP_I2C1MUX_A1,
+	GP_I2C1MUX_RESET,
+	GP_MIPI_DSI_RESET,
+	GP_MODEM_RESET,
+	GP_MODEM_ON_OFF,
+#if LED_ACTIVE_BLUE != 0
+	GP_LED_BLUE,
+#endif
+#if LED_ACTIVE_GREEN != 0
+	GP_LED_GREEN,
+#endif
+#if LED_ACTIVE_RED != 0
+	GP_LED_RED,
+#endif
+	GP_OV5640_MIPI_RESET,
+	GP_PWM1,
+	GP_MIPI_BACKLIGHT_EN,
+	GP_PWM2,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+	GP_USBH1_HUB_RESET,
+	GP_USB_NFC_PWR_EN,
+	GP_REG_2P8V_EN,
+	GP_VIBRATOR_EN,
+	GP_TORCH_EN,
+	GP_TOUCH_RESET,
+};
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_CS,
+#if LED_ACTIVE_BLUE == 0
+	GP_LED_BLUE,
+#endif
+#if LED_ACTIVE_GREEN == 0
+	GP_LED_GREEN,
+#endif
+#if LED_ACTIVE_RED == 0
+	GP_LED_RED,
+#endif
+	GP_LED_CTRL_GREEN,
+	GP_LED_CTRL_RED,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_RESET,
+	GP_GPIOKEY_VBUS_STATUS,
+	GP_GPS_INT,
+	GP_SIM_DETECT,
+	GP_USDHC3_CD,
+	GP_WM8960_HP_DET,
+	GP_WM8960_MIC_DET,
+	GP_MIPI_TE,
+	GPIRQ_EEPROM_INTR,
+	GPIRQ_MAX77818_WCHG_VALID_INT,
+	GPIRQ_MAX77818_WCHG_VALID,
+	GPIRQ_MAX77818_CHG_INT,
+	GPIRQ_MPU9250_INT,
+	GPIRQ_RTC,
+	GPIRQ_TAMPER,
+	GPIRQ_TAMPER_OLD,
+	GPIRQ_TOUCH,
+	GPIRQ_WIFI,
+	GP_TP74,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+void flash_red_led(void)
+{
+	int led_red = LED_ACTIVE_RED;
+	int i;
+
+	gpio_set_value(GP_LED_BLUE, LED_ACTIVE_BLUE ^ 1);
+	mdelay(500);
+
+	for (i = 0; i < 4; i++) {
+		gpio_set_value(GP_LED_RED, led_red);
+		mdelay(500);
+		led_red ^= 1;
+	}
+}
+
+static void __board_poweroff(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
+
+	writel(0x60, &snvs->lpcr);
+	mdelay(500);
+}
+
+void board_poweroff(void)
+{
+	flash_red_led();
+	__board_poweroff();
+}
+
+void board_power_check(void)
+{
+	gpio_set_value(GP_VIBRATOR_EN, 0);
+	max77834_power_check();
+}
+
+ulong start_time;
+
+void hw_watchdog_reset(void)
+{
+	ulong elapsed;
+	if (start_time) {
+		elapsed = get_timer(start_time);
+		if (elapsed >= CONFIG_SYS_HZ/2) {
+			gpio_set_value(GP_VIBRATOR_EN, 0);
+			start_time = 0;
+		}
+	}
+}
+
+int board_init(void)
+{
+	int i;
+	int inactive = 0;
+	int active = 0;
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			NULL, 0, 0);
+	gpio_set_value(GP_LED_BLUE, LED_ACTIVE_BLUE);
+
+	if ((get_imx_reset_cause() & 0xef) == 0x1) {
+		/*
+		 * Power-on reset
+		 * Check that power button is on for 1/2 second more
+		 */
+		for (i = 0; i < 500; i++) {
+			if (gpio_get_value(GP_GPIOKEY_POWER)) {
+				inactive++;
+				if (inactive >= 100) {
+					printf("power button not pressed long enough\n");
+					__board_poweroff();
+				}
+			} else {
+				active++;
+				if (active >= 400)
+					break;
+			}
+			udelay(1000);
+		}
+		gpio_set_value(GP_VIBRATOR_EN, 1);
+		start_time = get_timer(0);
+	}
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"power",	GP_GPIOKEY_POWER, 'p', 1},
+	{"reset",	GP_GPIOKEY_RESET, 'r', 1},
+#ifdef CONFIG_REV_OLD
+	{"tamper",	TAMPER_CHECK,	't', 1, 1},
+#else
+	{"tamper",	GPIRQ_TAMPER,	't', 1, 1},
+#endif
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/cid/cid_q2g.cfg u-boot-imx6/board/boundary/cid/cid_q2g.cfg
--- u-boot-2017.07/board/boundary/cid/cid_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid/cid_q2g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x431c032c
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x031b0314
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x03240333
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x031c025d
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x44363b43
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3f393549
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383b3f34
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4433463d
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00100017
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001d0015
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000b001d
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070015
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cid/Kconfig u-boot-imx6/board/boundary/cid/Kconfig
--- u-boot-2017.07/board/boundary/cid/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,24 @@
+if TARGET_CID
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "cid"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cid"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cid/MAINTAINERS u-boot-imx6/board/boundary/cid/MAINTAINERS
--- u-boot-2017.07/board/boundary/cid/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,6 @@
+CID BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cid/
+F:	include/configs/cid.h
+F:	configs/cid_2g_defconfig
diff -Nru u-boot-2017.07/board/boundary/cid/Makefile u-boot-imx6/board/boundary/cid/Makefile
--- u-boot-2017.07/board/boundary/cid/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cid.o
diff -Nru u-boot-2017.07/board/boundary/cid_tab/cid_tab.c u-boot-imx6/board/boundary/cid_tab/cid_tab.c
--- u-boot-2017.07/board/boundary/cid_tab/cid_tab.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid_tab/cid_tab.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,689 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <pwm.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Audmux 3 - Goes to the WM8960 */
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+
+	/* Audmux 4 - Goes to the WWAN USB Modem */
+	IOMUX_PAD_CTRL(DISP0_DAT20__AUD4_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__AUD4_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__AUD4_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__AUD4_RXD, AUD_PAD_CTRL),
+
+	/* backlight lvds */
+#define GP_BACKLIGHT_LVDS_EN	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLDN),
+#define GP_BACKLIGHT_LVDS_PWM1	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+#define GP_LVDS_LED_EN		IMX_GPIO_NR(4, 19)
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLDN),
+#define GP_LVDS_BIST		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLDN),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ECSPI2 - J6, finger sensor */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),	/* pin 3 */
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),	/* pin 4 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),	/* pin 5 */
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),	/* pin 6 */
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 1 nRST of AR8035 */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_GPIOKEY_VOL_DN	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+
+	/* Hogs */
+#define GP_GPIO_A		IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),
+#define GP_GPIO_B		IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+
+#define GP_STAT_LED1		IMX_GPIO_NR(4, 26)		/* Blue */
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_STAT_LED2		IMX_GPIO_NR(4, 25)		/* Greeen */
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_STAT_LED3		IMX_GPIO_NR(4, 27)		/* Red */
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+
+	/* Hogs - FAN48623, regulator for WWAN usb modem, always on for now */
+#define GP_3P7_EN		IMX_GPIO_NR(5, 11)
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLDN),	/* active high */
+#define GP_3P7_BYPASS_EN	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),	/* low active */
+
+#define GPIRQ_TAMPER	IMX_GPIO_NR(4, 18)
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLDN),
+#define GPIRQ_TAMPER2	IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLDN),
+
+	/* TODO Wireless control pins */
+#define GP_BT_CLK_REQ		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLUP),
+#define GP_BT_HOST_WAKE		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+
+#define GP_TP68			IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP72			IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLUP),
+#define GP_TP73			IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLDN),
+#define GP_TP78			IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+#define GP_TP85			IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+#define GP_TP86			IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+#define GP_TP90			IMX_GPIO_NR(4, 17)
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+#define GP_TP91			IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GP_TP92			IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+#define GP_TP97			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_TP104		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+#define GP_TP131		IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLUP),
+#define GP_TP_R368		IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, WEAK_PULLUP),
+
+	/* I2C1 - mux */
+#define GP_I2C1MUX_A0		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN),
+#define GP_I2C1MUX_A1		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN),
+#define GP_I2C1MUX_RESET	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN),
+
+	/* I2C1(mux 0) - wm8960 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, WEAK_PULLDN),
+#define GP_WM8960_MIC_DET		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+#define GP_WM8960_HP_DET		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+
+	/* I2C1(mux 1) - accelerometer */
+#define GPIRQ_MPU9250_INT	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLUP),
+
+	/* I2C1(mux 2)camera CSI0 J6  - finger sensor */
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, WEAK_PULLUP),	/* pin 20 */
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, WEAK_PULLUP),	/* pin 21 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, WEAK_PULLUP),	/* pin 22 */
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, WEAK_PULLUP),	/* pin 23 */
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, WEAK_PULLUP),	/* pin 25 */
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, WEAK_PULLUP),	/* pin 26 */
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, WEAK_PULLUP),	/* pin 27 */
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, WEAK_PULLUP),	/* pin 28 */
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN, WEAK_PULLUP),	/* pin 11 NS */
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, WEAK_PULLUP),	/* pin 10 */
+	IOMUX_PAD_CTRL(CSI0_MCLK__IPU1_CSI0_HSYNC, WEAK_PULLUP),	/* pin 16 */
+	IOMUX_PAD_CTRL(CSI0_VSYNC__IPU1_CSI0_VSYNC, WEAK_PULLUP),	/* pin 17 */
+#define GP_FP_RESET_N		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),		/* pin 18 */
+#define GP_FP_SENSOR_STAT	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),	/* pin 2 */
+#define GP_FP_LE_EN		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLDN),		/* pin 11 */
+
+	/* I2C1(mux 3) - ov5640 mipi */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* I2C2, J1 - Front camera, ov5640 */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU2_CSI1_DATA10, WEAK_PULLUP),	/* pin 37 */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU2_CSI1_DATA11, WEAK_PULLUP),	/* pin 35 */
+	/* pin 34, mclk, GPIO_3, also mipi_mclk */
+	IOMUX_PAD_CTRL(EIM_A17__IPU2_CSI1_DATA12, WEAK_PULLUP),	/* pin 33 */
+	IOMUX_PAD_CTRL(EIM_A18__IPU2_CSI1_DATA13, WEAK_PULLUP),	/* pin 31 */
+	IOMUX_PAD_CTRL(EIM_A19__IPU2_CSI1_DATA14, WEAK_PULLUP),	/* pin 29 */
+	IOMUX_PAD_CTRL(EIM_A20__IPU2_CSI1_DATA15, WEAK_PULLUP),	/* pin 27 */
+	IOMUX_PAD_CTRL(EIM_A21__IPU2_CSI1_DATA16, WEAK_PULLUP),	/* pin 25 */
+	IOMUX_PAD_CTRL(EIM_A22__IPU2_CSI1_DATA17, WEAK_PULLUP),	/* pin 23 */
+	IOMUX_PAD_CTRL(EIM_A23__IPU2_CSI1_DATA18, WEAK_PULLUP),	/* pin 21 */
+	IOMUX_PAD_CTRL(EIM_A24__IPU2_CSI1_DATA19, WEAK_PULLUP),	/* pin 19 */
+	IOMUX_PAD_CTRL(EIM_DA10__IPU2_CSI1_DATA_EN, WEAK_PULLUP),	/* pin 14 */
+	IOMUX_PAD_CTRL(EIM_A16__IPU2_CSI1_PIXCLK, WEAK_PULLUP),	/* pin 11 */
+	IOMUX_PAD_CTRL(EIM_DA11__IPU2_CSI1_HSYNC, WEAK_PULLUP),	/* pin 15 */
+	IOMUX_PAD_CTRL(EIM_DA12__IPU2_CSI1_VSYNC, WEAK_PULLUP),	/* pin 13 */
+#define GP_OV5640_STROBE		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),	/* pin 3 */
+#define GP_OV5640_POWER_DOWN		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),	/* pin 17 */
+#define GP_OV5640_RESET			IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),	/* pin 9 */
+
+	/* I2C2 - GT928 Touchscreen */
+#define GPIRQ_GT928	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+#define GP_GT928_RESET	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),
+
+	/* I2C2 - light sensor */
+#define GPIRQ_LIGHTSENSOR	IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+
+	/* I2C2 - RTC */
+#define GPIRQ_RTC	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* I2C3 - LM3643 */
+#define GP_FLASH_STROBE		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLDN),
+#define GP_FLASH_HW_EN		IMX_GPIO_NR(5, 6)
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLDN),
+#define GP_TORCH_EN		IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLDN),
+#define GP_FLASH_TX		IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLDN),
+
+	/* I2C3 - max77818 */
+#define GPIRQ_MAX77818_INOK	IMX_GPIO_NR(5, 13)
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+#define GPIRQ_MAX77818_WCINOK	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GPIRQ_MAX77818		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+
+	/* leds - Vibrator */
+#define GP_LED_VIBRATOR		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLDN),
+
+	/* PWM3, backlight (LVDS display) */
+#define GP_LVDS_LED_PWM		IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* PWM2, FP_MCLK */
+#define GP_PWM2			IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* PWM4, SIM_CLK  */
+#define GP_SIM_CLK		IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* Regulators */
+/* Goes to  J1(Front camera, EIM1), J5(mipi, rear), and NVCC_CSI/EIM1 */
+#define GP_REG_2P8V_EN		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+
+#define GP_REG_FP_3P3V_EN	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN),	/* J6 pin 7, 3.3V */
+
+#define GP_REG_FP_5V_EN		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),	/* J6 pin 8, 5v */
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+#define GP_REG_VBUS4		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for BT */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 - J65 */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 - GPS Ublox MAX-7W */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+#define GP_GPS_HEARTBEAT	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+#define GP_GPS_INT		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_GPS_RESET		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLDN),
+
+	/* USBH1 */
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* WWAN USB Modem */
+#define GP_MODEM_RESET		IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLDN),
+#define GP_MODEM_PULSE_ON	IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLDN),
+#define GP_SLEEP_STAT		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+#define GP_SIM_DETECT		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+#define GP_SIM_IO		IMX_GPIO_NR(5, 10)
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+};
+
+static const iomux_v3_cfg_t lvds_led_pwm_pads[] = {
+	IOMUX_PAD_CTRL(SD1_DAT1__PWM3_OUT, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t lvds_led_pwm_gpio_pads[] = {
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/*
+	 * pca9546 mux(0x70), J7 lvds,
+	 *    wm8960(0x1a),
+	 *    mpu9250(0x69),
+	 *    finger-sensor(0x37),
+	 *    ov5640_mipi(0x3c)
+	 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/*
+	 * gt928(0x14), lightsensor(0x29), ov5640(0x3c), rv4162(0x68)
+	 */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/*
+	 * fan53526(0x60), lm3643(0x63), max77818(0x66)
+	 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USBH1_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USBH1_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	int gp = port ? GP_REG_VBUS4 : GP_REG_USBOTG;
+
+	if (on)
+		max77823_boost_power(on);
+	gpio_set_value(gp, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		mdelay(200);
+		gpio_set_value(GP_BACKLIGHT_LVDS_PWM1, enable);
+		gpio_set_value(GP_BACKLIGHT_LVDS_EN, enable);
+		mdelay(10);
+		/* enable backlight PWM 3 */
+		SETUP_IOMUX_PADS(lvds_led_pwm_pads);
+		pwm_init(2, 0, 0);
+		/* 20 KHz, duty cycle 30%, period: 0.05 ms */
+		pwm_config(2, 15000, 50000);
+		pwm_enable(2);
+		mdelay(10);
+		gpio_set_value(GP_LVDS_LED_EN, enable);
+	} else {
+		gpio_set_value(GP_LVDS_LED_EN, enable);
+		SETUP_IOMUX_PADS(lvds_led_pwm_gpio_pads);
+		mdelay(10);
+		gpio_set_value(GP_BACKLIGHT_LVDS_EN, enable);
+		gpio_set_value(GP_BACKLIGHT_LVDS_PWM1, enable);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* EDID at 0x50 */
+	VD_M101NWWB(LVDS, fbp_detect_i2c, 0, 0x50),
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+	VD_ND1024_600(LVDS, fbp_detect_i2c, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_LD070WSVGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_BACKLIGHT_LVDS_EN,
+	GP_BACKLIGHT_LVDS_PWM1,
+	GP_LVDS_LED_EN,
+	GP_LVDS_BIST,
+	GP_BT_RFKILL_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_GPS_RESET,
+	GP_MODEM_RESET,
+	GP_MODEM_PULSE_ON,
+	GP_LED_VIBRATOR,
+	GP_I2C1MUX_A0,
+	GP_I2C1MUX_A1,
+	GP_I2C1MUX_RESET,
+	GP_FP_RESET_N,
+	GP_FP_LE_EN,
+	GP_OV5640_RESET,
+	GP_OV5640_MIPI_RESET,
+	GP_GT928_RESET,
+	GP_FLASH_STROBE,
+	GP_FLASH_HW_EN,
+	GP_TORCH_EN,
+	GP_FLASH_TX,
+	GP_LVDS_LED_PWM,
+	GP_PWM2,
+	GP_REG_2P8V_EN,
+	GP_REG_FP_3P3V_EN,
+	GP_REG_FP_5V_EN,
+	GP_REG_USBOTG,
+	GP_REG_VBUS4,
+	GP_REG_WLAN_EN,
+	GP_USBH1_HUB_RESET,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_CS,
+	GP_STAT_LED2,
+	GP_STAT_LED1,
+	GP_STAT_LED3,
+	GP_OV5640_POWER_DOWN,
+	GP_OV5640_STROBE,
+	GP_OV5640_MIPI_POWER_DOWN,
+	GP_3P7_EN,
+	GP_3P7_BYPASS_EN,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DN,
+	GP_GPIOKEY_VOL_UP,
+	GP_GPS_HEARTBEAT,
+	GP_GPS_INT,
+	GP_GPIO_A,
+	GP_GPIO_B,
+	GP_SLEEP_STAT,
+	GP_SIM_DETECT,
+	GP_SIM_IO,
+	GP_SIM_CLK,
+	GP_BT_CLK_REQ,
+	GP_BT_HOST_WAKE,
+	GP_WIFI_QOW,
+	GP_TP68,
+	GP_TP71,
+	GP_TP72,
+	GP_TP73,
+	GP_TP74,
+	GP_TP78,
+	GP_TP85,
+	GP_TP86,
+	GP_TP90,
+	GP_TP91,
+	GP_TP92,
+	GP_TP97,
+	GP_TP104,
+	GP_TP131,
+	GP_TP_R368,
+	GP_WM8960_MIC_DET,
+	GP_WM8960_HP_DET,
+	GPIRQ_MPU9250_INT,
+	GP_FP_SENSOR_STAT,
+	GPIRQ_RTC,
+	GPIRQ_TAMPER,
+	GPIRQ_TAMPER2,
+	GPIRQ_LIGHTSENSOR,
+	GPIRQ_GT928,
+	GPIRQ_MAX77818_INOK,
+	GPIRQ_MAX77818_WCINOK,
+	GPIRQ_MAX77818,
+	GPIRQ_WIFI,
+	GP_WIFI_WAKE,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
+
+	max77823_boost_power(0);
+	writel(0x60, &snvs->lpcr);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"reset",	GP_GPIOKEY_POWER,	'r', 1},
+	{"vol_dn",	GP_GPIOKEY_VOL_DN,	'-', 1},
+	{"vol_up",	GP_GPIOKEY_VOL_UP,	'+', 1},
+	{"tamper",	TAMPER_CHECK,		't', 1},
+	{"tp74",	GP_TP74,		'4', 0},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/cid_tab/cid_tab_q2g.cfg u-boot-imx6/board/boundary/cid_tab/cid_tab_q2g.cfg
--- u-boot-2017.07/board/boundary/cid_tab/cid_tab_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid_tab/cid_tab_q2g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x4308031c
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0308027a
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x03110321
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0305024e
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x43343944
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3c383244
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37383f32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4131433b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0012001d
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00190012
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000f0021
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00060013
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cid_tab/Kconfig u-boot-imx6/board/boundary/cid_tab/Kconfig
--- u-boot-2017.07/board/boundary/cid_tab/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid_tab/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,24 @@
+if TARGET_CID_TAB
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "cid_tab"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cid_tab"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cid_tab/MAINTAINERS u-boot-imx6/board/boundary/cid_tab/MAINTAINERS
--- u-boot-2017.07/board/boundary/cid_tab/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid_tab/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,6 @@
+CID BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cid_tab/
+F:	include/configs/cid_tab.h
+F:	configs/cid_tab_q2g_defconfig
diff -Nru u-boot-2017.07/board/boundary/cid_tab/Makefile u-boot-imx6/board/boundary/cid_tab/Makefile
--- u-boot-2017.07/board/boundary/cid_tab/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cid_tab/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cid_tab.o
diff -Nru u-boot-2017.07/board/boundary/cnt/cnt1g.cfg u-boot-imx6/board/boundary/cnt/cnt1g.cfg
--- u-boot-2017.07/board/boundary/cnt/cnt1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/cnt1g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* This configuration not yet produced */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cnt/cnt2g.cfg u-boot-imx6/board/boundary/cnt/cnt2g.cfg
--- u-boot-2017.07/board/boundary/cnt/cnt2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/cnt2g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 10 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x431b032c
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0314030c
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x03220331
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0319025d
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45363c47
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3f393648
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3a3d4035
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4334473f
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0012001a
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001c0016
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000f0022
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000a0017
+#define WALAT	1
+
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+
+#if 0
+/* ddr frequency to 528 Mhz using PLL2 */
+
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#endif
+#if 0
+/*
+ * ddr frequency to 452.571 MHz using pfd0
+ * pfd0 can be modified for lvds pixel clock, so don't use.
+ */
+DATA 4, CCM_ANALOG_PFD_528, 0x10181015
+DATA 4, CCM_CBCMR, 0x000a0324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 1
+/* ddr frequency to 500.210 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1013101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 0
+/* ddr frequency to 475.200 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1014101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 0
+/* ddr frequency to 452.571 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1015101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 0
+/* ddr frequency to 432 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1016101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 0
+/* ddr frequency to 413.217 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1017101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+#if 0
+/* ddr frequency to 396 MHz using pfd2 */
+DATA 4, CCM_ANALOG_PFD_528, 0x1018101b
+DATA 4, CCM_CBCMR, 0x00060324
+#include "../common/mx6/ddr-setup.cfg"
+#include "../common/mx6/1000mhz_256mx16.cfg"
+#endif
+
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cnt/cnt.c u-boot-imx6/board/boundary/cnt/cnt.c
--- u-boot-2017.07/board/boundary/cnt/cnt.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/cnt.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Accelerometer */
+#define GPIRQ_ACCEL		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+
+	/* NFC */
+#define GPIRQ_NFC		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),
+#define GP_NFC_VEN		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* Touch Reset */
+#define GP_TOUCH_RESET		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Accelerometer, NFC */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, Touch */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_NOR_CS;
+	if (cs >> 8)
+		return (cs >> 8);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VD_LG1280_800(LVDS, NULL, 0, 0x38),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_BACKLIGHT_LVDS,
+	GP_NFC_VEN,
+	GP_REG_USBOTG,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_TOUCH_RESET,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ACCEL,
+	GPIRQ_ENET_PHY,
+	GPIRQ_NFC,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 8 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x60, 0x50, 0x00, 0x00)},
+	/* 4 bit bus width */
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/cnt/Kconfig u-boot-imx6/board/boundary/cnt/Kconfig
--- u-boot-2017.07/board/boundary/cnt/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,17 @@
+if TARGET_CNT
+
+config SYS_BOARD
+	default "cnt"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cnt"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cnt/MAINTAINERS u-boot-imx6/board/boundary/cnt/MAINTAINERS
--- u-boot-2017.07/board/boundary/cnt/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,7 @@
+CNT BOARD
+M:	Gary Bisson <gary.bisson@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cnt/
+F:	include/configs/cnt.h
+F:	configs/cnt1g_defconfig
+F:	configs/cnt2g_defconfig
diff -Nru u-boot-2017.07/board/boundary/cnt/Makefile u-boot-imx6/board/boundary/cnt/Makefile
--- u-boot-2017.07/board/boundary/cnt/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cnt/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cnt.o
diff -Nru u-boot-2017.07/board/boundary/cob/cob.c u-boot-imx6/board/boundary/cob/cob.c
--- u-boot-2017.07/board/boundary/cob/cob.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob/cob.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include <pwm.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 pads (serial nor eeprom) */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* gpio_keys */
+#define GP_GPIOKEYS_MENU		IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLUP),
+#define GP_GPIOKEYS_HOME		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_GPIOKEYS_PB1_I		IMX_GPIO_NR(1, 8)	/* J9 pin 6 */
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+#define GP_GPIOKEYS_PB2_I		IMX_GPIO_NR(7, 12)	/* J10 pin 6 */
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* GPIO-leds */
+#define GP_GPIOLEDS_1		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLDN_OUTPUT),
+#define GP_GPIOLEDS_2		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLDN_OUTPUT),
+
+	/* Hog - GPIOs */
+#define GP_HEATER_EN		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLDN_OUTPUT),
+
+#define GP_LCD_DAY_BACKLIGHT_EN	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_LCD_NIGHT_BACKLIGHT_EN IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLDN_OUTPUT),
+
+#define GP_TX			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_RX			IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+#define GP_HEATER_FAULT		IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+#define GP_DA1_OUTA		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+#define GP_DA1_OUTB		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_DB1_OUTA		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_DB1_OUTB		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_DA2_OUTA		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_DA2_OUTB		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_DB2_OUTA		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_DB2_OUTB		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+
+	/* Hog - testpoints */
+#define GP_TP5			IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_TP6			IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP72			IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLDN),
+#define GP_TP75			IMX_GPIO_NR(1, 11)
+	IOMUX_PAD_CTRL(SD2_CMD__GPIO1_IO11, WEAK_PULLUP),
+#define GP_TP76			IMX_GPIO_NR(1, 10)
+	IOMUX_PAD_CTRL(SD2_CLK__GPIO1_IO10, WEAK_PULLUP),
+#define GP_TP78			IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_TP79			IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+#define GP_I2C3_CRTOUCH			IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+#define GP_I2C3_CRTOUCH_WAKE		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_I2C3_CRTOUCH_RESET		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLDN),
+
+	/* PWM1 */
+#define GP_LCD_DAY_BACKLIGHT_PWM IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM2 */
+#define GP_LCD_NIGHT_BACKLIGHT_PWM IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* Regulator - usbotg */
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__UART1_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__UART1_RTS_B, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_RST__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USBH1_SOURCE	IMX_GPIO_NR(2, 28)	/* 1 - imx, 0 - other board */
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN),
+#define GP_USBH1_FP_OC	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USB OTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* Hsync */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* Vsync */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT3__PWM1_OUT, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Connect H1 USB to imx */
+		gpio_direction_output(GP_USBH1_SOURCE, 1);
+		mdelay(2);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+		/* enable backlight PWM 1 */
+		pwm_init(0, 0, 0);
+
+		/* 300 Hz, duty cycle 2 ms, period: 3.3 ms */
+		pwm_config(0, 1666667, 3333333);
+		pwm_enable(0);
+	} else {
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+	gpio_direction_output(GP_LCD_DAY_BACKLIGHT_EN, enable);
+	gpio_direction_output(GP_LCD_DAY_BACKLIGHT_PWM, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* tsc2004 */
+	VD_DC050WX(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_USBH1_SOURCE,
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_HEATER_EN,
+	GP_LCD_DAY_BACKLIGHT_EN,
+	GP_LCD_DAY_BACKLIGHT_PWM,
+	GP_LCD_NIGHT_BACKLIGHT_EN,
+	GP_LCD_NIGHT_BACKLIGHT_PWM,
+	GP_I2C3_CRTOUCH_RESET,
+	GP_DA1_OUTA,
+	GP_DA1_OUTB,
+	GP_DB1_OUTA,
+	GP_DB1_OUTB,
+	GP_DA2_OUTA,
+	GP_DA2_OUTB,
+	GP_DB2_OUTA,
+	GP_DB2_OUTB,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,		/* SS1 of spi nor */
+	GP_I2C3_CRTOUCH_WAKE,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_USBH1_FP_OC,
+	GP_GPIOLEDS_1,
+	GP_GPIOLEDS_2,
+	GP_GPIOKEYS_MENU,
+	GP_GPIOKEYS_HOME,
+	GP_GPIOKEYS_PB1_I,
+	GP_GPIOKEYS_PB2_I,
+	GP_TX,
+	GP_RX,
+	GP_HEATER_FAULT,
+	GP_TP5,
+	GP_TP6,
+	GP_TP71,
+	GP_TP72,
+	GP_TP74,
+	GP_TP75,
+	GP_TP76,
+	GP_TP78,
+	GP_TP79,
+	GP_I2C3_CRTOUCH,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"home",	GP_GPIOKEYS_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEYS_MENU,	'M', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	{"mmc0",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/cob/cob.cfg u-boot-imx6/board/boundary/cob/cob.cfg
--- u-boot-2017.07/board/boundary/cob/cob.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob/cob.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cob/Kconfig u-boot-imx6/board/boundary/cob/Kconfig
--- u-boot-2017.07/board/boundary/cob/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,20 @@
+if TARGET_COB
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "cob"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cob"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cob/MAINTAINERS u-boot-imx6/board/boundary/cob/MAINTAINERS
--- u-boot-2017.07/board/boundary/cob/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,7 @@
+cob BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cob/
+F:	include/configs/cob.h
+F:	configs/cob_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/cob/Makefile u-boot-imx6/board/boundary/cob/Makefile
--- u-boot-2017.07/board/boundary/cob/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cob.o
diff -Nru u-boot-2017.07/board/boundary/cob2/cob2.c u-boot-imx6/board/boundary/cob2/cob2.c
--- u-boot-2017.07/board/boundary/cob2/cob2.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob2/cob2.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,499 @@
+/*
+ * Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include <pwm.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 pads (serial nor eeprom) */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI5 pads  */
+	IOMUX_PAD_CTRL(SD1_DAT0__ECSPI5_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__ECSPI5_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CLK__ECSPI5_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI5_CS0	IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLUP),
+#define GP_ECSPI5_CS1	IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+/* pin 1 nRST of AR8035 */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpio_keys */
+#define GP_GPIOKEYS_MENU	IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLUP),
+#define GP_GPIOKEYS_HOME	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_GPIOKEYS_PB1_I	IMX_GPIO_NR(1, 8)	/* J9 pin 6 */
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+#define GP_GPIOKEYS_PB2_I	IMX_GPIO_NR(7, 12)	/* J10 pin 6 */
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+/* Input used for determining if UART is available */
+#define GP_GPIOKEYS_SW2		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLUP),
+#define GP_GPIOKEYS_A		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),
+#define GP_GPIOKEYS_B		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLUP),
+#define GP_GPIOKEYS_EXP_RDY	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),
+#define GP_GPIOKEYS_DAY_BL_OPEN	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_GPIOKEYS_DAY_BL_SHORT IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GP_GPIOKEYS_NIGHT_BL_OPEN IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+#define GP_GPIOKEYS_NIGHT_BL_SHORT IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+
+	/* GPIO-leds */
+#define GP_GPIOLEDS_1		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP_OUTPUT),
+#define GP_GPIOLEDS_2		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP_OUTPUT),
+
+	/* Hog - GPIOs */
+#define GP_HEATER_EN		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLDN_OUTPUT),
+
+#define GP_LCD_DAY_BACKLIGHT_EN	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_LCD_NIGHT_BACKLIGHT_EN IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLDN_OUTPUT),
+#define GP_EXPAN_EN		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN_OUTPUT),
+
+#define GP_TX			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_RX			IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+#define GP_HEATER_FAULT		IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+#define GP_DA1_OUTA		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+#define GP_DA1_OUTB		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_DB1_OUTA		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_DB1_OUTB		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_DA2_OUTA		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_DA2_OUTB		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_DB2_OUTA		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_DB2_OUTB		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+#define GP_DIS_FPGA_RESET	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLDN),
+#define GP_I2C_DIG_SEL		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_FPGA_READY		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+
+	/* Hog - testpoints */
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLDN),
+#define GP_TP78			IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_TP79			IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DAT2__GPIO7_IO06, WEAK_PULLUP),
+#define GP_TP80			IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+#define GP_TP81			IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+#define GP_I2C3_CRTOUCH		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+#define GP_I2C3_CRTOUCH_WAKE	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_I2C3_CRTOUCH_RESET	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLDN),
+
+	/* PWM1 */
+#define GP_LCD_DAY_BACKLIGHT_PWM IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN_OUTPUT),
+
+	/* PWM2 */
+#define GP_LCD_NIGHT_BACKLIGHT_PWM IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN_OUTPUT),
+
+	/* PWM3 */
+#define GP_PWM3			IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN_OUTPUT),
+
+	/* Regulator - usbotg */
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__UART1_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__UART1_RTS_B, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, INPUT_FLOAT),	/* J57, alt UART2 rx usage */
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_RST__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USBH1_SOURCE		IMX_GPIO_NR(2, 28)	/* 1 - imx, 0 - other board */
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN),
+#define GP_USBH1_FP_OC		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USBH1_HUB_RESET      IMX_GPIO_NR(2, 29)
+	IOMUX_PAD_CTRL(EIM_EB1__GPIO2_IO29, WEAK_PULLDN),
+
+	/* USB OTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - SDIO */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* Hsync */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* Vsync */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT3__PWM1_OUT, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Connect H1 USB to imx */
+		gpio_direction_output(GP_USBH1_SOURCE, 1);
+		mdelay(2);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+		/* enable backlight PWM 1 */
+		pwm_init(0, 0, 0);
+
+		/* 300 Hz, duty cycle 2 ms, period: 3.3 ms */
+		pwm_config(0, 1666667, 3333333);
+		pwm_enable(0);
+	} else {
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+	gpio_direction_output(GP_LCD_DAY_BACKLIGHT_EN, enable);
+	gpio_direction_output(GP_LCD_DAY_BACKLIGHT_PWM, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* tsc2004 */
+	VD_DC050WX(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_HEATER_EN,
+	GP_LCD_DAY_BACKLIGHT_EN,
+	GP_LCD_NIGHT_BACKLIGHT_EN,
+	GP_EXPAN_EN,
+	GP_DA1_OUTA,
+	GP_DA1_OUTB,
+	GP_DB1_OUTA,
+	GP_DB1_OUTB,
+	GP_DA2_OUTA,
+	GP_DA2_OUTB,
+	GP_DB2_OUTA,
+	GP_DB2_OUTB,
+	GP_DIS_FPGA_RESET,
+	GP_I2C3_CRTOUCH_RESET,
+	GP_LCD_DAY_BACKLIGHT_PWM,
+	GP_LCD_NIGHT_BACKLIGHT_PWM,
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_USBH1_SOURCE,
+	GP_USBH1_HUB_RESET,
+	GP_EMMC_RESET,		/* hold in reset */
+
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,		/* SS1 of spi nor */
+	GP_ECSPI5_CS0,
+	GP_ECSPI5_CS1,
+	GP_I2C3_CRTOUCH_WAKE,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEYS_MENU,
+	GP_GPIOKEYS_HOME,
+	GP_GPIOKEYS_PB1_I,
+	GP_GPIOKEYS_PB2_I,
+	GP_GPIOKEYS_SW2,
+	GP_GPIOKEYS_A,
+	GP_GPIOKEYS_B,
+	GP_GPIOKEYS_EXP_RDY,
+	GP_GPIOKEYS_DAY_BL_OPEN,
+	GP_GPIOKEYS_DAY_BL_SHORT,
+	GP_GPIOKEYS_NIGHT_BL_OPEN,
+	GP_GPIOKEYS_NIGHT_BL_SHORT,
+	GP_GPIOLEDS_1,
+	GP_GPIOLEDS_2,
+	GP_TX,
+	GP_RX,
+	GP_HEATER_FAULT,
+	GP_I2C_DIG_SEL,
+	GP_FPGA_READY,
+	GP_TP71,
+	GP_TP74,
+	GP_TP78,
+	GP_TP79,
+	GP_TP80,
+	GP_TP81,
+	GP_I2C3_CRTOUCH,
+	GP_PWM3,
+	GP_USBH1_FP_OC,
+};
+
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"home",	GP_GPIOKEYS_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEYS_MENU,	'M', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	{"mmc0",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/cob2/cob2_q1g.cfg u-boot-imx6/board/boundary/cob2/cob2_q1g.cfg
--- u-boot-2017.07/board/boundary/cob2/cob2_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob2/cob2_q1g.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 9 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43230337
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x031e0318
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43270337
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03210267
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x3d303544
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3a343242
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x35363d2e
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4031453a
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00190021
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0024001e
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00150025
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000c001c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/cob2/Kconfig u-boot-imx6/board/boundary/cob2/Kconfig
--- u-boot-2017.07/board/boundary/cob2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob2/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,20 @@
+if TARGET_COB2
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "cob2"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "cob2"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/cob2/MAINTAINERS u-boot-imx6/board/boundary/cob2/MAINTAINERS
--- u-boot-2017.07/board/boundary/cob2/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob2/MAINTAINERS	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,7 @@
+cob2 BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/cob2/
+F:	include/configs/cob2.h
+F:	configs/cob2_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/cob2/Makefile u-boot-imx6/board/boundary/cob2/Makefile
--- u-boot-2017.07/board/boundary/cob2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/cob2/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := cob2.o
diff -Nru u-boot-2017.07/board/boundary/common/bd_common.c u-boot-imx6/board/boundary/common/bd_common.c
--- u-boot-2017.07/board/boundary/common/bd_common.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/bd_common.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/clock.h>
+#ifndef CONFIG_MX7D
+#ifndef CONFIG_MX51
+#include <asm/arch/iomux.h>
+#endif
+#endif
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <i2c.h>
+#include <linux/fb.h>
+#include <version.h>
+#include "bd_common.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int dram_init(void)
+{
+#if defined(CONFIG_MX51) || defined(CONFIG_MX7D)
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+#else
+	gd->ram_size = imx_ddr_size();
+#endif
+//	printf("%s:%p *%p=0x%lx\n", __func__, gd, &gd->ram_size, gd->ram_size);
+
+	return 0;
+}
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+void set_gpios_in(const unsigned short *p, int cnt)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++)
+		gpio_direction_input(*p++);
+}
+
+void set_gpios(const unsigned short *p, int cnt, int val)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++)
+		gpio_direction_output(*p++, val);
+}
+
+#ifdef CONFIG_FSL_ESDHC
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int gp_cd = cfg->gp_cd;
+
+	if (!gp_cd)
+		return 1;	/* eMMC always present */
+	return !gpio_get_value(gp_cd);
+}
+
+#if defined(CONFIG_MX51)
+#define BASE1 MMC_SDHC1_BASE_ADDR
+#define BASE2 MMC_SDHC2_BASE_ADDR
+#define CNT CONFIG_SYS_FSL_ESDHC_NUM
+#else
+#define BASE1 USDHC1_BASE_ADDR
+#define BASE2 USDHC2_BASE_ADDR
+#define BASE3 USDHC3_BASE_ADDR
+#define BASE4 USDHC4_BASE_ADDR
+#define CNT CONFIG_SYS_FSL_USDHC_NUM
+#endif
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	u32 index = 0;
+
+	for (index = 0; index < CNT; index++) {
+		struct fsl_esdhc_cfg *cfg = &board_usdhc_cfg[index];
+
+		if (cfg->esdhc_base == BASE1) {
+			cfg->sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+		} else if (cfg->esdhc_base == BASE2) {
+			cfg->sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+#ifndef CONFIG_MX51
+		} else if (cfg->esdhc_base == BASE3) {
+			cfg->sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+#ifndef CONFIG_MX7D
+		} else if (cfg->esdhc_base == BASE4) {
+			cfg->sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+#endif
+#endif
+		} else {
+			printf("unknown esdhc base %lx\n", cfg->esdhc_base);
+			break;
+		}
+
+		if (cfg->gp_cd)
+			gpio_request(cfg->gp_cd, "usdhcx_cd");
+
+		if (cfg->gp_reset) {
+			gpio_request(cfg->gp_reset, "usdhcx_reset");
+			gpio_set_value(cfg->gp_reset, 1); /* release reset */
+		}
+
+		ret = fsl_esdhc_initialize(bis, cfg);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPLASH_SCREEN
+int splash_screen_prepare(void)
+{
+	char *env_loadsplash;
+
+	if (!getenv("splashimage") || !getenv("splashsize")) {
+		return -1;
+	}
+
+	env_loadsplash = getenv("loadsplash");
+	if (env_loadsplash == NULL) {
+		printf("Environment variable loadsplash not found!\n");
+		return -1;
+	}
+
+	if (run_command_list(env_loadsplash, -1, 0)) {
+		printf("failed to run loadsplash %s\n\n", env_loadsplash);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+int board_cfb_skip(void)
+{
+	return NULL != getenv("novideo");
+}
+#endif
+
+void common_board_init(const struct i2c_pads_info *p, int i2c_bus_cnt, int otg_id,
+		const struct display_info_t *displays, int display_cnt,
+		int gp_hd_detect)
+{
+	int i;
+#ifdef IOMUXC_GPR1_OTG_ID_MASK
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	/* needed for i.mx6q, duallite doesn't need it, but doesn't hurt */
+	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_OTG_ID_MASK, otg_id);
+#endif
+	p += i2c_get_info_entry_offset();
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+	for (i = 0; i < i2c_bus_cnt; i++) {
+	        setup_i2c(p->bus_index, CONFIG_SYS_I2C_SPEED, 0x7f, p);
+		p += I2C_PADS_INFO_ENTRY_SPACING;
+	}
+#ifdef CONFIG_FAN53526
+	fan53526_init();
+#endif
+#ifdef CONFIG_MAX77823
+	max77823_init();
+#endif
+#ifdef CONFIG_TAMPER
+	check_tamper();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	if (!gp_hd_detect || gpio_get_value(gp_hd_detect))
+		setup_sata();
+#endif
+#ifdef CONFIG_CMD_FBPANEL
+	fbp_setup_display(displays, display_cnt);
+#endif
+}
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_PREBOOT
+	board_preboot_keys();
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+	/*
+	 * Not really needed as script checks for magic value in memory,
+	 * but shouldn't hurt.
+	 */
+	setenv_hex("reset_cause", get_imx_reset_cause());
+
+#ifdef CONFIG_MX7D
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PRINT_TIME_RV4162
+
+/* RV4162 particulars */
+#define RTC_I2CADDR 0x68
+#define RTC_YEAR 7
+#define RTC_MON  6
+#define RTC_DAY  5
+#define RTC_HOUR 3
+#define RTC_MIN  2
+#define RTC_SEC  1
+
+static int frombcd(u8 val)
+{
+	return (10*(val>>4))+(val&0x0f);
+}
+
+static void print_time_rv4162(void)
+{
+	u8 orig_i2c_bus;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	/* display date and time from RTC */
+	if (!i2c_set_bus_num(0) &&
+			!i2c_probe(RTC_I2CADDR)) {
+		u8 buffer[16];
+		int ret = i2c_read(RTC_I2CADDR, 0, 1, buffer, sizeof(buffer));
+
+		if (ret)
+			printf("Error %d reading RTC\n", ret);
+		else
+			printf("time: %04u-%02u-%02u %02u:%02u:%02u UTC\n",
+			       2000+frombcd(buffer[RTC_YEAR]),
+			       frombcd(buffer[RTC_MON]&0x1f),
+			       frombcd(buffer[RTC_DAY]),
+			       frombcd(buffer[RTC_HOUR]),
+			       frombcd(buffer[RTC_MIN]),
+			       frombcd(buffer[RTC_SEC]));
+	}
+	i2c_set_bus_num(orig_i2c_bus);
+}
+#else
+static void print_time_rv4162(void) {}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+#define ADDMAC_OFFSET	0x800000
+#else
+#define ADDMAC_OFFSET	0
+#endif
+
+#if defined(CONFIG_ENV_WLMAC) || defined(CONFIG_ENV_BD_ADDR)
+static void addmac_env(const char* env_var)
+{
+	unsigned char mac_address[8];
+	char macbuf[20];
+
+	if (!getenv(env_var)) {
+		imx_get_mac_from_fuse(ADDMAC_OFFSET, mac_address);
+		if (is_valid_ethaddr(mac_address)) {
+			snprintf(macbuf, sizeof(macbuf), "%pM", mac_address);
+			setenv(env_var, macbuf);
+		}
+	}
+}
+#endif
+
+#if defined(CONFIG_CMD_FASTBOOT) || defined(CONFIG_CMD_DFU)
+static void addserial_env(const char* env_var)
+{
+	unsigned char mac_address[8];
+	char serialbuf[20];
+
+	if (!getenv(env_var)) {
+		imx_get_mac_from_fuse(0, mac_address);
+		snprintf(serialbuf, sizeof(serialbuf), "%02x%02x%02x%02x%02x%02x",
+			 mac_address[0], mac_address[1], mac_address[2],
+			 mac_address[3], mac_address[4], mac_address[5]);
+		setenv(env_var, serialbuf);
+	}
+}
+#endif
+
+#ifndef CONFIG_SYS_BOARD
+/* CANNOT be in BSS section, will clobber relocation table */
+const char *board_type = (void*)1;
+#endif
+
+int checkboard(void)
+{
+#ifdef CONFIG_SYS_BOARD
+	puts("Board: " CONFIG_SYS_BOARD "\n");
+#else
+	board_type = board_get_board_type();
+	puts("Board: ");
+	puts(board_type);
+	puts("\n");
+#endif
+	return 0;
+}
+
+static const char str_uboot_release[] = "uboot_release";
+static const char cur_uboot_release[] = PLAIN_VERSION;
+
+int board_late_init(void)
+{
+	char *uboot_release;
+	int cpurev = get_cpu_rev();
+
+#ifdef CONFIG_BOARD_LATE_SPECIFIC_INIT
+	board_late_specific_init();
+#endif
+	setenv("cpu", get_imx_type((cpurev & 0xFF000) >> 12));
+	setenv("imx_cpu", get_imx_type((cpurev & 0xFF000) >> 12));
+#ifndef CONFIG_SYS_BOARD
+	/*
+	 * These lines are specific to nitrogen6x, as
+	 * everyone else has board in their default environment.
+	 */
+	if (!getenv("board"))
+		setenv("board", board_type);
+#endif
+	setenv("uboot_defconfig", CONFIG_DEFCONFIG);
+#ifdef CONFIG_ENV_WLMAC
+	addmac_env("wlmac");
+#endif
+#ifdef CONFIG_ENV_BD_ADDR
+	addmac_env("bd_addr");
+#endif
+#if defined(CONFIG_CMD_FASTBOOT) || defined(CONFIG_CMD_DFU)
+	addserial_env("serial#");
+#endif
+	print_time_rv4162();
+
+#if !defined(CONFIG_ENV_IS_NOWHERE)
+	uboot_release = getenv(str_uboot_release);
+	if (!uboot_release || strcmp(cur_uboot_release, uboot_release)) {
+		setenv(str_uboot_release, cur_uboot_release);
+		if (uboot_release) {
+			/*
+			 * if already saved in environment, correct value
+			 */
+			saveenv();
+		}
+	}
+#endif
+	return 0;
+}
diff -Nru u-boot-2017.07/board/boundary/common/bd_common.h u-boot-imx6/board/boundary/common/bd_common.h
--- u-boot-2017.07/board/boundary/common/bd_common.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/bd_common.h	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __BD_COMMON_H_
+#define __BD_COMMON_H_     1
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+
+struct button_key {
+	char const	*name;
+	unsigned short	gpnum;
+	char		ident;
+	char		active_low;
+	char		tamper;
+};
+#define TAMPER_CHECK	0xffff
+
+struct boot_mode;
+extern const struct boot_mode board_boot_modes[];
+extern const struct button_key board_buttons[];
+extern struct fsl_esdhc_cfg board_usdhc_cfg[];
+extern const char *board_type;
+void board_preboot_keys(void);
+void board_late_specific_init(void);
+const char *board_get_board_type(void);
+void set_gpios_in(const unsigned short *p, int cnt);
+void set_gpios(const unsigned short *p, int cnt, int val);
+
+struct display_info_t;
+struct i2c_pads_info;
+
+void common_board_init(const struct i2c_pads_info *p, int i2c_bus_cnt, int otg_id,
+		const struct display_info_t *displays, int display_cnt,
+		int gp_hd_detect);
+struct snvs_regs;
+void tamper_enable(struct snvs_regs *snvs);
+void tamper_clear(struct snvs_regs *snvs);
+void check_tamper(void);
+
+#define MAX_BUTTONS	32
+
+void max77823_init(void);
+void max77823_otg_power(int enable);
+void max77823_boost_power(int enable);
+int max77823_is_charging(void);
+void max77834_power_check(void);
+
+void fan53526_init(void);
+int otg_power_detect(void);
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/cmd_kbd.c u-boot-imx6/board/boundary/common/cmd_kbd.c
--- u-boot-2017.07/board/boundary/common/cmd_kbd.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/cmd_kbd.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include "bd_common.h"
+#ifdef CONFIG_TAMPER
+void tamper_enable(struct snvs_regs *snvs)
+{
+	writel(0x41736166, &snvs->lppgdr);	/* power glitch magic value */
+	writel(0x00800000, &snvs->lptgfcr);	/* Tamper Glitch Filter 1 En */
+	writel(0x200, &snvs->lptdcr);		/* External Tampering 1 En */
+	writel(0x20, &snvs->hpsvsr);		/* w1c, VIO5 */
+	writel(0x40030208, &snvs->lpsr);	/* w1c */
+	writel(0x20, &snvs->hpsvcr);		/* gpio1[0] will stop working */
+	writel(0x20, &snvs->lpsvcr);		/* Security Violation 5 En */
+}
+
+void tamper_clear(struct snvs_regs *snvs)
+{
+	writel(0x41736166, &snvs->lppgdr);	/* power glitch magic value */
+	writel(0, &snvs->lptgfcr);		/* disable Tamper Glitch Filter */
+	writel(0, &snvs->lptdcr);		/* disable External Tampering */
+	writel(0x20, &snvs->hpsvsr);		/* w1c, VIO5 */
+	writel(0, &snvs->hpsvcr);		/* makes gpio1[0] work again */
+	writel(0, &snvs->lpsvcr);		/* disable Security Vio */
+	writel(0x40030208, &snvs->lpsr);	/* w1c */
+}
+
+static void tamper_assert(struct snvs_regs *snvs)
+{
+	tamper_enable(snvs);
+	udelay(100);
+	tamper_clear(snvs);
+}
+
+void check_tamper(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)SNVS_BASE_ADDR;
+	const struct button_key *bb = board_buttons;
+	unsigned short gp;
+
+	while (1) {
+		if (!bb->name)
+			break;
+		if (bb->tamper) {
+			gp = bb->gpnum;
+			if (gpio_get_value(gp) ^ bb->active_low)
+				tamper_assert(snvs);
+		}
+		bb++;
+	}
+	tamper_clear(snvs);
+}
+#endif
+
+/*
+ * generate a null-terminated string containing the buttons pressed
+ * returns number of keys pressed
+ */
+static int read_keys(char *buf)
+{
+#ifdef CONFIG_TAMPER
+	struct snvs_regs *snvs = (struct snvs_regs *)SNVS_BASE_ADDR;
+#endif
+	int numpressed = 0;
+	const struct button_key *bb = board_buttons;
+	unsigned short gp;
+
+	while (1) {
+		if (!bb->name)
+			break;
+		gp = bb->gpnum;
+#ifdef CONFIG_TAMPER
+		if (gp == TAMPER_CHECK) {
+			/* Tamper status */
+			unsigned lpsr;
+
+			/*
+			 * We cannot leave tamper enabled all the time because
+			 * it screws up gpio_0
+			 */
+			tamper_enable(snvs);
+			udelay(100);
+			lpsr = readl(&snvs->lpsr);
+
+			if (lpsr & BIT(9)) {
+				buf[numpressed++] = bb->ident;
+			}
+			tamper_clear(snvs);
+		} else
+#endif
+		{
+			if (gpio_get_value(gp) ^ bb->active_low) {
+				buf[numpressed++] = bb->ident;
+#ifdef CONFIG_TAMPER
+				if (bb->tamper)
+					tamper_assert(snvs);
+#endif
+			}
+		}
+		bb++;
+	}
+	buf[numpressed] = '\0';
+	return numpressed;
+}
+
+static int do_kbd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char envvalue[MAX_BUTTONS];
+	int numpressed = read_keys(envvalue);
+
+	setenv("keybd", envvalue);
+	return numpressed == 0;
+}
+
+U_BOOT_CMD(
+	kbd, 1, 1, do_kbd,
+	"Tests for keypresses, sets 'keybd' environment variable",
+	"Returns 0 (true) to shell if key is pressed."
+);
+
+#ifdef CONFIG_PREBOOT
+static char const kbd_magic_prefix[] = "key_magic";
+static char const kbd_command_prefix[] = "key_cmd";
+
+void board_preboot_keys(void)
+{
+	int numpressed;
+	char keypress[MAX_BUTTONS];
+
+	numpressed = read_keys(keypress);
+	if (numpressed) {
+		char *kbd_magic_keys = getenv("magic_keys");
+		char *suffix;
+		/*
+		 * loop over all magic keys
+		 */
+		for (suffix = kbd_magic_keys; *suffix; ++suffix) {
+			char *keys;
+			char magic[sizeof(kbd_magic_prefix) + 1];
+			sprintf(magic, "%s%c", kbd_magic_prefix, *suffix);
+			keys = getenv(magic);
+			if (keys) {
+				if (!strcmp(keys, keypress))
+					break;
+			}
+		}
+		if (*suffix) {
+			char cmd_name[sizeof(kbd_command_prefix) + 1];
+			char *cmd;
+			sprintf(cmd_name, "%s%c", kbd_command_prefix, *suffix);
+			cmd = getenv(cmd_name);
+			if (cmd) {
+				setenv("preboot", cmd);
+				return;
+			}
+		}
+	}
+}
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/cmd_otg_cable.c u-boot-imx6/board/boundary/common/cmd_otg_cable.c
--- u-boot-2017.07/board/boundary/common/cmd_otg_cable.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/cmd_otg_cable.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "bd_common.h"
+
+#define ANADIG_USB1_CHRG_DETECT_CHK_CONTACT	BIT(18)
+#define ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B	BIT(19)
+#define ANADIG_USB1_CHRG_DETECT_EN_B		BIT(20)
+
+#define ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT	BIT(0)
+#define ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED	BIT(1)
+
+int otg_power_detect(void)
+{
+	int ret = 0;
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 val;
+	int i = 0;
+
+	/* turn on comparator, change threshold to 4.6V*/
+	writel(BIT(20) | 6, &mxc_ccm->usb1_vbus_detect_set);
+	writel(1, &mxc_ccm->usb1_vbus_detect_clr);
+
+	/* Enable charger detect, contact detect */
+	writel(ANADIG_USB1_CHRG_DETECT_EN_B, &mxc_ccm->usb1_chrg_detect_clr);
+	writel(ANADIG_USB1_CHRG_DETECT_CHK_CONTACT |
+		ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		&mxc_ccm->usb1_chrg_detect_set);
+
+	/* determine type of cable */
+	/* Check if plug is connected */
+	while (1) {
+		val = readl(&mxc_ccm->usb1_vbus_det_stat);
+		if (!(val & 0x0e))
+			break;
+		if (val & 0x8) {
+			ret = 1;
+			break;
+		}
+		val = readl(&mxc_ccm->usb1_chrg_det_stat);
+		if (!(val & ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT))
+			break;
+		i++;
+		if (i >= 10) {
+			ret = 1;
+			break;
+		}
+		udelay(5000);
+	}
+	/* Disable charger detect */
+	writel(ANADIG_USB1_CHRG_DETECT_EN_B |
+		ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		&mxc_ccm->usb1_chrg_detect_set);
+	return ret;
+}
+
+static int do_otg_cable(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return otg_power_detect() ? 0 : 1;
+}
+
+U_BOOT_CMD(
+	otg_cable, 1, 1, do_otg_cable,
+	"Tests for otg cable connected",
+	"Returns 0 (true) to shell if cable is connected."
+);
diff -Nru u-boot-2017.07/board/boundary/common/eth.c u-boot-imx6/board/boundary/common/eth.c
--- u-boot-2017.07/board/boundary/common/eth.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/eth.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,489 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/imx-regs.h>
+#if defined(CONFIG_MX51)
+#include <asm/arch/iomux-mx51.h>
+#elif defined(CONFIG_MX7D)
+#else
+#include <asm/arch/iomux.h>
+#endif
+#include <asm/arch/sys_proto.h>
+#if defined(CONFIG_MX7D)
+#include <asm/arch/mx7-pins.h>
+#elif !defined(CONFIG_MX51)
+#include <asm/arch/mx6-pins.h>
+#endif
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <linux/errno.h>
+#include <malloc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <spi.h>
+#include "../common/padctrl.h"
+
+#if defined(CONFIG_FEC_MXC) && !defined(CONFIG_FEC_MXC_PHYADDR)
+#error CONFIG_FEC_MXC_PHYADDR missing
+#endif
+
+#ifdef CONFIG_FEC_MXC_PHYADDR
+#ifdef CONFIG_PHY_ATHEROS
+#define ATHEROS_MASK(a) ((1 << (a)) | ((1 << ((a) ^ 4))))
+#else
+#define ATHEROS_MASK(a) 0
+#endif
+
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+#define KSZ9021_MASK(a) (0xf << ((a) & 4))
+#else
+#define KSZ9021_MASK(a) 0
+#endif
+
+#define ALL_PHY_MASK(a) (ATHEROS_MASK(a) | KSZ9021_MASK(a))
+#ifdef CONFIG_RGMII2
+#define COMBINED_MASK(a) (ALL_PHY_MASK(a) | (ALL_PHY_MASK(a + 1) << 16))
+#else
+#define COMBINED_MASK(a) ALL_PHY_MASK(a)
+#endif
+
+#ifndef ETH_PHY_MASK
+#define ETH_PHY_MASK	COMBINED_MASK(CONFIG_FEC_MXC_PHYADDR)
+#endif
+
+#if ((ETH_PHY_MASK >> CONFIG_FEC_MXC_PHYADDR) & 1) == 0
+#error CONFIG_FEC_MXC_PHYADDR is not part of ETH_PHY_MASK
+#endif
+#endif
+
+#define PULL_GP(a, bit)		(((a >> bit) & 1) ? WEAK_PULLUP_OUTPUT : WEAK_PULLDN_OUTPUT)
+#if 0	//defined(CONFIG_MX7D)
+#define PULL_ENET(a, bit)	(((a >> bit) & 1) ? PAD_CTRL_ENET_RX_UP : PAD_CTRL_ENET_RX_DN)
+#else
+#define PULL_ENET(a, bit)	PAD_CTRL_ENET_RX
+#endif
+
+#ifdef CONFIG_MX6SX
+#include "eth-mx6sx.c"
+#elif defined(CONFIG_MX7D)
+#include "eth-mx7d.c"
+#elif defined(CONFIG_MX51)
+#include "eth-mx51.c"
+#else
+#include "eth-mx6.c"
+#endif
+
+#if defined(CONFIG_PHY_ATHEROS) || defined(CONFIG_PHY_MICREL_KSZ9021)
+static unsigned char strap_gpios[] = {
+	GP_PHY_RD0,
+	GP_PHY_RD1,
+	GP_PHY_RD2,
+	GP_PHY_RD3,
+	GP_PHY_RX_CTL,
+	GP_PHY_RXC,
+#ifdef CONFIG_MX6SX
+	GP_PHY2_RD0,
+	GP_PHY2_RD1,
+	GP_PHY2_RD2,
+	GP_PHY2_RD3,
+	GP_PHY2_RX_CTL,
+	GP_PHY2_RXC,
+#endif
+};
+
+static void set_strap_pins(unsigned strap)
+{
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(strap_gpios); i++) {
+		gpio_direction_output(strap_gpios[i], strap & 1);
+		strap >>= 1;
+	}
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+static void init_fec_clocks(void)
+{
+#ifdef CONFIG_MX6SX
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	int reg;
+	int i;
+
+	/* Use 125MHz anatop loopback REF_CLK1 for ENET1 */
+	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK | IOMUX_GPR1_FEC2_MASK, 0);
+
+	reg = readl(&anatop->pll_enet);
+	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
+	writel(reg, &anatop->pll_enet);
+
+	for (i = 0; i < 2; i++) {
+		int ret = enable_fec_anatop_clock(i, ENET_125MHZ);
+		if (ret) {
+			printf("Failed to enable clock (FEC%d): %d\n", i, ret);
+			return;
+		}
+	}
+#endif
+#ifdef CONFIG_MX7D
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+		(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+		 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK), 0);
+
+	set_clk_enet(ENET_125MHz);
+#endif
+	udelay(100);	/* Wait 100 us before using mii interface */
+}
+
+#if defined(CONFIG_RGMII2)
+#define FEC_INDEX	0	/* FEC0 for imx6sx */
+#else
+#define FEC_INDEX	-1	/* just plain FEC */
+#endif
+
+static void init_fec(bd_t *bis, unsigned phy_mask)
+{
+#ifdef CONFIG_MX6SX
+	uint32_t mdio_base = ENET_MDIO_BASE;
+	uint32_t base = ENET_BASE_ADDR;
+#else
+	uint32_t mdio_base = IMX_FEC_BASE;
+	uint32_t base = IMX_FEC_BASE;
+#endif
+	struct mii_dev *bus = NULL;
+	struct phy_device *phydev = NULL;
+	int ret;
+
+	bus = fec_get_miibus(mdio_base, -1);
+	if (!bus)
+		return;
+#if defined(CONFIG_RGMII1) || !defined(CONFIG_MX6SX)
+	phydev = phy_find_by_mask(bus, phy_mask & 0xffff, PHY_INTERFACE_MODE_RGMII);
+	if (!phydev) {
+		printf("%s: phy not found\n", __func__);
+		goto error;
+	}
+	printf("%s at %d\n", phydev->drv->name, phydev->addr);
+	ret  = fec_probe(bis, FEC_INDEX, base, bus, phydev);
+	if (ret) {
+		printf("FEC MXC: %s:failed\n", __func__);
+		free(phydev);
+		goto error;
+	}
+#endif
+#if defined(CONFIG_RGMII2)
+	phydev = phy_find_by_mask(bus, phy_mask >> 16, PHY_INTERFACE_MODE_RGMII);
+	if (!phydev) {
+		printf("%s: phy2 not found\n", __func__);
+		goto error;
+	}
+	printf("%s at %d\n", phydev->drv->name, phydev->addr);
+	ret  = fec_probe(bis, 1, ENET2_BASE_ADDR, bus, phydev);
+	if (ret) {
+		printf("FEC1 MXC: %s:failed\n", __func__);
+		free(phydev);
+		goto error;
+	}
+#endif
+	return;
+error:
+	;
+	/* Let's leave "mii read" in working state for debug */
+#if 0
+	mdio_unregister(bus);
+	mdio_free(bus);
+#endif
+}
+#endif
+
+#ifdef CONFIG_PHY_ATHEROS
+static void setup_gpio_ar8035(void)
+{
+	set_strap_pins(STRAP_AR8035);
+	SETUP_IOMUX_PADS(enet_ar8035_gpio_pads);
+}
+
+static void setup_enet_ar8035(void)
+{
+	SETUP_IOMUX_PADS(enet_ar8035_pads);
+}
+#ifndef CONFIG_PHY_MICREL_KSZ9021
+#define setup_gpio_eth(kz) setup_gpio_ar8035()
+#define setup_enet_eth(kz) setup_enet_ar8035()
+#endif
+#endif
+
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+static void setup_gpio_ksz9021(void)
+{
+	set_strap_pins(STRAP_KSZ9021);
+	SETUP_IOMUX_PADS(enet_ksz9021_gpio_pads);
+}
+
+static void setup_enet_ksz9021(void)
+{
+	SETUP_IOMUX_PADS(enet_ksz9021_pads);
+}
+#ifndef CONFIG_PHY_ATHEROS
+#define setup_gpio_eth(kz) setup_gpio_ksz9021()
+#define setup_enet_eth(kz) setup_enet_ksz9021()
+#else
+#define setup_gpio_eth(kz) if (kz) setup_gpio_ksz9021(); else setup_gpio_ar8035();
+#define setup_enet_eth(kz) if (kz) setup_enet_ksz9021(); else setup_enet_ar8035();
+#endif
+#endif
+
+#if defined(CONFIG_PHY_ATHEROS) || defined(CONFIG_PHY_MICREL_KSZ9021)
+static void setup_iomux_enet(int kz)
+{
+#ifdef GP_KS8995_RESET
+	gpio_direction_output(GP_KS8995_RESET, 0);
+#endif
+#ifdef GP_RGMII2_PHY_RESET
+	gpio_direction_output(GP_RGMII2_PHY_RESET, 0); /* PHY rst */
+#endif
+	gpio_direction_output(GP_RGMII_PHY_RESET, 0); /* PHY rst */
+	setup_gpio_eth(kz);
+
+	/* Need delay 10ms according to KSZ9021 spec */
+	/* 1 ms minimum reset pulse for ar8035 */
+	udelay(1000 * 10);
+#ifdef GP_RGMII2_PHY_RESET
+	gpio_set_value(GP_RGMII2_PHY_RESET, 1); /* PHY reset */
+#endif
+	gpio_set_value(GP_RGMII_PHY_RESET, 1); /* PHY reset */
+#ifdef GP_KS8995_POWER_DOWN
+	gpio_direction_output(GP_KS8995_POWER_DOWN, 1);
+#endif
+
+#ifdef CONFIG_MX7D
+	/* strap hold time for AR8031, 18 fails, 19 works, so 40 should be safe */
+	udelay(40);
+#else
+	/* strap hold time for AR8035, 5 fails, 6 works, so 12 should be safe */
+	udelay(12);
+#endif
+#ifdef GP_KS8995_RESET
+	gpio_direction_output(GP_KS8995_RESET, 1);
+#endif
+
+	setup_enet_eth(kz);
+}
+#endif
+
+#ifdef CONFIG_PHY_ATHEROS
+static void phy_ar8031_config(struct phy_device *phydev)
+{
+	int val;
+
+	/* Select 125MHz clk from local PLL on CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x0007);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= ~0x1c;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, (val|0x0018));
+
+#if 0 //done in ar8031_config
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, (val|0x0100));
+#endif
+}
+
+static void phy_ar8035_config(struct phy_device *phydev)
+{
+	int val;
+
+	/*
+	 * Ar803x phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x3);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x805d);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4003);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val & ~(1 << 8));
+
+#if 0 //done in ar8035_config
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, (val|0x0100));
+
+	phydev->supported = phydev->drv->features;
+#endif
+}
+
+#define PHY_ID_AR8031	0x004dd074
+#define PHY_ID_AR8035	0x004dd072
+
+#ifndef CONFIG_PHY_MICREL_KSZ9021
+int board_phy_config(struct phy_device *phydev)
+{
+	if (((phydev->drv->uid ^ PHY_ID_AR8031) & 0xffffffef) == 0)
+		phy_ar8031_config(phydev);
+	else if (((phydev->drv->uid ^ PHY_ID_AR8035) & 0xffffffef) == 0)
+		phy_ar8035_config(phydev);
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+#define PHY_ID_KSZ9021	0x221610
+
+int board_phy_config(struct phy_device *phydev)
+{
+#ifdef CONFIG_PHY_ATHEROS
+	if (((phydev->drv->uid ^ PHY_ID_AR8031) & 0xffffffef) == 0) {
+		phy_ar8031_config(phydev);
+	} else if (((phydev->drv->uid ^ PHY_ID_AR8035) & 0xffffffef) == 0) {
+		phy_ar8035_config(phydev);
+	} else if (((phydev->drv->uid ^ PHY_ID_KSZ9021) & 0xfffffff0) == 0) {
+		/* found KSZ, reinit phy for KSZ */
+		setup_iomux_enet(1);
+#else
+	{
+#endif
+		/* min rx data delay */
+		ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_RX_DATA_SKEW, 0x0);
+		/* min tx data delay */
+		ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_TX_DATA_SKEW, 0x0);
+		/* max rx/tx clock delay, min rx/tx control */
+		ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_CLOCK_SKEW, 0xf0f0);
+	}
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+#endif
+
+#ifdef GP_KS8995_RESET
+static int ks8995_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint len = *cmds++;
+
+		if (!len)
+			break;
+
+		ret = spi_xfer(spi, len * 8, cmds, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+		if (ret) {
+			debug("%s: Failed spi %02x,%02x,%02x %d\n", __func__, cmds[0], cmds[1], cmds[2], ret);
+			return ret;
+		}
+		debug("spi: len=%02x cmds= %02x,%02x,%02x\n", len, cmds[0], cmds[1], cmds[2]);
+		cmds += len;
+	}
+	return ret;
+}
+
+#define KS8995_REG_ID1		0x01    /* Chip ID1 */
+#define KS8995_RESET_DELAY	10	/* usec */
+
+static u8 stop_cmds[] = {3, 2, KS8995_REG_ID1, 0, 0};
+static u8 start_cmds[] = {3, 2, KS8995_REG_ID1, 1, 0};
+
+static int ks8995_reset(void)
+{
+	struct spi_slave *spi;
+	int ret;
+
+	enable_spi_clk(1, 1);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(1, 1, 4000000, SPI_MODE_0);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_slave;
+	}
+
+	ret = ks8995_write_rtn(spi, stop_cmds);
+	if (ret)
+		return ret;
+
+	udelay(KS8995_RESET_DELAY);
+
+	ret = ks8995_write_rtn(spi, start_cmds);
+
+	/* Release spi bus */
+	spi_release_bus(spi);
+free_slave:
+	spi_free_slave(spi);
+	enable_spi_clk(0, 1);
+
+	return ret;
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_PHY_ATHEROS) || defined(CONFIG_PHY_MICREL_KSZ9021)
+	setup_iomux_enet(0);
+#endif
+#ifdef GP_KS8995_RESET
+	ks8995_reset();
+#endif
+#ifdef CONFIG_FEC_MXC
+	init_fec_clocks();
+	init_fec(bis, ETH_PHY_MASK);
+#endif
+
+#ifdef CONFIG_CI_UDC
+#if defined(CONFIG_FEC_MXC) && defined(CONFIG_RGMII1) && defined(CONFIG_RGMII2)
+#define USB_ETH "eth2addr"
+#elif defined(CONFIG_FEC_MXC)
+#define USB_ETH "eth1addr"
+#else
+#define USB_ETH "ethaddr"
+#endif
+	/* For otg ethernet*/
+#ifndef CONFIG_FEC_MXC
+	/* ethaddr should be set from fuses */
+	if (!getenv(USB_ETH)) {
+		unsigned char mac[8];
+
+		imx_get_mac_from_fuse(0, mac);
+		if (is_valid_ethaddr(mac))
+			eth_setenv_enetaddr(USB_ETH, mac);
+		else
+			setenv(USB_ETH, getenv("usbnet_devaddr"));
+	}
+#else
+	if (!getenv(USB_ETH))
+		setenv(USB_ETH, getenv("usbnet_devaddr"));
+#endif
+	usb_eth_initialize(bis);
+#endif
+	return 0;
+}
diff -Nru u-boot-2017.07/board/boundary/common/eth-mx51.c u-boot-imx6/board/boundary/common/eth-mx51.c
--- u-boot-2017.07/board/boundary/common/eth-mx51.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/eth-mx51.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,5 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
diff -Nru u-boot-2017.07/board/boundary/common/eth-mx6.c u-boot-imx6/board/boundary/common/eth-mx6.c
--- u-boot-2017.07/board/boundary/common/eth-mx6.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/eth-mx6.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+						/* pin kz9021,	pin ar8035 */
+#define GP_PHY_RD0	IMX_GPIO_NR(6, 25)	/* 32 MODE0,	29 AD0 */
+#define GP_PHY_RD1	IMX_GPIO_NR(6, 27)	/* 31 MODE1,	28 AD1 */
+#define GP_PHY_RD2	IMX_GPIO_NR(6, 28)	/* 28 MODE2,	26 MODE1 */
+#define GP_PHY_RD3	IMX_GPIO_NR(6, 29)	/* 27 MODE3,	25 MODE3 */
+#define GP_PHY_RX_CTL	IMX_GPIO_NR(6, 24)	/* 33 CLK125_EN, 30 MODE0 */
+#define GP_PHY_RXC	IMX_GPIO_NR(6, 30)	/* 35 AD2,	31 1P8_SEL */
+
+#ifndef STRAP_AR8035
+#define STRAP_AR8035	(0x28 | (CONFIG_FEC_MXC_PHYADDR & 3))
+#endif
+
+#ifdef CONFIG_PHY_ATHEROS
+static const iomux_v3_cfg_t enet_ar8035_gpio_pads[] = {
+	IOMUX_PAD_CTRL(RGMII_RD0__GPIO6_IO25, PULL_GP(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(RGMII_RD1__GPIO6_IO27, PULL_GP(STRAP_AR8035, 1)),
+	/* mode = 1100 - plloff mode */
+	IOMUX_PAD_CTRL(RGMII_RD2__GPIO6_IO28, PULL_GP(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(RGMII_RD3__GPIO6_IO29, PULL_GP(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(RGMII_RX_CTL__GPIO6_IO24, PULL_GP(STRAP_AR8035, 4)),
+	IOMUX_PAD_CTRL(RGMII_RXC__GPIO6_IO30, PULL_GP(STRAP_AR8035, 5)),
+};
+
+static const iomux_v3_cfg_t enet_ar8035_pads[] = {
+	IOMUX_PAD_CTRL(RGMII_RD0__RGMII_RD0, PULL_ENET(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(RGMII_RD1__RGMII_RD1, PULL_ENET(STRAP_AR8035, 1)),
+	IOMUX_PAD_CTRL(RGMII_RD2__RGMII_RD2, PULL_ENET(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(RGMII_RD3__RGMII_RD3, PULL_ENET(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(RGMII_RX_CTL__RGMII_RX_CTL, PULL_ENET(STRAP_AR8035, 4)),
+	IOMUX_PAD_CTRL(RGMII_RXC__RGMII_RXC, PULL_ENET(STRAP_AR8035, 5)),
+};
+#endif
+
+#define STRAP_KSZ9021	(0x1f | ((CONFIG_FEC_MXC_PHYADDR & 4) ? 0x20 : 0))
+
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+static const iomux_v3_cfg_t enet_ksz9021_gpio_pads[] = {
+	IOMUX_PAD_CTRL(RGMII_RD0__GPIO6_IO25, PULL_GP(STRAP_KSZ9021, 0)),
+	IOMUX_PAD_CTRL(RGMII_RD1__GPIO6_IO27, PULL_GP(STRAP_KSZ9021, 1)),
+	IOMUX_PAD_CTRL(RGMII_RD2__GPIO6_IO28, PULL_GP(STRAP_KSZ9021, 2)),
+	IOMUX_PAD_CTRL(RGMII_RD3__GPIO6_IO29, PULL_GP(STRAP_KSZ9021, 3)),
+	IOMUX_PAD_CTRL(RGMII_RX_CTL__GPIO6_IO24, PULL_GP(STRAP_KSZ9021, 4)),
+	IOMUX_PAD_CTRL(RGMII_RXC__GPIO6_IO30, PULL_GP(STRAP_KSZ9021, 4)),
+};
+
+static const iomux_v3_cfg_t enet_ksz9021_pads[] = {
+	IOMUX_PAD_CTRL(RGMII_RD0__RGMII_RD0, PULL_ENET(STRAP_KSZ9021, 0)),
+	IOMUX_PAD_CTRL(RGMII_RD1__RGMII_RD1, PULL_ENET(STRAP_KSZ9021, 1)),
+	IOMUX_PAD_CTRL(RGMII_RD2__RGMII_RD2, PULL_ENET(STRAP_KSZ9021, 2)),
+	IOMUX_PAD_CTRL(RGMII_RD3__RGMII_RD3, PULL_ENET(STRAP_KSZ9021, 3)),
+	IOMUX_PAD_CTRL(RGMII_RX_CTL__RGMII_RX_CTL, PULL_ENET(STRAP_KSZ9021, 4)),
+	IOMUX_PAD_CTRL(RGMII_RXC__RGMII_RXC, PULL_ENET(STRAP_KSZ9021, 5)),
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/eth-mx6sx.c u-boot-imx6/board/boundary/common/eth-mx6sx.c
--- u-boot-2017.07/board/boundary/common/eth-mx6sx.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/eth-mx6sx.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define GP_PHY_RD0	IMX_GPIO_NR(5, 0)
+#define GP_PHY_RD1	IMX_GPIO_NR(5, 1)
+#define GP_PHY_RD2	IMX_GPIO_NR(5, 2)
+#define GP_PHY_RD3	IMX_GPIO_NR(5, 3)
+#define GP_PHY_RX_CTL	IMX_GPIO_NR(5, 4)
+#define GP_PHY_RXC	IMX_GPIO_NR(5, 5)
+
+#define GP_PHY2_RD0	IMX_GPIO_NR(5, 12)
+#define GP_PHY2_RD1	IMX_GPIO_NR(5, 13)
+#define GP_PHY2_RD2	IMX_GPIO_NR(5, 14)
+#define GP_PHY2_RD3	IMX_GPIO_NR(5, 15)
+#define GP_PHY2_RX_CTL	IMX_GPIO_NR(5, 16)
+#define GP_PHY2_RXC	IMX_GPIO_NR(5, 17)
+
+#ifndef STRAP_AR8035
+#define STRAP_AR8035	((0x28 | (CONFIG_FEC_MXC_PHYADDR & 3)) | ((0x28 | ((CONFIG_FEC_MXC_PHYADDR + 1) & 3)) << 6))
+#endif
+
+#ifdef CONFIG_PHY_ATHEROS
+static const iomux_v3_cfg_t enet_ar8035_gpio_pads[] = {
+	IOMUX_PAD_CTRL(RGMII1_RD0__GPIO5_IO_0, PULL_GP(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(RGMII1_RD1__GPIO5_IO_1, PULL_GP(STRAP_AR8035, 1)),
+	IOMUX_PAD_CTRL(RGMII1_RD2__GPIO5_IO_2, PULL_GP(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(RGMII1_RD3__GPIO5_IO_3, PULL_GP(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(RGMII1_RX_CTL__GPIO5_IO_4, PULL_GP(STRAP_AR8035, 4)),
+	/* 1.8V(1)/1.5V select(0) */
+	IOMUX_PAD_CTRL(RGMII1_RXC__GPIO5_IO_5, PULL_GP(STRAP_AR8035, 5)),
+
+	IOMUX_PAD_CTRL(RGMII2_RD0__GPIO5_IO_12, PULL_GP(STRAP_AR8035, 6)),
+	IOMUX_PAD_CTRL(RGMII2_RD1__GPIO5_IO_13, PULL_GP(STRAP_AR8035, 7)),
+	IOMUX_PAD_CTRL(RGMII2_RD2__GPIO5_IO_14, PULL_GP(STRAP_AR8035, 8)),
+	/* MODE 2 is LED_100, Internal pull up */
+	IOMUX_PAD_CTRL(RGMII2_RD3__GPIO5_IO_15, PULL_GP(STRAP_AR8035, 9)),
+	IOMUX_PAD_CTRL(RGMII2_RX_CTL__GPIO5_IO_16, PULL_GP(STRAP_AR8035, 10)),
+	/* 1.8V(1)/1.5V select(0) */
+	IOMUX_PAD_CTRL(RGMII2_RXC__GPIO5_IO_17, PULL_GP(STRAP_AR8035, 11)),
+};
+
+static const iomux_v3_cfg_t enet_ar8035_pads[] = {
+	IOMUX_PAD_CTRL(RGMII1_RD0__ENET1_RX_DATA_0, PULL_ENET(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(RGMII1_RD1__ENET1_RX_DATA_1, PULL_ENET(STRAP_AR8035, 1)),
+	IOMUX_PAD_CTRL(RGMII1_RD2__ENET1_RX_DATA_2, PULL_ENET(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(RGMII1_RD3__ENET1_RX_DATA_3, PULL_ENET(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(RGMII1_RX_CTL__ENET1_RX_EN, PULL_ENET(STRAP_AR8035, 4)),
+	IOMUX_PAD_CTRL(RGMII1_RXC__ENET1_RX_CLK, PULL_ENET(STRAP_AR8035, 5)),
+
+	IOMUX_PAD_CTRL(RGMII2_RD0__ENET2_RX_DATA_0, PULL_ENET(STRAP_AR8035, 6)),
+	IOMUX_PAD_CTRL(RGMII2_RD1__ENET2_RX_DATA_1, PULL_ENET(STRAP_AR8035, 7)),
+	IOMUX_PAD_CTRL(RGMII2_RD2__ENET2_RX_DATA_2, PULL_ENET(STRAP_AR8035, 8)),
+	IOMUX_PAD_CTRL(RGMII2_RD3__ENET2_RX_DATA_3, PULL_ENET(STRAP_AR8035, 9)),
+	IOMUX_PAD_CTRL(RGMII2_RX_CTL__ENET2_RX_EN, PULL_ENET(STRAP_AR8035, 10)),
+	IOMUX_PAD_CTRL(RGMII2_RXC__ENET2_RX_CLK, PULL_ENET(STRAP_AR8035, 11)),
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/eth-mx7d.c u-boot-imx6/board/boundary/common/eth-mx7d.c
--- u-boot-2017.07/board/boundary/common/eth-mx7d.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/eth-mx7d.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define GP_PHY_RD0	IMX_GPIO_NR(7, 0)
+#define GP_PHY_RD1	IMX_GPIO_NR(7, 1)
+#define GP_PHY_RD2	IMX_GPIO_NR(7, 2)
+#define GP_PHY_RD3	IMX_GPIO_NR(7, 3)
+#define GP_PHY_RX_CTL	IMX_GPIO_NR(7, 4)
+#define GP_PHY_RXC	IMX_GPIO_NR(7, 5)
+
+#ifndef STRAP_AR8035
+#define STRAP_AR8035	(0x28 | (CONFIG_FEC_MXC_PHYADDR & 3))
+#endif
+
+#ifdef CONFIG_PHY_ATHEROS
+	/* really AR8031 for nitrogen7 */
+static const iomux_v3_cfg_t enet_ar8035_gpio_pads[] = {
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD0__GPIO7_IO0, PULL_GP(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD1__GPIO7_IO1, PULL_GP(STRAP_AR8035, 1)),
+	/* MODE - 1100 */
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD2__GPIO7_IO2, PULL_GP(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD3__GPIO7_IO3, PULL_GP(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RX_CTL__GPIO7_IO4, PULL_GP(STRAP_AR8035, 4)),
+	/* 1.8V(1)/1.5V select(0) */
+	IOMUX_PAD_CTRL(ENET1_RGMII_RXC__GPIO7_IO5, PULL_GP(STRAP_AR8035, 5)),
+};
+
+static const iomux_v3_cfg_t enet_ar8035_pads[] = {
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD0__ENET1_RGMII_RD0, PULL_ENET(STRAP_AR8035, 0)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD1__ENET1_RGMII_RD1, PULL_ENET(STRAP_AR8035, 1)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD2__ENET1_RGMII_RD2, PULL_ENET(STRAP_AR8035, 2)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RD3__ENET1_RGMII_RD3, PULL_ENET(STRAP_AR8035, 3)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL, PULL_ENET(STRAP_AR8035, 4)),
+	IOMUX_PAD_CTRL(ENET1_RGMII_RXC__ENET1_RGMII_RXC, PULL_ENET(STRAP_AR8035, 5)),
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/fan53526.c u-boot-imx6/board/boundary/common/fan53526.c
--- u-boot-2017.07/board/boundary/common/fan53526.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/fan53526.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+#include "bd_common.h"
+
+void fan53526_init(void)
+{
+	int ret;
+	u8 orig_i2c_bus;
+	u8 val8;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_FAN53526);
+#define I2C_ADDR_FAN53526	0x60
+	/*
+	 * Vout = 600mV + n * 6.25 mV
+	 * n = (Vout - 600000uV) / 6250uV
+	 */
+	/* max is 1.39375 V */
+	/*
+	 * VDD_ARM_IN and VDD_SOC_IN must be at least 125 mV higher than the
+	 * LDO Output Set Point for correct voltage regulation
+	 */
+	val8 = DIV_ROUND_UP((1393750 - 600000), 6250);
+	val8 |= 0x80;	/* Enable output */
+	ret = i2c_write(I2C_ADDR_FAN53526, 0, 1, &val8, 1);
+	if (ret < 0)
+		printf("%s: i2c write(0) failed(%d)\n", __func__, ret);
+	ret = i2c_write(I2C_ADDR_FAN53526, 1, 1, &val8, 1);
+	if (ret < 0)
+		printf("%s: i2c write(1) failed(%d)\n", __func__, ret);
+
+	i2c_set_bus_num(orig_i2c_bus);
+}
diff -Nru u-boot-2017.07/board/boundary/common/Kconfig u-boot-imx6/board/boundary/common/Kconfig
--- u-boot-2017.07/board/boundary/common/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/Kconfig	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,48 @@
+config CMD_KBD
+	bool "Enable KBD cmd"
+	default y
+
+config MAX77823
+	bool
+	default y if TARGET_CID
+	default y if TARGET_CID_TAB
+	default y if TARGET_H4
+	default y if TARGET_LS
+	default y if TARGET_NITROGEN6_SCM
+	default y if TARGET_VP
+
+config OTG_CHARGER
+	bool "otg_charger"
+	depends on MAX77823
+	default y if TARGET_CID
+
+config I2C_BUS_MAX77823
+	int
+	depends on MAX77823
+	default 3 if TARGET_NITROGEN6_SCM
+	default 2
+
+config FAN53526
+	bool
+	default y if TARGET_CID
+	default y if TARGET_CID_TAB
+
+config I2C_BUS_FAN53526
+	int
+	depends on FAN53526
+	default 2
+
+config SPLASH_SCREEN_PREPARE
+	bool "Prepare splash screen for display"
+	default y if SPLASH_SCREEN
+
+config DEFAULT_HITACHI_HVGA
+	bool "hvga display as default"
+
+config TAMPER
+	bool "Enable tamper detection gpio"
+
+config CMD_OTG_CABLE
+	bool "Enable otg cable detection"
+	depends on ARCH_MX6
+	default y
diff -Nru u-boot-2017.07/board/boundary/common/Makefile u-boot-imx6/board/boundary/common/Makefile
--- u-boot-2017.07/board/boundary/common/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/Makefile	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := eth.o bd_common.o
+obj-$(CONFIG_CMD_KBD)  += cmd_kbd.o
+obj-$(CONFIG_MAX77823)  += max77823.o
+obj-$(CONFIG_FAN53526)  += fan53526.o
+obj-$(CONFIG_CMD_OTG_CABLE)  += cmd_otg_cable.o
diff -Nru u-boot-2017.07/board/boundary/common/max77823.c u-boot-imx6/board/boundary/common/max77823.c
--- u-boot-2017.07/board/boundary/common/max77823.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/max77823.c	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "bd_common.h"
+
+#define I2C_ADDR_FUELGAUGE	0x36
+#define MAX77823_REG_VCELL	0x09
+
+#define I2C_ADDR_CHARGER	0x69
+
+#define MAX77823_CHG_DETAILS_00	0xB3
+#define MAX77823_CHG_DETAILS_01	0xB4
+#define MAX77823_CHG_CNFG_00	0xB7
+#define MAX77823_CHG_CNFG_01	0xB8
+#define MAX77823_CHG_CNFG_02	0xB9
+#define MAX77823_CHG_CNFG_06	0xBD
+#define MAX77823_CHG_CNFG_09	0xC0
+#define MAX77823_CHG_CNFG_10	0xC1
+#define MAX77823_CHG_CNFG_11	0xC2
+#define MAX77823_CHG_CNFG_12	0xC3
+
+#define CHG_CNFG_00_CHG_MASK	BIT(0)
+#define CHG_CNFG_00_OTG_MASK	BIT(1)
+#define CHG_CNFG_00_BUCK_MASK	BIT(2)
+#define CHG_CNFG_00_BOOST_MASK	BIT(3)
+
+#ifdef CONFIG_OTG_CHARGER
+
+#define ANADIG_USB1_CHRG_DETECT_CHK_CONTACT	BIT(18)
+#define ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B	BIT(19)
+#define ANADIG_USB1_CHRG_DETECT_EN_B		BIT(20)
+
+#define ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT	BIT(0)
+#define ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED	BIT(1)
+
+static int set_max_chrgin_current(int i2c_addr)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 val;
+	u8 chgin = 0x3;
+	int i = 0;
+	int ilim_max = 3;
+
+	/* turn on comparator, change threshold to 4.6V*/
+	writel(BIT(20) | 6, &mxc_ccm->usb1_vbus_detect_set);
+	writel(1, &mxc_ccm->usb1_vbus_detect_clr);
+
+	/* Enable charger detect, contact detect */
+	writel(ANADIG_USB1_CHRG_DETECT_EN_B, &mxc_ccm->usb1_chrg_detect_clr);
+	writel(ANADIG_USB1_CHRG_DETECT_CHK_CONTACT |
+		ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		&mxc_ccm->usb1_chrg_detect_set);
+
+	i2c_read(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+	chgin &= 0x7f;
+
+	/* determine type of cable */
+	/* Check if plug is connected */
+	while (1) {
+		val = readl(&mxc_ccm->usb1_chrg_det_stat);
+		if (val & ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT) {
+			break;
+		} else {
+			i++;
+			if (i >= 10) {
+				ilim_max = 0x78;
+				break;
+			}
+			val = readl(&mxc_ccm->usb1_vbus_det_stat);
+			if (!(val & 0x0e)) {
+				if (chgin == 0xf)
+					return chgin;
+				chgin = 0x0f;
+				i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+			}
+			udelay(5000);
+		}
+	}
+	writel(ANADIG_USB1_CHRG_DETECT_CHK_CONTACT |
+		ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		&mxc_ccm->usb1_chrg_detect_clr);
+
+	if (val & ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT) {
+		udelay(100000);
+		val = readl(&mxc_ccm->usb1_chrg_det_stat);
+		if (val & ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED) {
+			ilim_max = 0x78;	/* Charger */
+		} else {
+			ilim_max = 0xf;		/* Standard downstream port */
+		}
+
+	}
+	/* Disable charger detect */
+	writel(ANADIG_USB1_CHRG_DETECT_EN_B |
+		ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,
+		&mxc_ccm->usb1_chrg_detect_set);
+
+	if (chgin > ilim_max) {
+		chgin = ilim_max;
+		i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+		udelay(5000);
+	}
+	/* Increase chgin until vbus is invalid */
+	while (chgin < ilim_max) {
+		val = readl(&mxc_ccm->usb1_vbus_det_stat);
+		if (!(val & 0x0e)) {
+			if (chgin == 0xf)
+				return chgin;
+			chgin = 0xf;	/* 500 mA source */
+			i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+			udelay(1000);
+			continue;
+		}
+		if (!(val & 8) || (chgin > 0x78))
+			break;
+		chgin++;
+		i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+	}
+	/* Decrease chgin until vbus is valid */
+	while (1) {
+		val = readl(&mxc_ccm->usb1_vbus_det_stat);
+		if (!(val & 0x0e)) {
+			chgin = 0xf;	/* 500 mA source */
+			i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+			return chgin;
+		}
+		if ((val & 8) || (chgin <= 3))
+			break;
+		chgin--;
+		i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+		udelay(100);
+	}
+	if (chgin != ilim_max) {
+		if (chgin > 3) {
+			chgin--;
+			i2c_write(i2c_addr, MAX77823_CHG_CNFG_09, 1, &chgin, 1);
+		}
+	}
+	return chgin;
+}
+#endif
+
+static void power_check(void)
+{
+	int ret;
+	u8 val8;
+	u8 buf[2];
+
+#ifdef CONFIG_OTG_CHARGER
+	int chgin = set_max_chrgin_current(I2C_ADDR_CHARGER);
+	if (chgin >= 0x5a) {	/* 3.0 amps */
+		val8 = 0x5;	/* enable charging mode */
+		i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00, 1, &val8, 1);
+		return;
+	}
+#else
+	ret = i2c_read(I2C_ADDR_CHARGER, MAX77823_CHG_DETAILS_00, 1, &val8, 1);
+	if (!ret) {
+		/* check for VBUS is valid */
+		if (((val8 >> 5) & 0x3) == 3) {
+			val8 = 0x5;	/* enable charging mode */
+			i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00, 1, &val8, 1);
+			return;
+		}
+	}
+#endif
+	/* chgin cannot supply enough, check battery */
+	val8 = 0x4;	/* disable charging mode */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00, 1, &val8, 1);
+	udelay(5000);	/* 5 ms to let voltage stabilize */
+
+	ret = i2c_read(I2C_ADDR_FUELGAUGE, MAX77823_REG_VCELL, 1, buf, 2);
+	val8 = 0x5;	/* enable charging mode */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00, 1, &val8, 1);
+
+	if (!ret) {
+		u32 v = (buf[1] << 8) | buf[0];
+
+		v = (v >> 3) * 625;
+		printf("battery voltage = %d uV\n", v);
+		if (v < 3000000) {
+			printf("voltage = %d uV too low, powering off\n", v);
+			board_poweroff();
+		}
+	} else {
+		printf("error reading battery voltage\n");
+	}
+}
+
+/*
+ * Output:
+ *  0 - done charging,
+ *  1 - charging,
+ *  -1 : can't charge
+ */
+int max77823_is_charging(void)
+{
+	int ret;
+	u8 buf[2];
+	u8 orig_i2c_bus;
+	u8 chg_dtls;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_MAX77823);
+
+	ret = i2c_read(I2C_ADDR_CHARGER, MAX77823_CHG_DETAILS_01, 1, buf, 2);
+	if (!ret) {
+		chg_dtls = buf[0] & 0xf;
+		if ((chg_dtls >= 1) && (chg_dtls <= 3))
+			ret = 1;
+		else if (chg_dtls == 4)
+			ret = 0;
+		else
+			ret = -1;
+	} else {
+		ret = -1;
+	}
+	i2c_set_bus_num(orig_i2c_bus);
+	return ret;
+}
+
+void max77823_init(void)
+{
+	u8 orig_i2c_bus;
+	u8 val8;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_MAX77823);
+#ifndef CONFIG_OTG_CHARGER
+	val8 = 0x78;	/* 4.0A source */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_09, 1, &val8, 1);
+#endif
+	val8 = 0x26;	/* .76 A source */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_10, 1, &val8, 1);
+	val8 = 0x0c;	/* Protection allow 0xb9 write */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_06, 1, &val8, 1);
+	val8 = 0x2a;	/* 2.1A charge */
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_02, 1, &val8, 1);
+
+	/*
+	 * fast charge timer disable
+	 * Switching frequency 2 MHz
+	 * restart threshold 100mV below CHG_CV_PRM
+	 */
+	val8 = (0 << 0) | (0x01 << 3) | (0x0 << 4);
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_01, 1, &val8, 1);
+	/*
+	 * enable charging from chgin(otg)/wcin,
+	 * VCHGIN_REG - bits[4:3]
+	 * 0 - Vchgin_reg = 4.5V, Vchgin_uvlo=4.3V
+	 * 1 - Vchgin_reg = 4.9V, Vchgin_uvlo=4.7V
+	 * 2 - Vchgin_reg = 5.0V, Vchgin_uvlo=4.8V
+	 * 3 - Vchgin_reg = 5.1V, Vchgin_uvlo=4.9V
+	 */
+	val8 = 0x67 | (0 << 3);
+	i2c_write(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_12, 1, &val8, 1);
+	power_check();
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+static int max77823_update_reg(int i2c_addr, int reg, int val, int mask)
+{
+	unsigned char buf[4];
+	int ret;
+
+	ret = i2c_read(i2c_addr, reg, 1, buf, 1);
+	if (!ret) {
+		buf[0] &= ~mask;
+		buf[0] |= val;
+		i2c_write(i2c_addr, reg, 1, buf, 1);
+		ret = buf[0];
+	}
+	return ret;
+}
+
+static int max77823_write_reg(int i2c_addr, int reg, int val)
+{
+	unsigned char buf[4];
+	int ret;
+
+	buf[0] = val;
+	ret = i2c_write(i2c_addr, reg, 1, buf, 1);
+	return ret;
+}
+
+static void max77823_otg_enable(void)
+{
+	/* Disable charging from CHRG_IN when we are supplying power */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_12,
+			0, 0x20);
+
+	/* Update CHG_CNFG_11 to 0x54(5.1V) */
+	max77823_write_reg(I2C_ADDR_CHARGER,
+		MAX77823_CHG_CNFG_11, 0x54);
+
+	/* OTG on, boost on */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00,
+		CHG_CNFG_00_OTG_MASK | CHG_CNFG_00_BOOST_MASK,
+		CHG_CNFG_00_OTG_MASK | CHG_CNFG_00_BOOST_MASK);
+}
+
+static void max77823_otg_disable(void)
+{
+	/* chrg on, OTG off, boost on/off, (buck on) */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00,
+		CHG_CNFG_00_CHG_MASK | CHG_CNFG_00_BUCK_MASK,
+		CHG_CNFG_00_CHG_MASK | CHG_CNFG_00_BUCK_MASK |
+			CHG_CNFG_00_OTG_MASK | CHG_CNFG_00_BOOST_MASK);
+
+	mdelay(50);
+
+	/* Allow charging from CHRG_IN when we are not supplying power */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_12,
+			0x20, 0x20);
+}
+
+void max77823_otg_power(int enable)
+{
+	u8 orig_i2c_bus;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_MAX77823);
+	if (enable)
+		max77823_otg_enable();
+	else
+		max77823_otg_disable();
+
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+static void max77823_boost_enable(void)
+{
+	/* Update CHG_CNFG_11 to 0x54(5.1V) */
+	max77823_write_reg(I2C_ADDR_CHARGER,
+		MAX77823_CHG_CNFG_11, 0x54);
+
+	/* charger on, otg off, buck on, boost on */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00,
+		CHG_CNFG_00_BOOST_MASK, CHG_CNFG_00_BOOST_MASK);
+}
+
+static void max77823_boost_disable(void)
+{
+	/* chrg on, OTG off, buck on, boost off */
+	max77823_update_reg(I2C_ADDR_CHARGER, MAX77823_CHG_CNFG_00,
+		0, CHG_CNFG_00_BOOST_MASK);
+}
+
+void max77823_boost_power(int enable)
+{
+	u8 orig_i2c_bus;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_MAX77823);
+	if (enable)
+		max77823_boost_enable();
+	else
+		max77823_boost_disable();
+
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+void max77834_power_check(void)
+{
+	u8 orig_i2c_bus;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(CONFIG_I2C_BUS_MAX77823);
+	power_check();
+	i2c_set_bus_num(orig_i2c_bus);
+}
diff -Nru u-boot-2017.07/board/boundary/common/mx6/1000mhz_256mx16.cfg u-boot-imx6/board/boundary/common/mx6/1000mhz_256mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/1000mhz_256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/1000mhz_256mx16.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Kingston D2516EC4BXGGB-U/(DDR3-1600)
+ *  NOTE: tFAW and tRRD must change to use a part slower than 1333
+ * RANK 0, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 0 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 0 rank + 3 width = 31 = 2 GB
+ *
+ * MT41K512M16TNA-125:E
+ * RANK 1, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 1 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 1 rank + 3 width = 32 = 4 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 500.21M DDR clock = .50021G = 1999.1ps/clocks
+ * 13125ps / 1999.1ps/clocks = 6.56 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x82		(260000/1999.1) = 130.05 = 131(0x83) clocks
+ * tXS:0x87		(270000/1999.1) = 135.06 = 136(0x88) clocks
+ * tXP:b'011'		(6000/1999.1) = 3.001 = 4 clocks
+ * tXPDLL:b'1100'	(24000/1999.1) = 12.005 = 13(0x0d) clocks
+ * tFAW:b'11001'	(50000/1999.1) = 25.011 = 26(0x1a) clocks
+ * tCL:b'0100'		(13125/1999.1) = 6.565 = 7 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x82877994
+/*
+ * tRCD:b'110'		(13125/1999.1) = 6.565 = 7 clocks
+ * tRP:b'110'		(13125/1999.1) = 6.565 = 7 clocks
+ * tRC:b'11001'		(50625/1999.1) = 25.323 = 26(0x1a) clocks
+ * tRAS:b'10010'	(37500/1999.1) = 18.758 = 19(0x13) clocks
+ * tRPA:b'1'		(tRP[+1]) = 8 clocks
+ * b'000'
+ * tWR:b'111'		(15000/1999.1) = 7.503 = 8 clocks
+ * tMRD:b'1011'		(max 4,12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'100'		(tCL-1) = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB328F64
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/1999.1)) = 3.751 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/1999.1)) = 3.751 = 4 clocks
+ * tRRD:b'101'		MAX(4, (10000/1999.1)) = 5.002 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DD
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x87	 	(270000/1999.1) = 135.061 = 136(0x88) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x00871023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x50000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x90000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000027, 0x00000047)
+/*
+ * RANK 0: BUS_WIDTH 32: 15 rows, 1 CS, 0x84190000
+ * RANK 0: BUS_WIDTH 64: 15 rows, 1 CS, 0x841a0000
+ * RANK 1: BUS_WIDTH 32: 15 rows, 2 CS, 0xc4190000
+ * RANK 1: BUS_WIDTH 64: 15 rows, 2 CS, 0xc41a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x84190000, 0x841a0000, 0xc4190000, 0xc41a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032	/* MR2, tCWL=6, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0408803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031	/* MR1 Rtt=RZQ/2 OD=RZQ/7*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00428039)
+/* A12 - 1 dll on(fast exit), CAS 7 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030	/* MR0 FastExit, tWR=8, Dll reset, tCL=7  */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x19308038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/1066mhz_128mx16.cfg u-boot-imx6/board/boundary/common/mx6/1066mhz_128mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/1066mhz_128mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/1066mhz_128mx16.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Hynix: H5TC2G63FFR-PBA (DDR3L-1600 11-11-11)
+ * Hynix: H5TQ2G63FFR-H9C (DDR3-1333 9-9-9)
+ * Micron: MT41K128M16JT-125 IT:K (DDR3-1600)
+ * RANK 0, BUS_WIDTH 32
+ * 14 row + 3 bank + 10 col + 0 rank + 2 width = 29 = 512 MB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 14 row + 3 bank + 10 col + 0 rank + 3 width = 30 = 1 GB
+ *
+ * RANK 1, BUS_WIDTH 32
+ * 14 row + 3 bank + 10 col + 1 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 14 row + 3 bank + 10 col + 1 rank + 3 width = 31 = 2 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 528M DDR clock = .528G = 1893.9ps/clocks
+ * 13125ps / 1893.9ps/clocks = 6.93 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x55		(161351/1893.9) = 85.19  86(0x56) clocks
+ * tXS:0x5a		(172300/1893.9) = 90.97 = 91(0x5b) clocks
+ * tXP:b'011'		(6000/1893.9) = 3.168 = 4 clocks
+ * tXPDLL:b'1100'	(24000/1893.9) = 12.672 = 13(0xd) clocks
+ * tFAW:b'10111'	(45000/1893.9) = 23.760 = 24(0x18) clocks
+ * tCL:b'0100'		(13125/1893.9) = 6.930 = 7 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x555A7974
+/*
+ * tRCD:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRP:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRC:b'11010'		(50625/1893.9) = 26.731 = 27(0x1b) clocks
+ * tRAS:b'10011'	(37500/1893.9) = 19.800 = 20(0x14) clocks
+ * tRPA:b'1'		(tRP[+1]) = 8 clocks
+ * b'000'
+ * tWR:b'111'		(15000/1893.9) = 7.920 = 8 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'100'		(tCL-1) = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tRRD:b'011'		MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x5a		(172000/1893.9) = 90.8 = 91(0x5b) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x005A1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x30000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x50000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000017, 0x00000027)
+/*
+ * RANK 0: BUS_WIDTH 32: 14 rows, 1 CS, 0x83190000
+ * RANK 0: BUS_WIDTH 64: 14 rows, 1 CS, 0x831a0000
+ * RANK 1: BUS_WIDTH 32: 14 rows, 2 CS, 0xc3190000
+ * RANK 1: BUS_WIDTH 64: 14 rows, 2 CS, 0xc31a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x83190000, 0x831a0000, 0xc3190000, 0xc31a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032	/* MR2, tCWL=6, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0408803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031	/* MR1 Rtt=RZQ/2 OD=RZQ/7*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00428039)
+/* A12 - 1 dll on(fast exit), CAS 7 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030	/* MR0 FastExit, tWR=8, Dll reset, tCL=7  */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x19308038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 4 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/1066mhz_256mx16.cfg u-boot-imx6/board/boundary/common/mx6/1066mhz_256mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/1066mhz_256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/1066mhz_256mx16.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Kingston D2516EC4BXGGB-U/(DDR3-1600)
+ * Kingston D2516EC4BXGGBI-U/(DDR3-1600)
+ * Micron MT41K256M16HA-125 IT:E (DDR3-1600)
+ *  NOTE: tFAW and tRRD must change to use a part slower than 1333
+ * RANK 0, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 0 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 0 rank + 3 width = 31 = 2 GB
+ *
+ * MT41K512M16TNA-125:E
+ * RANK 1, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 1 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 1 rank + 3 width = 32 = 4 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 528M DDR clock = .528G = 1893.9ps/clocks
+ * 13125ps / 1893.9ps/clocks = 6.93 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x89		(260000/1893.9) = 137.283 = 138(0x8a) clocks
+ * tXS:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) clocks
+ * tXP:b'011'		(6000/1893.9) = 3.168 = 4 clocks
+ * tXPDLL:b'1100'	(24000/1893.9) = 12.672 = 13(0xd) clocks
+ * tFAW:b'10111'	(45000/1893.9) = 23.760 = 24(0x18) clocks
+ * tCL:b'0100'		(13125/1893.9) = 6.930 = 7 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E7974
+/*
+ * tRCD:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRP:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRC:b'11010'		(50625/1893.9) = 26.731 = 27(0x1b) clocks
+ * tRAS:b'10011'	(37500/1893.9) = 19.800 = 20(0x14) clocks
+ * tRPA:b'1'		(tRP[+1]) = 8 clocks
+ * b'000'
+ * tWR:b'111'		(15000/1893.9) = 7.920 = 8 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'100'		(tCL-1) = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tRRD:b'011'		MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x50000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x90000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000027, 0x00000047)
+/*
+ * RANK 0: BUS_WIDTH 32: 15 rows, 1 CS, 0x84190000
+ * RANK 0: BUS_WIDTH 64: 15 rows, 1 CS, 0x841a0000
+ * RANK 1: BUS_WIDTH 32: 15 rows, 2 CS, 0xc4190000
+ * RANK 1: BUS_WIDTH 64: 15 rows, 2 CS, 0xc41a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x84190000, 0x841a0000, 0xc4190000, 0xc41a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032	/* MR2, tCWL=6, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0408803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031	/* MR1 Rtt=RZQ/2 OD=RZQ/7*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00428039)
+/* A12 - 1 dll on(fast exit), CAS 7 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030	/* MR0 FastExit, tWR=8, Dll reset, tCL=7  */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x19308038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/1066mhz_256mx16-hynix.cfg u-boot-imx6/board/boundary/common/mx6/1066mhz_256mx16-hynix.cfg
--- u-boot-2017.07/board/boundary/common/mx6/1066mhz_256mx16-hynix.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/1066mhz_256mx16-hynix.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * RANK 0, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 0 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 0 rank + 3 width = 31 = 2 GB
+ *
+ * Hynix H5TC8G63AMR-PBA (DDR3-1600 11-11-11)
+ * Micro MT41K512M16TNA-125:E (DDR3L-1600)
+ * Hynix is the slower part of the 2.
+ * RANK 1, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 1 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 1 rank + 3 width = 32 = 4 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 528M DDR clock = .528G = 1893.9ps/clocks
+ * 13125ps / 1893.9ps/clocks = 6.93 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x89		(260000/1893.9) = 137.283 = 138(0x8a) clocks
+ * tXS:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) clocks
+ * tXP:b'011'		(6000/1893.9) = 3.168 = 4 clocks
+ * tXPDLL:b'1100'	(24000/1893.9) = 12.672 = 13(0xd) clocks
+ * tFAW:b'11010'	27(0x1b) clocks
+ * tCL:b'0100'		(13125/1893.9) = 6.930 = 7 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E79A4
+/*
+ * tRCD:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRP:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRC:b'11010'		(50625/1893.9) = 26.731 = 27(0x1b) clocks
+ * tRAS:b'10011'	(37500/1893.9) = 19.800 = 20(0x14) clocks
+ * tRPA:b'1'		(tRP[+1]) = 8 clocks
+ * b'000'
+ * tWR:b'111'		(15000/1893.9) = 7.920 = 8 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'100'		(tCL-1) = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/1893.9) = 3.960 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/1893.9) = 3.960 = 4 clocks
+ * tRRD:b'101'		6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00dd
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x50000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x90000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000027, 0x00000047)
+/*
+ * RANK 0: BUS_WIDTH 32: 15 rows, 1 CS, 0x84190000
+ * RANK 0: BUS_WIDTH 64: 15 rows, 1 CS, 0x841a0000
+ * RANK 1: BUS_WIDTH 32: 15 rows, 2 CS, 0xc4190000
+ * RANK 1: BUS_WIDTH 64: 15 rows, 2 CS, 0xc41a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x84190000, 0x841a0000, 0xc4190000, 0xc41a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032	/* MR2, tCWL=6, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0408803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031	/* MR1 Rtt=RZQ/2 OD=RZQ/7*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00428039)
+/* A12 - 1 dll on(fast exit), CAS 7 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030	/* MR0 FastExit, tWR=8, Dll reset, tCL=7  */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x19308038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/1066mhz_512mx16.cfg u-boot-imx6/board/boundary/common/mx6/1066mhz_512mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/1066mhz_512mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/1066mhz_512mx16.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Micron MT41K512M16HA-107 IT:A (DDR3-1866)
+ * RANK 0, BUS_WIDTH 32
+ * 16 row + 3 bank + 10 col + 0 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 16 row + 3 bank + 10 col + 0 rank + 3 width = 32 = 4 GB
+ *
+ * RANK 1, BUS_WIDTH 32
+ * 16 row + 3 bank + 10 col + 1 rank + 2 width = 32 = 4 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 16 row + 3 bank + 10 col + 1 rank + 3 width = 33 = 8 GB, too much
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 528M DDR clock = .528G = 1893.9ps/clocks
+ * 13125ps / 1893.9ps/clocks = 6.93 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+#if (RANK == 1) && (BUS_WIDTH == 64)
+#error RANK and BUS_WIDTH setting gives too much memory
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x89		(260000/1893.9) = 137.283 = 138(0x8a) clocks
+ * tXS:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) clocks
+ * tXP:b'011'		(6000/1893.9) = 3.168 = 4 clocks
+ * tXPDLL:b'1100'	(24000/1893.9) = 12.672 = 13(0xd) clocks
+ * tFAW:b'11010' 	(50000/1893.9) = 26.400 = 27(0x1b) clocks
+ * tCL:b'0100'		(13125/1893.9) = 6.930 = 7 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E79a4
+/*
+ * tRCD:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRP:b'110'		(13125/1893.9) = 6.930 = 7 clocks
+ * tRC:b'11010'		(50625/1893.9) = 26.731 = 27(0x1b) clocks
+ * tRAS:b'10011'	(37500/1893.9) = 19.800 = 20(0x14) clocks
+ * tRPA:b'1'		(tRP[+1]) = 8 clocks
+ * b'000'
+ * tWR:b'111'		(15000/1893.9) = 7.920 = 8 clocks
+ * tMRD:b'1011'		(max 4,12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'100'		(tCL-1) = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/1893.9)) = 3.960 = 4 clocks
+ * tRRD:b'101'		MAX(4, (10000/1893.9)) =  5.280 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DD
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x8e		(270000/1893.9) = 142.563 = 143(0x8f) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x90000000-1
+ * RANK 0, BUS_WIDTH 64: end of CS0 US 0xffffffff
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000047, 0x0000007f)
+/*
+ * RANK 0: BUS_WIDTH 32: 16 rows, 1 CS, 0x85190000
+ * RANK 0: BUS_WIDTH 64: 16 rows, 1 CS, 0x851a0000
+ * RANK 1: BUS_WIDTH 32: 16 rows, 2 CS, 0xc5190000
+ * RANK 1: BUS_WIDTH 64: 16 rows, 2 CS, 0xc51a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x85190000, 0x851a0000, 0xc5190000, 0xc51a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032	/* MR2, tCWL=6, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0408803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031	/* MR1 Rtt=RZQ/2 OD=RZQ/7*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00428039)
+/* A12 - 1 dll on(fast exit), CAS 7 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030	/* MR0 FastExit, tWR=8, Dll reset, tCL=7  */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x19308038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 64 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00003800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/800mhz_128mx16.cfg u-boot-imx6/board/boundary/common/mx6/800mhz_128mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/800mhz_128mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/800mhz_128mx16.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013-2018 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * Hynix: H5TC2G63FFR-PBA (DDR3L-1600 11-11-11)
+ * Micron: MT41K128M16JT-125 IT:K (DDR3-1600)
+ * RANK 0, BUS_WIDTH 32
+ * 14 row + 3 bank + 10 col + 0 rank + 2 width = 29 = 512 MB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 14 row + 3 bank + 10 col + 0 rank + 3 width = 30 = 1 GB
+ *
+ * RANK 1, BUS_WIDTH 32
+ * 14 row + 3 bank + 10 col + 1 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 14 row + 3 bank + 10 col + 1 rank + 3 width = 31 = 2 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 396M DDR clock = .396G = 2525.2ps/clocks
+ * 13125ps / 2525ps/clocks = 5.198 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x3f		(160000/2525) = 63.36 = 64(0x40) clocks
+ * tXS:0x43		(170000/2525) = 67.32 = 68(0x44) clocks
+ * tXP:b'010'		(7500/2525) = 2.97 = 3 clocks
+ * tXPDLL:b'1001'	(24000/2525) = 9.505 = 10(0x0a) clocks
+ * tFAW:b'10011'	(50000/2525) = 19.80 = 20(0x14) clocks
+ * tCL:b'0011'		(13125/2525) = 5.198 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x3f435333
+/*
+ * tRCD:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRP:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRC:b'10100'		(50625/2525) = 20.049 = 21(0x15) clocks
+ * tRAS:b'01110'	(37500/2525) = 14.851 = 15(0x0f) clocks
+ * tRPA:b'1'		(tRP[+1]) = 7 clocks
+ * b'000'
+ * tWR:b'101'		(15000/2525) = 5.940 = 6 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'011'		(tCL-1) = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb68e8b63
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tRRD:b'011'		MAX(4, (5000/2525)) = 1.980 = 4 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x43		(170000/2525) = 67.32 = 68(0x44) clocks
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x30000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x50000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000017, 0x00000027)
+/*
+ * RANK 0: BUS_WIDTH 32: 14 rows, 1 CS, 0x83190000
+ * RANK 0: BUS_WIDTH 64: 14 rows, 1 CS, 0x831a0000
+ * RANK 1: BUS_WIDTH 32: 14 rows, 2 CS, 0xc3190000
+ * RANK 1: BUS_WIDTH 64: 14 rows, 2 CS, 0xc31a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x83190000, 0x831a0000, 0xc3190000, 0xc31a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2, tCWL=5, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0400803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 Rtt=RZQ/4 OD=RZQ/6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00048039)
+/* A12 - 1 dll on(fast exit), tCL 6 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x15208030	/* MR0 FastExit, tWR=6(b'010'), Dll reset, tCL=6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x15208038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 4 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/800mhz_256mx16.cfg u-boot-imx6/board/boundary/common/mx6/800mhz_256mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/800mhz_256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/800mhz_256mx16.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Kingston D2516EC4BXGGB-U/(DDR3-1600)
+ * Kingston D2516EC4BXGGBI-U/(DDR3-1600)
+ * Micron MT41K256M16HA-125 IT:E (DDR3-1600)
+ *  NOTE: tFAW and tRRD must change to use a part slower than 1333
+ * RANK 0, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 0 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 0 rank + 3 width = 31 = 2 GB
+ *
+ * MT41K512M16TNA-125:E
+ * RANK 1, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 1 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 1 rank + 3 width = 32 = 4 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 396M DDR clock = .396G = 2525.2ps/clocks
+ * 13125ps / 2525ps/clocks = 5.198 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002d
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x66		(260000/2525) = 102.97 = 103(0x67) clocks
+ * tXS:0x6a		(270000/2525) = 106.93 = 107(0x6b) clocks
+ * tXP:b'010'		(6000/2525) = 2.376 = 3 clocks
+ * tXPDLL:b'1001'	(24000/2525) = 9.505 = 10(0x0a) clocks
+ * tFAW:b'10011'	(50000/2525) = 19.802 = 20(0x14) clocks
+ * tCL:b'0011'		(13125/2525) = 5.198 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x666a5333
+/*
+ * tRCD:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRP:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRC:b'10100'		(50625/2525) = 20.049 = 21(0x15) clocks
+ * tRAS:b'01110'	(37500/2525) = 14.851 = 15(0x0f) clocks
+ * tRPA:b'1'		(tRP[+1]) = 7 clocks
+ * b'000'
+ * tWR:b'101'		(15000/2525) = 5.940 = 6 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'011'		(tCL-1) = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb68e8b63
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tRRD:b'011'		MAX(4, (10000/2525)) = 3.960 = 4 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x6a		(270000/2525) = 106.93 = 107(0x6b) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x006a1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556d
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x50000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x90000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000027, 0x00000047)
+/*
+ * RANK 0: BUS_WIDTH 32: 15 rows, 1 CS, 0x84190000
+ * RANK 0: BUS_WIDTH 64: 15 rows, 1 CS, 0x841a0000
+ * RANK 1: BUS_WIDTH 32: 15 rows, 2 CS, 0xc4190000
+ * RANK 1: BUS_WIDTH 64: 15 rows, 2 CS, 0xc41a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x84190000, 0x841a0000, 0xc4190000, 0xc41a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2, tCWL=5, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0400803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 Rtt=RZQ/4 OD=RZQ/6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00048039)
+/* A12 - 1 dll on(fast exit), tCL 6 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x15208030	/* MR0 FastExit, tWR=6(b'010'), Dll reset, tCL=6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x15208038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/800mhz_256mx16-hynix.cfg u-boot-imx6/board/boundary/common/mx6/800mhz_256mx16-hynix.cfg
--- u-boot-2017.07/board/boundary/common/mx6/800mhz_256mx16-hynix.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/800mhz_256mx16-hynix.cfg	2018-08-27 21:35:36.940805046 +0300
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * RANK 0, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 0 rank + 2 width = 30 = 1 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 0 rank + 3 width = 31 = 2 GB
+ *
+ * Hynix H5TC8G63AMR-PBA (DDR3-1600 11-11-11)
+ * Micron MT41K512M16TNA-125:E (DDR3L-1600)
+ * Hynix is the slower part of the 2.
+ * RANK 1, BUS_WIDTH 32
+ * 15 row + 3 bank + 10 col + 1 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 15 row + 3 bank + 10 col + 1 rank + 3 width = 32 = 4 GB
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 396M DDR clock = .396G = 2525.2ps/clocks
+ * 13125ps / 2525ps/clocks = 5.198 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002d
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x66		(260000/2525) = 102.97 = 103(0x67) clocks
+ * tXS:0x6a		(270000/2525) = 106.93 = 107(0x6b) clocks
+ * tXP:b'010'		(6000/2525) = 2.376 = 3 clocks
+ * tXPDLL:b'1001'	(24000/2525) = 9.505 = 10(0x0a) clocks
+ * tFAW:b'10100'	(27clocks @1066 speed) = 50657ps, (50657/2525) = 20.062 = 21(0x15) clocks
+ * tCL:b'0011'		(13125/2525) = 5.198 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x666a5343
+/*
+ * tRCD:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRP:b'101'		(13125/2525) = 5.198 = 6 clocks
+ * tRC:b'10100'		(50625/2525) = 20.049 = 21(0x15) clocks
+ * tRAS:b'01110'	(37500/2525) = 14.851 = 15(0x0f) clocks
+ * tRPA:b'1'		(tRP[+1]) = 7 clocks
+ * b'000'
+ * tWR:b'101'		(15000/2525) = 5.940 = 6 clocks
+ * tMRD:b'1011'		(max tMRD 4, tMOD 12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'011'		(tCL-1) = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb68e8b63
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/2525)) = 2.970 = 4 clocks
+ * tRRD:b'100'		MAX(4, (11258/2525)) =  4.458 = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00dc
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x6a		(270000/2525) = 106.93 = 107(0x6b) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x006a1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556d
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x50000000-1
+ * RANK 0/1, BUS_WIDTH 64: end of CS0 US 0x90000000-1
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000027, 0x00000047)
+/*
+ * RANK 0: BUS_WIDTH 32: 15 rows, 1 CS, 0x84190000
+ * RANK 0: BUS_WIDTH 64: 15 rows, 1 CS, 0x841a0000
+ * RANK 1: BUS_WIDTH 32: 15 rows, 2 CS, 0xc4190000
+ * RANK 1: BUS_WIDTH 64: 15 rows, 2 CS, 0xc41a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x84190000, 0x841a0000, 0xc4190000, 0xc41a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2, tCWL=5, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0400803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 Rtt=RZQ/4 OD=RZQ/6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00048039)
+/* A12 - 1 dll on(fast exit), tCL 6 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x15208030	/* MR0 FastExit, tWR=6(b'010'), Dll reset, tCL=6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x15208038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 32 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/800mhz_512mx16.cfg u-boot-imx6/board/boundary/common/mx6/800mhz_512mx16.cfg
--- u-boot-2017.07/board/boundary/common/mx6/800mhz_512mx16.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/800mhz_512mx16.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Micron MT41K512M16HA-107 IT:A (DDR3-1866)
+ * RANK 0, BUS_WIDTH 32
+ * 16 row + 3 bank + 10 col + 0 rank + 2 width = 31 = 2 GB
+ *
+ * RANK 0, BUS_WIDTH 64
+ * 16 row + 3 bank + 10 col + 0 rank + 3 width = 32 = 4 GB
+ *
+ * RANK 1, BUS_WIDTH 32
+ * 16 row + 3 bank + 10 col + 1 rank + 2 width = 32 = 4 GB
+ *
+ * RANK 1, BUS_WIDTH 64
+ * 16 row + 3 bank + 10 col + 1 rank + 3 width = 33 = 8 GB, too much
+ *
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 400M DDR clock = .4G = 2500 ps/clocks
+ * 13125ps / 2500ps/clocks = 5.25 clocks
+ */
+
+#ifndef RANK
+#error please define RANK
+#endif
+#ifndef BUS_WIDTH
+#error please define BUS_WIDTH
+#endif
+#if (RANK == 1) && (BUS_WIDTH == 64)
+#error RANK and BUS_WIDTH setting gives too much memory
+#endif
+
+#if RANK == 1
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank1
+#define R_RANK1(reg, rank1) DATA 4, reg, rank1
+#else
+#define REG_RANK(reg, rank0, rank1) DATA 4, reg, rank0
+#define R_RANK1(reg, rank1)
+#endif
+
+#if BUS_WIDTH == 64
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw64
+#define R_BW_64(reg, bw64) DATA 4, reg, bw64
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw64, r1_bw64)
+#else
+#define REG_BW(reg, bw32, bw64) DATA 4, reg, bw32
+#define R_BW_64(reg, bw64)
+#define R_RK_BW(reg, r0_bw32, r0_bw64, r1_bw32, r1_bw64) REG_RANK(reg, r0_bw32, r1_bw32)
+#endif
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002d
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * tRFC:0x68		(260000/2499) = 104.041 = 105(0x69) clocks
+ * tXS:0x6c		(270000/2499) = 108.043 = 109(0x6d) clocks
+ * tXP:b'010'		(6000/2499) = 2.401 = 3 clocks
+ * tXPDLL:b'1001'	(24000/2499) = 9.603 = 10(0xa) clocks
+ * tFAW:b'10100'	(50000/2499) = 20.008 = 21(0x15) clocks
+ * tCL:b'0011'		(13125/2499) = 5.252 = 6 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x686c5343
+/*
+ * tRCD:b'101'		(13125/2499) = 5.252 = 6 clocks
+ * tRP:b'101'		(13125/2499) = 5.252 = 6 clocks
+ * tRC:b'10100'		(50625/2499) = 20.258 = 21(0x15) clocks
+ * tRAS:b'01111'	(37500/2499) = 15.006 = 16(0x10) clocks
+ * tRPA:b'1'		(tRP[+1]) = 7 clocks
+ * b'000'
+ * tWR:b'110'		(15000/2499) = 6.002 = 7 clocks
+ * tMRD:b'1011'		(max 4,12) = 12(0xc) clocks
+ * b'00'
+ * tCWL:b'011'		(tCL-1) = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb68f8d63
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011'		MAX(4, (7500/2499)) = 3.001 = 4 clocks
+ * tWTR:same bank b'011' MAX(4, (7500/2499)) = 3.001 = 4 clocks
+ * tRRD:b'100'		MAX(4, (10000/2499)) = 4.002 = 5 clocks
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00dc
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x0f9f26d2
+/*
+ * tXPR:0x6c	(270000/2499) = 108.04 = 109(0x6d) cycles
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x006c1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556d
+/*
+ * RANK 0/1, BUS_WIDTH 32: end of CS0 US 0x90000000-1
+ * RANK 0, BUS_WIDTH 64: end of CS0 US 0xffffffff
+ */
+REG_BW(MX6_MMDC_P0_MDASP, 0x00000047, 0x0000007f)
+/*
+ * RANK 0: BUS_WIDTH 32: 16 rows, 1 CS, 0x85190000
+ * RANK 0: BUS_WIDTH 64: 16 rows, 1 CS, 0x851a0000
+ * RANK 1: BUS_WIDTH 32: 16 rows, 2 CS, 0xc5190000
+ * RANK 1: BUS_WIDTH 64: 16 rows, 2 CS, 0xc51a0000
+ */
+R_RK_BW(MX6_MMDC_P0_MDCTL, 0x85190000, 0x851a0000, 0xc5190000, 0xc51a0000)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2, tCWL=5, RZQ/2 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0400803a)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x0000803b)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 Rtt=RZQ/4 OD=RZQ/6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x00048039)
+/* A12 - 1 dll on(fast exit), tCL 6 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x17208030	/* MR0 FastExit, tWR=7, Dll reset, tCL=6*/
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x17208038)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040	/* ZQ calibration */
+R_RANK1(MX6_MMDC_P0_MDSCR, 0x04008048)
+/* force a calibration */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+R_BW_64(MX6_MMDC_P1_MPZQHWCTRL, 0xa1390003)
+/*
+ * 8 refreshes at a time, at 64 Khz
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00003800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+R_BW_64(MX6_MMDC_P1_MPODTCTRL, 0x00022227)
+
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, MX6_MMDC_P0_MPDGCTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, MX6_MMDC_P0_MPDGCTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPDGCTRL0, MX6_MMDC_P1_MPDGCTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPDGCTRL1, MX6_MMDC_P1_MPDGCTRL1_VAL)
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, MX6_MMDC_P0_MPRDDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPRDDLCTL, MX6_MMDC_P1_MPRDDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, MX6_MMDC_P0_MPWRDLCTL_VAL
+R_BW_64(MX6_MMDC_P1_MPWRDLCTL, MX6_MMDC_P1_MPWRDLCTL_VAL)
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, MX6_MMDC_P0_MPWLDECTRL0_VAL
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, MX6_MMDC_P0_MPWLDECTRL1_VAL
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL0, MX6_MMDC_P1_MPWLDECTRL0_VAL)
+R_BW_64(MX6_MMDC_P1_MPWLDECTRL1, MX6_MMDC_P1_MPWLDECTRL1_VAL)
+
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+R_BW_64(MX6_MMDC_P1_MPMUR0, 0x00000800)
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/common/mx6/clocks.cfg u-boot-imx6/board/boundary/common/mx6/clocks.cfg
--- u-boot-2017.07/board/boundary/common/mx6/clocks.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/clocks.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+#ifdef CONFIG_MX6QP
+/* set IPU AXI-id1 Qos=0x1 AXI-id0/2/3 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x77177717
+DATA 4, MX6_IOMUXC_GPR7, 0x77177717
+#else
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+#endif
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, CCM_CCOSR, 0x000000fb
diff -Nru u-boot-2017.07/board/boundary/common/mx6/ddr-setup.cfg u-boot-imx6/board/boundary/common/mx6/ddr-setup.cfg
--- u-boot-2017.07/board/boundary/common/mx6/ddr-setup.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/mx6/ddr-setup.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 32 bits	x16/x32
+ */
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_CAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_RAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_RESET, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
+
+/* (differential input) */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+/* (differential input) */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+/* disable ddr pullups */
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/*
+ * MDMISC	mirroring-off	interleaved (row/bank/col)
+ */
+#ifndef WALAT
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00011740
+#elif WALAT!=0
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00011740
+#else
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00001740
+#endif
+
+/*
+ * MDSCR	con_req
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+
+#ifdef CONFIG_MX6QP
+/* NoC DDR configuration register set */
+DATA 4 0x00bb0008 0x00000004
+DATA 4 0x00bb000c 0x2891E41A
+DATA 4 0x00bb0038 0x00000564
+DATA 4 0x00bb0014 0x00000040
+DATA 4 0x00bb0028 0x00000020
+DATA 4 0x00bb002c 0x00000020
+
+/* MMDCx_MAARCR - bit 26 - Disable all MMDC arbitration and reordering controls */
+DATA 4 0x021b0400 0x14420000
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/padctrl.h u-boot-imx6/board/boundary/common/padctrl.h
--- u-boot-2017.07/board/boundary/common/padctrl.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/padctrl.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifdef CONFIG_MX6SX
+#include "padctrl-mx6sx.h"
+#elif defined(CONFIG_MX7D)
+#include "padctrl-mx7d.h"
+#elif defined(CONFIG_MX51)
+#include "padctrl-mx51.h"
+#else
+#include "padctrl-mx6.h"
+#endif
diff -Nru u-boot-2017.07/board/boundary/common/padctrl-mx51.h u-boot-imx6/board/boundary/common/padctrl-mx51.h
--- u-boot-2017.07/board/boundary/common/padctrl-mx51.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/padctrl-mx51.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define OUTPUT_40OHM		(PAD_CTL_DSE_MED)
+
+#define PAD_CTRL_ENET		(PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_DSE_MED | PAD_CTL_HYS)
+
+#define PAD_CTRL_INPUT	(PAD_CTL_DSE_MED | PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN		(PAD_CTL_PUS_100K_DOWN |	\
+	PAD_CTL_DSE_MED | PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN_OUTPUT	(PAD_CTL_PUS_100K_DOWN |	\
+	PAD_CTL_DSE_MED | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP		(PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_DSE_MED | PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP_OUTPUT	(PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_DSE_MED | PAD_CTL_SRE_SLOW)
+
+
diff -Nru u-boot-2017.07/board/boundary/common/padctrl-mx6.h u-boot-imx6/board/boundary/common/padctrl-mx6.h
--- u-boot-2017.07/board/boundary/common/padctrl-mx6.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/padctrl-mx6.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define INPUT_FLOAT	(PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define OUTPUT_40OHM	(PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define PAD_CTRL_ENET_MDC (PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+#define PAD_CTRL_ENET_MDIO (PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define PAD_CTRL_ENET_RX	(PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+#define PAD_CTRL_ENET_RX_DN	(PAD_CTL_PUS_100K_DOWN | PAD_CTRL_ENET_RX)
+#define PAD_CTRL_ENET_RX_UP	(PAD_CTL_PUS_100K_UP | PAD_CTRL_ENET_RX)
+
+#define PAD_CTRL_ENET_TX	(PAD_CTRL_ENET_RX)
+
+#define WEAK_PULLDN	(PAD_CTL_PUS_100K_DOWN |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN_OUTPUT (PAD_CTL_PUS_100K_DOWN |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP_OUTPUT (PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_SLOW)
diff -Nru u-boot-2017.07/board/boundary/common/padctrl-mx6sx.h u-boot-imx6/board/boundary/common/padctrl-mx6sx.h
--- u-boot-2017.07/board/boundary/common/padctrl-mx6sx.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/padctrl-mx6sx.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define OUTPUT_40OHM (PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define PAD_CTRL_ENET_MDC	(PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define PAD_CTRL_ENET_MDIO	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define PAD_CTRL_ENET_RX  (PAD_CTL_SPEED_HIGH | \
+	PAD_CTL_DSE_48ohm | PAD_CTL_SRE_FAST)
+
+#define PAD_CTRL_ENET_RX_DN	(PAD_CTL_PUS_100K_DOWN | PAD_CTRL_ENET_RX)
+#define PAD_CTRL_ENET_RX_UP	(PAD_CTL_PUS_100K_UP | PAD_CTRL_ENET_RX)
+#define PAD_CTRL_ENET_TX	(PAD_CTRL_ENET_RX)
+
+#define WEAK_PULLDN		(PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN_OUTPUT	(PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP		(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP_OUTPUT	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
+
diff -Nru u-boot-2017.07/board/boundary/common/padctrl-mx7d.h u-boot-imx6/board/boundary/common/padctrl-mx7d.h
--- u-boot-2017.07/board/boundary/common/padctrl-mx7d.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/common/padctrl-mx7d.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define PAD_CTRL_ENET_MDC	(PAD_CTL_DSE_3P3V_32OHM)
+#define PAD_CTRL_ENET_MDIO	(PAD_CTL_DSE_3P3V_32OHM)
+
+#define PAD_CTRL_ENET_RX	(PAD_CTL_DSE_3P3V_49OHM)
+#define PAD_CTRL_ENET_RX_DN	(PAD_CTL_PUS_PD100KOHM | PAD_CTRL_ENET_RX)
+#define PAD_CTRL_ENET_RX_UP	(PAD_CTL_PUS_PU100KOHM | PAD_CTRL_ENET_RX)
+
+#define PAD_CTRL_ENET_TX	(PAD_CTL_DSE_3P3V_49OHM)
+
+#define WEAK_PULLUP	(PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN_OUTPUT (PAD_CTL_PUS_PD100KOHM | PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP_OUTPUT (PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_SRE_SLOW)
+
diff -Nru u-boot-2017.07/board/boundary/dash/dash.c u-boot-imx6/board/boundary/dash/dash.c
--- u-boot-2017.07/board/boundary/dash/dash.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/dash/dash.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static iomux_v3_cfg_t const init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19,  WEAK_PULLUP),
+
+	/* USB otg power */
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, OUTPUT_40OHM),
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, OUTPUT_40OHM),
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, OUTPUT_40OHM),
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, OUTPUT_40OHM),
+	IOMUX_PAD_CTRL(GPIO_6__GPIO1_IO06, OUTPUT_40OHM),
+
+	/* gpio_Keys - Button assignments for J14 */
+	/* Menu */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),	/* LVDS_BCKLT_EN */
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),	/* LVDS_PWR_EN */
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK,   USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD,   USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK,   USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD,   USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06,    WEAK_PULLUP),
+
+	/* wl1271 pads  */
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, ISL1208 RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 MPU-9150, BH1780GLI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - LVDS EDID on J4 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+	VD_WSVGA(LVDS, fbp_detect_i2c, 2, 0x38),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+
+static const unsigned short gpios_out_low[] = {
+	/* Disable wl1271 */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_REG_USBOTG,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BACKLIGHT_LVDS,
+	GPIRQ_WL1271_WL,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/dash/dash_q1g.cfg u-boot-imx6/board/boundary/dash/dash_q1g.cfg
--- u-boot-2017.07/board/boundary/dash/dash_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/dash/dash_q1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/dash/Kconfig u-boot-imx6/board/boundary/dash/Kconfig
--- u-boot-2017.07/board/boundary/dash/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/dash/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,20 @@
+if TARGET_DASH
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "dash"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "dash"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/dash/MAINTAINERS u-boot-imx6/board/boundary/dash/MAINTAINERS
--- u-boot-2017.07/board/boundary/dash/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/dash/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+DASH BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/dash/
+F:	include/configs/dash.h
+F:	configs/dash_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/dash/Makefile u-boot-imx6/board/boundary/dash/Makefile
--- u-boot-2017.07/board/boundary/dash/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/dash/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := dash.o
diff -Nru u-boot-2017.07/board/boundary/eo/eo.c u-boot-imx6/board/boundary/eo/eo.c
--- u-boot-2017.07/board/boundary/eo/eo.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/eo.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 pads */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),
+#define GP_ENET_PHY_INT		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),	/* Micrel RGMII Phy Interrupt */
+
+	/* gpio_keys */
+#define GP_BUTTON1		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_BUTTON2		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_BUTTON3		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_BUTTON4		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_BUTTON5		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+
+#define GP_POE_GP1		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_POE_GP2		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+
+	/* I2C1 - rv4162(rtc), */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* I2C2 - J12(touch connector), */
+#define GPIRQ_I2C2_TOUCH	IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* I2C3 - pcie, MPR21 cap touch, MMA8652(accelerometer) */
+#define GP_I2C3_PCIE_EN		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+#define GPIRQ_CAP_TOUCH		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),
+#define GPIRQ_ACC1		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GPIRQ_ACC2		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* LVDS, J6 */
+#define GP_LVDS_EN		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),	/* J6 - pin 7, DISP0_CONTRAST */
+
+	/* PWM1 - AD5211 pwm input for J58 backlight */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, OUTPUT_40OHM),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN_OUTPUT),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN_OUTPUT),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 pads */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - micro SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* uses both lvds connectors */
+	VD_1080P60(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_I2C3_PCIE_EN,
+	GP_LVDS_EN,
+	GP_BACKLIGHT_LVDS,
+	GP_PCIE_RESET,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ENET_PHY_INT,
+	GP_BUTTON1,
+	GP_BUTTON2,
+	GP_BUTTON3,
+	GP_BUTTON4,
+	GP_BUTTON5,
+	GP_POE_GP1,
+	GP_POE_GP2,
+	GP_TP71,
+	GPIRQ_I2C2_TOUCH,
+	GPIRQ_CAP_TOUCH,
+	GPIRQ_ACC1,
+	GPIRQ_ACC2,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"b1",		GP_BUTTON1,	'1', 1},
+	{"b2",		GP_BUTTON2,	'2', 1},
+	{"b3",		GP_BUTTON3,	'3', 1},
+	{"b4",		GP_BUTTON4,	'4', 1},
+	{"b5",		GP_BUTTON5,	'5', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/eo/eo.cfg u-boot-imx6/board/boundary/eo/eo.cfg
--- u-boot-2017.07/board/boundary/eo/eo.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/eo.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/eo/eo_duallite.cfg u-boot-imx6/board/boundary/eo/eo_duallite.cfg
--- u-boot-2017.07/board/boundary/eo/eo_duallite.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/eo_duallite.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/eo/Kconfig u-boot-imx6/board/boundary/eo/Kconfig
--- u-boot-2017.07/board/boundary/eo/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,28 @@
+if TARGET_EO
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "eo"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "eo"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+config PRINT_TIME_RV4162
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/eo/MAINTAINERS u-boot-imx6/board/boundary/eo/MAINTAINERS
--- u-boot-2017.07/board/boundary/eo/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,6 @@
+EO BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/eo/
+F:	include/configs/eo.h
+F:	configs/eo_defconfig
diff -Nru u-boot-2017.07/board/boundary/eo/Makefile u-boot-imx6/board/boundary/eo/Makefile
--- u-boot-2017.07/board/boundary/eo/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/eo/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,6 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+obj-y  := eo.o
diff -Nru u-boot-2017.07/board/boundary/h/6x_bootscript.txt u-boot-imx6/board/boundary/h/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/h/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/6x_bootscript.txt	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,19 @@
+setenv bootargs enable_wait_mode=off ldb=sep0
+setenv nextcon 0;
+setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+setenv nextcon 1
+setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,INNOLUX-WVGA,if=RGB666
+setenv nextcon 2
+setenv fbmem "fbmem=28M,10M";
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs $bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0
+${fs}load ${dtype} ${disk}:1 10800000 /boot/uImage
+&& ${fs}load ${dtype} ${disk}:1 12800000 /boot/uramdisk.img
+&& bootm 10800000 12800000 ;
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/h/h.c u-boot-imx6/board/boundary/h/h.c
--- u-boot-2017.07/board/boundary/h/h.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/h.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	       \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |	       \
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 pads */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS		IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET		IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+
+	/* i2c mux pads */
+#define GP_I2C_EN_MIPI		IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLDN),	/* mipi I2C enable */
+#define GP_I2C_EN_LVDS0		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLDN),	/* LVDS0 I2C enable */
+#define GP_I2C_EN_LVDS1		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLDN),	/* LVDS1 I2C enable */
+#define GP_I2C_EN_RTC		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN),	/* RTC I2C enable */
+#define GP_I2C_EN_AR1020	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN),	/* AR1020 I2C enable */
+
+	/* Broadcom bcm4330 pads */
+#define GP_WL_EN		IMX_GPIO_NR(6, 7)	/* NANDF_CLE - active high */
+        IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM),	/* wlan regulator enable */
+#define GP_WL_WAKE_IRQ		IMX_GPIO_NR(6, 14)	/* NANDF_CS1 - active low */
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),	/* wlan wake irq */
+#define GP_WL_BT_REG_EN		IMX_GPIO_NR(6, 15)	/* NANDF_CS2 - active high */
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, OUTPUT_40OHM),	/* bt regulator enable */
+#define GP_WL_BT_WAKE_IRQ	IMX_GPIO_NR(6, 16)	/* NANDF_CS3 - active low */
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, OUTPUT_40OHM),	/* bt wake irq */
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, OUTPUT_40OHM),		/* bt wake */
+#define GP_WL_BT_RESET		IMX_GPIO_NR(6, 8)	/* NANDF_ALE - active low */
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, OUTPUT_40OHM),	/* bt reset */
+#define GP_WL_CLK_REQ_IRQ	IMX_GPIO_NR(6, 9)	/* NANDF_WP_B - active low */
+
+#define GP_RGB_BACKLIGHT_PWM		IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+#define GP_LVDS0_BACKLIGHT_PWM		IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+#define GP_LVDS1_BACKLIGHT_PWM		IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+#define GP_RGB_MIRROR_H			IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),	/* DI0 display left/right mirror */
+#define GP_RGB_MIRROR_V			IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),	/* DI0 display up/down mirror */
+#define GP_LVDS0_12V_5V_BL_SELECT	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLDN),	/* LVDS0 12v/5v select, 0 - 5v, 1 - 12v */
+#define GP_RGB_LVDS1_12V_5V_BL_SELECT	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),	/* rgb/LVDS1 12v/5v select, 0 - 5v, 1 - 12v */
+#define GP_12V_POWER_EN			IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLDN),	/* 12v power enable */
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USB */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),	/* Hub reset */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, USDHC_PAD_CTRL), /* USBOTG ID pin */
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLUP),	/* usbotg power */
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),	/* USBOTG OC pin */
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),	/* Rev1 usb power */
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* Rev1 usb power */
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLUP),	/* Rev1 usb power */
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP), /* CD */
+
+	/* USDHC4  */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP), /* CD */
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	2
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_cd = GP_USDHC4_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_RGB_BACKLIGHT_PWM, enable);
+}
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS0_BACKLIGHT_PWM, enable);
+	gpio_direction_output(GP_LVDS1_BACKLIGHT_PWM, enable ^ 1);
+}
+
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS0_BACKLIGHT_PWM, enable ^ 1);
+	gpio_direction_output(GP_LVDS1_BACKLIGHT_PWM, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VD_1024_600(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_INNOLUX_WVGA(LVDS2, fbp_detect_i2c, 2, 0x48),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	/* Disable wl1271 */
+	GP_WL_EN,
+	GP_WL_BT_REG_EN,
+	GP_WL_BT_RESET,
+	GP_RGB_MIRROR_V,
+	GP_LVDS0_12V_5V_BL_SELECT,
+	GP_RGB_LVDS1_12V_5V_BL_SELECT,
+	GP_12V_POWER_EN,
+	GP_I2C_EN_MIPI,
+	GP_I2C_EN_LVDS0,
+	GP_I2C_EN_LVDS1,
+	GP_I2C_EN_RTC,
+	GP_I2C_EN_AR1020,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_RGB_MIRROR_H,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_WL_WAKE_IRQ,
+	GP_WL_BT_WAKE_IRQ,
+	GP_WL_CLK_REQ_IRQ,
+	GP_RGB_BACKLIGHT_PWM,
+	GP_LVDS0_BACKLIGHT_PWM,
+	GP_LVDS1_BACKLIGHT_PWM,
+	GP_USDHC3_CD,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/h/hquad2g.cfg u-boot-imx6/board/boundary/h/hquad2g.cfg
--- u-boot-2017.07/board/boundary/h/hquad2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/hquad2g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/h/hsolo1g.cfg u-boot-imx6/board/boundary/h/hsolo1g.cfg
--- u-boot-2017.07/board/boundary/h/hsolo1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/hsolo1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* BOM removed, not supported */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/h/Kconfig u-boot-imx6/board/boundary/h/Kconfig
--- u-boot-2017.07/board/boundary/h/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,20 @@
+if TARGET_H
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "h"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "h"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/h/MAINTAINERS u-boot-imx6/board/boundary/h/MAINTAINERS
--- u-boot-2017.07/board/boundary/h/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,8 @@
+H BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/h/
+F:	include/configs/h.h
+F:	configs/hsolo1g_defconfig
+F:	configs/hquad2g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/h/Makefile u-boot-imx6/board/boundary/h/Makefile
--- u-boot-2017.07/board/boundary/h/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := h.o
diff -Nru u-boot-2017.07/board/boundary/h4/h4.c u-boot-imx6/board/boundary/h4/h4.c
--- u-boot-2017.07/board/boundary/h4/h4.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/h4.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,469 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "spi_display.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_PUS_22K_UP | 			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX3 */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* AUDMUX5 - from TC358743 hdmi input */
+	IOMUX_PAD_CTRL(KEY_ROW1__AUD5_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D24__AUD5_RXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__AUD5_RXC, AUD_PAD_CTRL),
+
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),	/* for spi displays */
+
+	/* GPIO_KEYS assignments for J14 */
+#define GP_GPIOKEY_POWER		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_GPIOKEY_1		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+#define GP_GPIOKEY_2		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+#define GP_GPIOKEY_3		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLUP),
+#define GP_VBUS_GOOD		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),
+#define GP_SPARE		IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+
+#define GP_MAIN_POWER_EN	IMX_GPIO_NR(1, 19)		/* low is on */
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* hdmi cec - tc358743 and micro hdmi connector */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* hog  - test points */
+#define GP_TP4		IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+#define GP_TP5		IMX_GPIO_NR(4, 17)
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+#define GP_TP6		IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+#define GP_TP7		IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP8		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLUP),
+#define GP_TP9		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),
+#define GP_TP10		IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+
+	/* i2c1_wm8960 - Amplifier Mute */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+
+	/* i2c2 TC3587 mipi hdmi input */
+#define GP_TC3587_RESET		IMX_GPIO_NR(6, 1)
+	IOMUX_PAD_CTRL(CSI0_DAT15__GPIO6_IO01, WEAK_PULLDN),
+#define GPIRQ_TC3587		IMX_GPIO_NR(6, 0)
+	IOMUX_PAD_CTRL(CSI0_DAT14__GPIO6_IO00, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),
+	/* micro hdmi power detect */
+#define GP_HDMI_POWER_DET	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN),
+
+
+	/* i2c3 - J8 */
+#define GPIRQ_J8	IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+#define GP_J8_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+
+	/* I2C3 MAX77818 */
+#define GP_MAX77818_INOKB	IMX_GPIO_NR(3, 4)	/* INOKB, WCHG_VALID_INT */
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_MAX77818_WCINOKB	IMX_GPIO_NR(3, 5)	/* WCINOKB, WCHG_INT */
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_MAX77818_INTB	IMX_GPIO_NR(3, 6)	/* INTB, CHG_INT */
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+
+	/* lcd */
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN),
+#define GP_SPI_DISPLAY_STANDBY	IMX_GPIO_NR(3, 31)
+	IOMUX_PAD_CTRL(EIM_D31__GPIO3_IO31, WEAK_PULLUP),
+
+	/* PWM1 - Backlight on RGB connector: J15, pin 37 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM3  */
+#define GP_BACKLIGHT_SPI	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* reg_usbh1_vbus */
+#define GP_REG_5V		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLDN),
+
+	/* reg_usbh1_vbus */
+#define GP_REG_USBH1		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART4  */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Murata */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* murata wifi */
+#define GPIRQ_WLAN		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+#define GP_WLAN_CLK_REQ		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	gpio_set_value(GP_REG_5V, 1);
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	gpio_set_value(port ? GP_REG_USBH1 : GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			enable_spi_rgb(di);
+#endif
+		mdelay(100); /* let panel sync up before enabling backlight */
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		gpio_direction_output(GP_BACKLIGHT_SPI, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		gpio_direction_output(GP_BACKLIGHT_SPI, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+}
+
+
+static const struct display_info_t displays[] = {
+#ifdef CONFIG_MXC_SPI_DISPLAY
+	VD_A030JN01_YUV720(LCD, NULL, 1, 1),
+	VD_A030JN01_UPS051(LCD, NULL, 1, 2),
+	VD_AUO_G050(LCD, NULL, 1, 0),
+#endif
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_MAIN_POWER_EN,
+	GP_TC3587_RESET,
+	GP_J8_RESET,
+	GP_SPI_DISPLAY_RESET,
+	GP_SPI_DISPLAY_STANDBY,
+	GP_BACKLIGHT_RGB,
+	GP_BACKLIGHT_SPI,
+	GP_REG_5V,
+	GP_REG_USBH1,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_CS,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_1,
+	GP_GPIOKEY_2,
+	GP_GPIOKEY_3,
+	GP_VBUS_GOOD,
+	GP_SPARE,
+	GP_TP4,
+	GP_TP5,
+	GP_TP6,
+	GP_TP7,
+	GP_TP8,
+	GP_TP9,
+	GP_TP10,
+	GPIRQ_TC3587,
+	GP_HDMI_POWER_DET,
+	GPIRQ_J8,
+	GP_MAX77818_INOKB,
+	GP_MAX77818_WCINOKB,
+	GP_MAX77818_INTB,
+	GP_WLAN_CLK_REQ,
+	GPIRQ_WLAN,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
+
+	/* Doing both gpio1:19 and pmic_req makes the board not turn on again */
+//	gpio_set_value(GP_MAIN_POWER_EN, 1);
+	writel(0x60, &snvs->lpcr);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	gpio_set_value(GP_REG_5V, 1);
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/h4/h4.cfg u-boot-imx6/board/boundary/h4/h4.cfg
--- u-boot-2017.07/board/boundary/h4/h4.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/h4.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/h4/Kconfig u-boot-imx6/board/boundary/h4/Kconfig
--- u-boot-2017.07/board/boundary/h4/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,20 @@
+if TARGET_H4
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "h4"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "h4"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/h4/MAINTAINERS u-boot-imx6/board/boundary/h4/MAINTAINERS
--- u-boot-2017.07/board/boundary/h4/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/h4/
+F:	include/configs/h4.h
+F:	configs/h4_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/h4/Makefile u-boot-imx6/board/boundary/h4/Makefile
--- u-boot-2017.07/board/boundary/h4/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := h4.o
+obj-$(CONFIG_MXC_SPI_DISPLAY) += spi_display.o
diff -Nru u-boot-2017.07/board/boundary/h4/spi_display.c u-boot-imx6/board/boundary/h4/spi_display.c
--- u-boot-2017.07/board/boundary/h4/spi_display.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/spi_display.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,473 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#define DEBUG
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/video.h>
+#include <spi.h>
+#include "spi_display.h"
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define SPI_MOSI_R_PAD_CTRL	SPI_PAD_CTRL | PAD_CTL_ODE | PAD_CTL_PUS_22K_UP
+
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(3, 29)
+#define GP_SPI_DISPLAY_STANDBY	IMX_GPIO_NR(3, 31)
+
+static iomux_v3_cfg_t const spi_mosi_r_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_MOSI_R_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_mosi_w_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_pad[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT11__ECSPI2_SS0, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_gpio_pad[] = {
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),
+};
+
+static int AUO_G050_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = 0x20;
+			buf[1] = reg >> 8;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			buf[0] = 0;
+			buf[1] = reg;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			if (!len) {
+				debug("spi: reg:%04x\n", reg);
+				break;
+			}
+			buf[0] = 0x40;
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%04x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int AUO_G050_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = 0x20;
+	buf[1] = reg >> 8;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0;
+	buf[1] = reg;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0xC0;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%04x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	udelay(2);
+	return rbuf[1];
+}
+
+#define A(reg, cnt) (reg >> 8), (reg & 0xff), cnt
+
+static u8 AUO_G050_display_init_cmds[] = {
+/* Display Mode Setting */
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x00,
+	A(0xb100, 2), 0x0c, 0x00,
+	A(0xbc00, 3), 0x05, 0x05, 0x05,
+	A(0xb700, 2), 0x22, 0x22,
+	A(0xb800, 4), 0x01, 0x03, 0x03, 0x03,
+	A(0xc803, 1), 0x96,
+	A(0xc805, 1), 0x96,
+	A(0xc807, 1), 0x96,
+	A(0xc809, 1), 0x96,
+	A(0xc80b, 1), 0x2a,
+	A(0xc80c, 1), 0x2a,
+	A(0xc80f, 1), 0x2a,
+	A(0xc810, 1), 0x2a,
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x01,
+	A(0xb900, 3), 0x34, 0x34, 0x34,
+	A(0xba00, 3), 0x14, 0x14, 0x14,
+	A(0xbe00, 2), 0x00, 0x8c,
+	A(0xb000, 3), 0x00, 0x00, 0x00,
+	A(0xb800, 3), 0x24, 0x24, 0x24,
+	A(0xbc00, 3), 0x00, 0x88, 0x01,
+	A(0xbd00, 3), 0x00, 0x88, 0x01,
+	A(0xd100, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd200, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd300, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd400, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd500, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd600, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0x1100, 0),	/* exit sleep mode, wait 120 ms */
+	A(0, 0)
+};
+
+static u8 AUO_G050_display_on_cmds[] = {
+	A(0x2900, 0),
+	A(0, 0)
+};
+
+/* *************************************************** */
+
+static int A030JN01_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+		int bits = 16;
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = reg + (reg & 0x40);
+			if (len)
+				buf[1] = *cmds++;
+			else
+				bits = 8;
+			ret = spi_xfer(spi, bits, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%02x %02x\n", reg, buf[1]);
+			udelay(2);
+			if (!len)
+				break;
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int A030JN01_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = (reg + (reg & 0x40)) | 0x40;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%02x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	return rbuf[1];
+}
+
+static u8 A030JN01_display_YUV720_init_cmds[] = {
+/* Display Mode Setting */
+	A(4, 2), 0x6b, 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_UPS051_init_cmds[] = {
+	A(5, 1), 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_on_cmds[] = {
+	A(0, 0)
+};
+
+struct spi_display_info {
+	int mode;
+	int speed_r;
+	int speed_w;
+	int reset_active_low;
+	u8 *init_cmds;
+	u8 *on_cmds;
+	int (*spi_write_rtn)(struct spi_slave *spi, u8 *cmds);
+	int (*spi_read_rtn)(struct spi_slave *spi, int reg);
+};
+
+struct spi_display_info spi_di[] = {
+	{ .mode = SPI_MODE_0, .speed_r = 10000, .speed_w = 1000000, .reset_active_low = 1,
+			.init_cmds = AUO_G050_display_init_cmds, .on_cmds = AUO_G050_display_on_cmds,
+			.spi_write_rtn = AUO_G050_spi_write_rtn, .spi_read_rtn = AUO_G050_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_YUV720_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_UPS051_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+};
+
+const struct display_info_t *g_dev;
+
+/*
+ * Return 1 for successful detection of display
+ */
+int detect_spi(struct display_info_t const *dev)
+{
+	return 1;
+}
+
+static void init_spi(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	unsigned reset_gpio = GP_SPI_DISPLAY_RESET;
+	unsigned standby_gpio = GP_SPI_DISPLAY_STANDBY;
+	struct spi_display_info *di = &spi_di[dev->addr];
+	int reset_val = di->reset_active_low ? 0 : 1;
+
+	debug("%s\n", __func__);
+	gpio_direction_output(standby_gpio, 0);
+	gpio_direction_output(cs_gpio, 1);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	gpio_direction_output(reset_gpio, reset_val);
+	udelay(200);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	mdelay(1);
+	gpio_direction_output(standby_gpio, 1);
+	mdelay(200);
+}
+
+void enable_spi_rgb(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret;
+	struct spi_display_info *di = &spi_di[dev->addr];
+
+	g_dev = dev;
+	init_spi(dev);
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_w_pads);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	ret = di->spi_write_rtn(spi, di->init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	mdelay(200);
+	ret = di->spi_write_rtn(spi, di->on_cmds);
+	if (ret) {
+		printf("%s: Failed to display_on_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	ret = 1;
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return;
+}
+
+static int do_spid(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	int arg = 2;
+	uint reg;
+	u8 buf[80];
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_w_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	if (argc > ARRAY_SIZE(buf) - 3)
+		argc = ARRAY_SIZE(buf) - 3;
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	buf[0] = reg >> 8;
+	buf[1] = reg;
+	buf[2] = argc - arg;
+	while (arg < argc) {
+		buf[arg + 1] = simple_strtoul(argv[arg], NULL, 16);
+		arg++;
+	}
+	arg++;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	di->spi_write_rtn(spi, buf);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spid, 70, 0, do_spid,
+	"write cmd, data to spi display",
+	"reg16 [byte]"
+);
+
+static int do_spidr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	uint reg;
+	int val;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_r_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_r, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	val = di->spi_read_rtn(spi, reg);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	printf("spidr: reg:0x%x = 0x%x\n", reg, val);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spidr, 70, 0, do_spidr,
+	"read spi display register",
+	"reg16"
+);
diff -Nru u-boot-2017.07/board/boundary/h4/spi_display.h u-boot-imx6/board/boundary/h4/spi_display.h
--- u-boot-2017.07/board/boundary/h4/spi_display.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/h4/spi_display.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,2 @@
+int detect_spi(struct display_info_t const *dev);
+void enable_spi_rgb(struct display_info_t const *dev);
diff -Nru u-boot-2017.07/board/boundary/hl/hl_1g.cfg u-boot-imx6/board/boundary/hl/hl_1g.cfg
--- u-boot-2017.07/board/boundary/hl/hl_1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hl/hl_1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x423e023e
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x022a0229
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45444a48
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x39372f32
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00400045
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00390040
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/hl/hl.c u-boot-imx6/board/boundary/hl/hl.c
--- u-boot-2017.07/board/boundary/hl/hl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hl/hl.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define OUTPUT_40OHM (PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET		IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+
+	/* GPIO - J4 outputs are inverted */
+#define GP_J4_PIN1	IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN),
+#define GP_J4_PIN2	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLDN),
+#define GP_J4_PIN3	IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN),
+#define GP_J4_PIN4	IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN),
+#define GP_J4_PIN5	IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLDN),
+#define GP_J4_PIN6	IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+
+	/* GPIO - J2 outputs */
+#define GP_J2_PIN1	IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLDN),
+#define GP_J2_PIN2	IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLDN),
+#define GP_J2_PIN3	IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLDN),
+#define GP_J2_PIN4	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN),
+#define GP_J2_PIN5	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN),
+#define GP_J2_PIN6	IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLDN),
+
+	/* gpio - test points */
+#define GP_TP71			IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+#define GP_TP72			IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_TP73			IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_TP75			IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_TP_SD3_WP		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLDN),
+
+	/* I2C2 - ov5640 mipi */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(NANDF_CS2__CCM_CLKO2, WEAK_PULLDN),
+
+	/* I2C3 */
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+#define GPIRQ_RV4162		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+
+#define GP_LVDS_J6_PIN19	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* LEDS */
+#define GP_J8_POWER_ON		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN_OUTPUT),
+#define GP_J46_PIN2_I		IMX_GPIO_NR(1, 7)		/* inverted */
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP_OUTPUT),
+#define GP_J46_PIN3_I		IMX_GPIO_NR(1, 8)		/* inverted */
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP_OUTPUT),
+
+	/* PWM1 - J7 - touchscreen connector */
+#define GP_PWM1_J7 IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+
+	/* PWM3 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+
+	/* PWM4 on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, OUTPUT_40OHM),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 - J1 pins 1 & 6 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 - J1 pins 4 & 5 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),	/* may not be connected */
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+
+	/* USDHC3 */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+#endif
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* ft5x06 */
+	VD_TM070JDHG30(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_HANNSTAR7(LVDS, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_ASIT500MA6F5D(LCD, NULL, 2, 0x38),
+
+	VD_OKAYA_480_272(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_HITACHI_HVGA(LCD, NULL, 2, 0x48),
+	VD_CLAA_WVGA(LCD, NULL, 2, 0x48),
+
+
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WVGA_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_OV5640_MIPI_RESET,
+	GP_J8_POWER_ON,
+	GP_J46_PIN2_I,
+	GP_J46_PIN3_I,
+	GP_PWM1_J7,
+	GP_BACKLIGHT_RGB,
+	GP_BACKLIGHT_LVDS,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+};
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_J4_PIN1,
+	GP_J4_PIN2,
+	GP_J4_PIN3,
+	GP_J4_PIN4,
+	GP_J4_PIN5,
+	GP_J4_PIN6,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_J2_PIN1,
+	GP_J2_PIN2,
+	GP_J2_PIN3,
+	GP_J2_PIN4,
+	GP_J2_PIN5,
+	GP_J2_PIN6,
+	GPIRQ_I2C3_J7,
+	GPIRQ_RV4162,
+	GP_TP71,
+	GP_TP72,
+	GP_TP73,
+	GP_TP74,
+	GP_TP75,
+	GP_TP_SD3_WP,
+	GP_USDHC3_CD,
+	GPIRQ_WL1271_WL,
+	GP_LVDS_J6_PIN19,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/hl/Kconfig u-boot-imx6/board/boundary/hl/Kconfig
--- u-boot-2017.07/board/boundary/hl/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hl/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,24 @@
+if TARGET_HL
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "hl"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "hl"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/hl/MAINTAINERS u-boot-imx6/board/boundary/hl/MAINTAINERS
--- u-boot-2017.07/board/boundary/hl/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hl/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+HL BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/hl/
+F:	include/configs/hl.h
+F:	configs/hl_1g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/hl/Makefile u-boot-imx6/board/boundary/hl/Makefile
--- u-boot-2017.07/board/boundary/hl/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hl/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := hl.o
diff -Nru u-boot-2017.07/board/boundary/hp/hp.c u-boot-imx6/board/boundary/hp/hp.c
--- u-boot-2017.07/board/boundary/hp/hp.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/hp.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,564 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/* micro sd - 3.3v - 80ohm @ 1.8v settings is 40ohm at 3.3v */
+#define USDHC1_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/* wifi - 1.8v */
+#define USDHC2_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/* eMMC - 1.8v */
+#define USDHC4_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	IOMUX_PAD_CTRL(DISP0_DAT23__AUD4_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__AUD4_RXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__AUD4_RXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__AUD4_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__AUD4_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__AUD4_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 - J55 db */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_SS0		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+#define GP_ECSPI2_SS1		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+
+	/* ECSPI3 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),
+	/* ECSPI3_SS0	XR20M1170IL16-F - spi uart */
+#define GP_ECSPI3_UART		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+
+	IOMUX_PAD_CTRL(NANDF_CS2__CCM_CLKO2, WEAK_PULLDN),
+#define GPIRQ_SPI_UART		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+#define GP_SPI_UART_RESET	IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLDN),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP_OUTPUT),
+
+	/* GPIO Outputs */
+#define GP_GPO_1		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+#define GP_GPO_2		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_GPO_3		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_GPO_4		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_GPO_5		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_GPO_6		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_GPO_7		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_GPO_8		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+
+	/* GPIO Inputs */
+#define GP_GPI_1		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+#define GP_GPI_2		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLUP),
+#define GP_GPI_3		IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),
+#define GP_GPI_4		IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),
+#define GP_GPI_5		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),
+#define GP_GPI_6		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLUP),
+#define GP_GPI_7		IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),
+#define GP_GPI_8		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),
+#define GP_GPI_9		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+#define GP_GPI_10		IMX_GPIO_NR(4, 14)
+	IOMUX_PAD_CTRL(KEY_COL4__GPIO4_IO14, WEAK_PULLUP),
+#define GP_GPI_11		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_GPI_12		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_GPI_13		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_GPI_14		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+#define GP_GPI_15		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+#define GP_GPI_16		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+#define GP_GPI_EN_N		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+
+	/* GPIO test points */
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP72			IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_TP73			IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP84			IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+#define GP_TP88			IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GP_TP89			IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+#define GP_TP95			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_LVDS_CTRL		IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+
+
+	/* i2c1_rv4162 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+
+#define GPIRQ_I2C3A_J6		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+#define GP_I2C3A_J6_RESET		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* i2c3a - J6 lvds connector (behind PCA9540B mux) */
+#define GPIRQ_LIGHT_SENSOR	IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DAT2__GPIO7_IO06, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN),
+
+	/* PWM1 - J55, pin B30 */
+#define GP_J55_PWM1		IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLDN),
+
+	/* PWM2 - Backlight on LVDS2 connector: J6, pin 30 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 1)
+	IOMUX_PAD_CTRL(GPIO_1__GPIO1_IO01, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__GPIO7_IO04, WEAK_PULLUP),
+#define GP_UART1_TX_EN		IMX_GPIO_NR(7, 5)
+	IOMUX_PAD_CTRL(SD3_DAT1__GPIO7_IO05, WEAK_PULLDN_OUTPUT),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__UART2_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CLK__UART2_RTS_B, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+#define GP_UART3_TX_EN		IMX_GPIO_NR(3, 31)
+	IOMUX_PAD_CTRL(EIM_D31__GPIO3_IO31, WEAK_PULLDN_OUTPUT),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLUP),
+#define GP_UART4_TX_EN		IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLDN_OUTPUT),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLUP),
+#define GP_UART5_TX_EN		IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLDN_OUTPUT),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(ENET_RX_ER__USB_OTG_ID, WEAK_PULLUP),
+//	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+	/* USDHC1  */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT0__SD1_DATA0, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT1__SD1_DATA1, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT2__SD1_DATA2, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DAT3__SD1_DATA3, USDHC1_PAD_CTRL),
+#define GP_USDHC1_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC2 - silex/TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC2_PAD_CTRL),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC4_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* silex/wl1271 */
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+#define GP_WIFI_CLK_REQ		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLUP),
+	/* TiWi only */
+#define GPIRQ_BT_HOST_WAKE	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, RV4162 rtc */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2, J55 connector to hp board */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, PCA9540B(mux), I2C3a, J6 LVDS, I2C3b, PCIe connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	if (!on) {
+		gpio_set_value(GP_REG_USBOTG, on);
+		return 0;
+	}
+	if (otg_power_detect()) {
+		gpio_set_value(GP_REG_USBOTG, 0);
+		mdelay(100);
+		if (otg_power_detect())
+			return 0;
+	}
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_SYS_BOOT_BOARD_POWER_CHECK
+void board_power_check()
+{
+	int i = 0;
+
+	while (1) {
+		if (!otg_power_detect())
+			break;
+		if (!i) {
+			gpio_set_value(GP_REG_USBOTG, 0);
+		} else {
+			printf("Please disconnect otg cable\n");
+
+		}
+		i++;
+		mdelay(1000);
+	}
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC1_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VD_AFK1024600A02(LVDS, fbp_detect_i2c, (GP_I2C3A_J6_RESET << 8) | 2, 0x4a),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_LD070WSVGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_SPI_UART_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_GPO_1,
+	GP_GPO_2,
+	GP_GPO_3,
+	GP_GPO_4,
+	GP_GPO_5,
+	GP_GPO_6,
+	GP_GPO_7,
+	GP_GPO_8,
+	GP_I2C3A_J6_RESET,
+	GP_PCIE_RESET,
+	GP_J55_PWM1,
+	GP_BACKLIGHT_LVDS,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_UART1_TX_EN,
+	GP_UART3_TX_EN,
+	GP_UART4_TX_EN,
+	GP_UART5_TX_EN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_SS0,
+	GP_ECSPI2_SS1,
+	GP_ECSPI3_UART,
+	GP_FLEXCAN_STANDBY,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_SPI_UART,
+	GPIRQ_ENET_PHY,
+	GP_GPI_1,
+	GP_GPI_2,
+	GP_GPI_3,
+	GP_GPI_4,
+	GP_GPI_5,
+	GP_GPI_6,
+	GP_GPI_7,
+	GP_GPI_8,
+	GP_GPI_9,
+	GP_GPI_10,
+	GP_GPI_11,
+	GP_GPI_12,
+	GP_GPI_13,
+	GP_GPI_14,
+	GP_GPI_15,
+	GP_GPI_16,
+	GP_GPI_EN_N,
+	GP_TP71,
+	GP_TP72,
+	GP_TP73,
+	GP_TP74,
+	GP_TP84,
+	GP_TP88,
+	GP_TP89,
+	GP_TP95,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_I2C3A_J6,
+	GP_LVDS_CTRL,
+	GPIRQ_LIGHT_SENSOR,
+	GP_PCIE_DISABLE,
+	GP_USDHC1_CD,
+	GPIRQ_WIFI,
+	GP_WIFI_QOW,
+	GP_WIFI_CLK_REQ,
+	GPIRQ_BT_HOST_WAKE
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_ENET_RX_ERR,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	'T', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/hp/hp.cfg u-boot-imx6/board/boundary/hp/hp.cfg
--- u-boot-2017.07/board/boundary/hp/hp.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/hp.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 6 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42340235
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02210221
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4216021d
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0208020d
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4146494d
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x47494b44
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37332c2a
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3131312d
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040004c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0038003e
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00210024
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00230035
+#define WALAT   1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/hp/hp_q1g.cfg u-boot-imx6/board/boundary/hp/hp_q1g.cfg
--- u-boot-2017.07/board/boundary/hp/hp_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/hp_q1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 10 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x430e0320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x030a0302
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43140326
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x030e0254
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42353947
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3d373446
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383c4134
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4235463f
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x000c0014
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00170011
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x0009001a
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00040011
+#define WALAT   0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/hp/hp_s512m.cfg u-boot-imx6/board/boundary/hp/hp_s512m.cfg
--- u-boot-2017.07/board/boundary/hp/hp_s512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/hp_s512m.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42340234
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02230222
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4344484e
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37352a2b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x003b0043
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00330039
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/hp/Kconfig u-boot-imx6/board/boundary/hp/Kconfig
--- u-boot-2017.07/board/boundary/hp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,24 @@
+if TARGET_HP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "hp"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "hp"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/hp/MAINTAINERS u-boot-imx6/board/boundary/hp/MAINTAINERS
--- u-boot-2017.07/board/boundary/hp/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,9 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/hp/
+F:	include/configs/hp.h
+F:	configs/hp_defconfig
+F:	configs/hp_q1g_defconfig
+F:	configs/hp_s512m_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/hp/Makefile u-boot-imx6/board/boundary/hp/Makefile
--- u-boot-2017.07/board/boundary/hp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/hp/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := hp.o
diff -Nru u-boot-2017.07/board/boundary/insp/insp1g.cfg u-boot-imx6/board/boundary/insp/insp1g.cfg
--- u-boot-2017.07/board/boundary/insp/insp1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/insp1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn off backlight */
+DATA 4, 0x020e0344, 5
+DATA 4, 0x020e072c, 0x30b0
+
+/* 15 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x4320032f
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0315030f
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4321032e
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x031a0260
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42373b46
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3f3a3646
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x35373e32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4032443a
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0013001c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001e0015
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000e0020
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000a0016
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/insp/insp2g.cfg u-boot-imx6/board/boundary/insp/insp2g.cfg
--- u-boot-2017.07/board/boundary/insp/insp2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/insp2g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn off backlight */
+DATA 4, 0x020e0344, 5
+DATA 4, 0x020e072c, 0x30b0
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* This configuration not yet produced */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/insp/insp.c u-boot-imx6/board/boundary/insp/insp.c
--- u-boot-2017.07/board/boundary/insp/insp.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/insp.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,492 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* HOG */
+#define GP_MAIN_POWER_EN	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_MAIN_POWER_BUTTON	IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+
+	/* ADV7180 */
+	/* camera - video0 - ADV7180 - I2C3, crystal 28.636 MHz */
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),	/* Hsync */
+	IOMUX_PAD_CTRL(CSI0_VSYNC__GPIO5_IO21, WEAK_PULLUP),	/* Vsync */
+#define GP_ADV7180_RESET	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP_OUTPUT),
+#define GP_ADV7180_IRQ		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_CS1	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP), /* SS1 */
+
+	/* GPIO_KEYS */
+#define GP_INSP_GP1		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_INSP_GP2		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_INSP_GP3		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_INSP_GP4		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+#define GP_INSP_GP5		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+#define GP_INSP_GP6	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_INSP_GP7	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_INSP_GP8	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_INSP_GP9	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+#define GP_INSP_GP10	IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* HDMI */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* I2C1 - sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_SGTL5000_MUTE	IMX_GPIO_NR(1, 29)		/* Low is muted */
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN_OUTPUT),
+	/* no headphone detect */
+#define GP_HEADPHONE_DET	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* I2C2 */
+#define GP_J6_I2C_EN		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLUP_OUTPUT),
+#define GP_HDMI_I2C_EN		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP_OUTPUT),
+
+	/* I2C3 */
+#define GP_TSC2004_IRQ		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_TSC2004_RESET	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+
+	/* PWM1 */
+#define GP_PWM1			IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN_OUTPUT),
+
+	/* PWM3 */
+#define GP_RGB_BACKLIGHT	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN_OUTPUT),
+
+	/* rtc - i2c1 */
+#define GP_RTC_RV4162_IRQ	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* lvds input on CSI1 */
+#if defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
+	/* Dualite/Solo doesn't have IPU2 */
+	IOMUX_PAD_CTRL(EIM_A24__IPU1_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU1_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU1_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU1_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU1_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU1_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU1_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU1_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU1_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU1_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU1_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] */
+#else
+	IOMUX_PAD_CTRL(EIM_A24__IPU2_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU2_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU2_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU2_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU2_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU2_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU2_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU2_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU2_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU2_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU2_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] */
+#endif
+
+#define GP_CAMERA_LOCK		IMX_GPIO_NR(3, 8)			/* low active */
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+#define GP_CAMERA_POWER_DOWN	IMX_GPIO_NR(3, 9)			/* low active */
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+#define GP_CAMERA_RX_EN		IMX_GPIO_NR(3, 10)			/* high active */
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),		/* 10 Mhz - 66 MHz */
+
+	/* UART1  */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 for debug */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+	/* UART3 - Broadcom Bluetooth*/
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_H1_PWR	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN_OUTPUT),	/* USB Hub Reset for USB2512 4 port hub */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG - J3 */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* USDHC2: TiWi-R2 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+#define GP_WL_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+#define GP_BT_EN		IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+#define GP_WL_IRQ		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - sd */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD	IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, NO_PAD_CTRL),
+#define GP_USDHC3_WP	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, NO_PAD_CTRL),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, OUTPUT_40OHM),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2, hdmi */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, Charger PCIe */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port == 0)
+		gpio_set_value(GP_USB_OTG_PWR, on);
+	if (port == 1)
+		gpio_set_value(GP_USB_H1_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_CS1 : -1;
+}
+
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_RGB_BACKLIGHT, enable);
+}
+
+void board_enable_hdmi(const struct display_info_t *di, int enable)
+{
+	board_enable_lcd(di, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_800_600MR_60(HDMI, fbp_detect_i2c, (GP_HDMI_I2C_EN << 8) | 1, 0x50),
+	VD_1280_720M_60(HDMI, NULL, (GP_HDMI_I2C_EN << 8) | 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, (GP_HDMI_I2C_EN << 8) | 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, (GP_HDMI_I2C_EN << 8) | 1, 0x50),
+
+	VD_LSA40AT9001(LCD, NULL, 2, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_MAIN_POWER_EN,
+	GP_ADV7180_RESET,
+	GP_J6_I2C_EN,
+	GP_HDMI_I2C_EN,
+	GP_TSC2004_RESET,
+	GP_PWM1,
+	GP_RGB_BACKLIGHT,
+	GP_CAMERA_POWER_DOWN,
+	GP_CAMERA_RX_EN,
+	GP_SGTL5000_MUTE,
+	GP_USB_H1_PWR,
+	GP_USB_OTG_PWR,
+	GP_WL_EN,		/* disable wireless */
+	GP_BT_EN,	 	/* disable bluetooth */
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_CS1,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_MAIN_POWER_BUTTON,
+	GP_ADV7180_IRQ,
+	GP_INSP_GP1,
+	GP_INSP_GP2,
+	GP_INSP_GP3,
+	GP_INSP_GP4,
+	GP_INSP_GP5,
+	GP_INSP_GP6,
+	GP_INSP_GP7,
+	GP_INSP_GP8,
+	GP_INSP_GP9,
+	GP_INSP_GP10,
+	GP_TSC2004_IRQ,
+	GP_RTC_RV4162_IRQ,
+	GP_CAMERA_LOCK,
+	GP_HEADPHONE_DET,
+	GP_WL_IRQ,
+	GP_USDHC3_CD,
+	GP_USDHC3_WP,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"input1",	GP_INSP_GP1,	'1', 1},
+	{"input2",	GP_INSP_GP2,	'2', 1},
+	{"power",	GP_MAIN_POWER_BUTTON,	'P', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/insp/Kconfig u-boot-imx6/board/boundary/insp/Kconfig
--- u-boot-2017.07/board/boundary/insp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,24 @@
+if TARGET_INSP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "insp"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "insp"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/insp/MAINTAINERS u-boot-imx6/board/boundary/insp/MAINTAINERS
--- u-boot-2017.07/board/boundary/insp/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+insp BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/insp/
+F:	include/configs/insp.h
+F:	configs/insp_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/insp/Makefile u-boot-imx6/board/boundary/insp/Makefile
--- u-boot-2017.07/board/boundary/insp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/insp/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := insp.o
diff -Nru u-boot-2017.07/board/boundary/ioc/ioc.c u-boot-imx6/board/boundary/ioc/ioc.c
--- u-boot-2017.07/board/boundary/ioc/ioc.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/ioc.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,449 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "spi_display.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),	/* for spi displays */
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+
+	/* i2c2 ov5640 Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, OUTPUT_40OHM),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, OUTPUT_40OHM),
+
+	/* i2c2 ov5642 Camera controls, J5 */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO_6__GPIO1_IO06, OUTPUT_40OHM),
+#define GP_OV5642_RESET		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, OUTPUT_40OHM),
+
+	/* PWM1  */
+#define GP_BACKLIGHT	 IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM4  */
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - emmc */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC_PAD_CTRL),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_NOR_CS;
+	if (bus == 1 && cs == 0)
+		return GP_ECSPI2_CS;
+	if (cs >> 8)
+		return (cs >> 8);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			enable_spi_rgb(di);
+#endif
+		gpio_direction_output(GP_BACKLIGHT, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+	VD_SVGA(LCD, NULL, 0, 0x00),
+#ifdef CONFIG_MXC_SPI_DISPLAY
+	VD_AUO_G050(LCD, NULL, 1, 0),
+	VD_A030JN01_UPS051(LCD, NULL, 1, 2),
+#endif
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	/* Disable wl1271 */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_REG_USBOTG,
+	GP_OV5640_MIPI_RESET,
+	GP_OV5642_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_OV5642_POWER_DOWN,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GP_BACKLIGHT,
+	GPIRQ_ENET_PHY,
+	GPIRQ_WL1271_WL,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/ioc/ioc.cfg u-boot-imx6/board/boundary/ioc/ioc.cfg
--- u-boot-2017.07/board/boundary/ioc/ioc.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/ioc.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ioc/Kconfig u-boot-imx6/board/boundary/ioc/Kconfig
--- u-boot-2017.07/board/boundary/ioc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,24 @@
+if TARGET_IOC
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ioc"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ioc"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ioc/MAINTAINERS u-boot-imx6/board/boundary/ioc/MAINTAINERS
--- u-boot-2017.07/board/boundary/ioc/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,6 @@
+LS BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ioc/
+F:	include/configs/ioc.h
+F:	configs/ioc_defconfig
diff -Nru u-boot-2017.07/board/boundary/ioc/Makefile u-boot-imx6/board/boundary/ioc/Makefile
--- u-boot-2017.07/board/boundary/ioc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ioc.o
+obj-$(CONFIG_MXC_SPI_DISPLAY) += spi_display.o
\      
diff -Nru u-boot-2017.07/board/boundary/ioc/spi_display.c u-boot-imx6/board/boundary/ioc/spi_display.c
--- u-boot-2017.07/board/boundary/ioc/spi_display.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/spi_display.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,461 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/video.h>
+#include <spi.h>
+#include "spi_display.h"
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define SPI_MOSI_R_PAD_CTRL	SPI_PAD_CTRL | PAD_CTL_ODE | PAD_CTL_PUS_22K_UP
+
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+
+static iomux_v3_cfg_t const spi_mosi_r_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_MOSI_R_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_mosi_w_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_pad[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT11__ECSPI2_SS0, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_gpio_pad[] = {
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),
+};
+
+static int AUO_G050_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = 0x20;
+			buf[1] = reg >> 8;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			buf[0] = 0;
+			buf[1] = reg;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			if (!len) {
+				debug("spi: reg:%04x\n", reg);
+				break;
+			}
+			buf[0] = 0x40;
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%04x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int AUO_G050_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = 0x20;
+	buf[1] = reg >> 8;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0;
+	buf[1] = reg;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0xC0;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%04x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	udelay(2);
+	return rbuf[1];
+}
+
+#define A(reg, cnt) (reg >> 8), (reg & 0xff), cnt
+
+static u8 AUO_G050_display_init_cmds[] = {
+/* Display Mode Setting */
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x00,
+	A(0xb100, 2), 0x0c, 0x00,
+	A(0xbc00, 3), 0x05, 0x05, 0x05,
+	A(0xb700, 2), 0x22, 0x22,
+	A(0xb800, 4), 0x01, 0x03, 0x03, 0x03,
+	A(0xc803, 1), 0x96,
+	A(0xc805, 1), 0x96,
+	A(0xc807, 1), 0x96,
+	A(0xc809, 1), 0x96,
+	A(0xc80b, 1), 0x2a,
+	A(0xc80c, 1), 0x2a,
+	A(0xc80f, 1), 0x2a,
+	A(0xc810, 1), 0x2a,
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x01,
+	A(0xb900, 3), 0x34, 0x34, 0x34,
+	A(0xba00, 3), 0x14, 0x14, 0x14,
+	A(0xbe00, 2), 0x00, 0x8c,
+	A(0xb000, 3), 0x00, 0x00, 0x00,
+	A(0xb800, 3), 0x24, 0x24, 0x24,
+	A(0xbc00, 3), 0x00, 0x88, 0x01,
+	A(0xbd00, 3), 0x00, 0x88, 0x01,
+	A(0xd100, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd200, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd300, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd400, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd500, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd600, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0x1100, 0),	/* exit sleep mode, wait 120 ms */
+	A(0, 0)
+};
+
+static u8 AUO_G050_display_on_cmds[] = {
+	A(0x2900, 0),
+	A(0, 0)
+};
+
+/* *************************************************** */
+
+static int A030JN01_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = reg + (reg & 0x40);
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%02x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int A030JN01_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = (reg + (reg & 0x40)) | 0x40;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%02x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	return rbuf[1];
+}
+
+static u8 A030JN01_display_YUV720_init_cmds[] = {
+/* Display Mode Setting */
+	A(4, 2), 0x6b, 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_UPS051_init_cmds[] = {
+	A(5, 1), 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_on_cmds[] = {
+	A(0, 0)
+};
+
+struct spi_display_info {
+	int mode;
+	int speed_r;
+	int speed_w;
+	int reset_active_low;
+	u8 *init_cmds;
+	u8 *on_cmds;
+	int (*spi_write_rtn)(struct spi_slave *spi, u8 *cmds);
+	int (*spi_read_rtn)(struct spi_slave *spi, int reg);
+};
+
+struct spi_display_info spi_di[] = {
+	{ .mode = SPI_MODE_0, .speed_r = 10000, .speed_w = 1000000, .reset_active_low = 1,
+			.init_cmds = AUO_G050_display_init_cmds, .on_cmds = AUO_G050_display_on_cmds,
+			.spi_write_rtn = AUO_G050_spi_write_rtn, .spi_read_rtn = AUO_G050_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_YUV720_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_UPS051_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+};
+
+const struct display_info_t *g_dev;
+
+/*
+ * Return 1 for successful detection of display
+ */
+int detect_spi(struct display_info_t const *dev)
+{
+	return 1;
+}
+
+static void init_spi(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	unsigned reset_gpio = GP_SPI_DISPLAY_RESET;
+	struct spi_display_info *di = &spi_di[dev->addr];
+	int reset_val = di->reset_active_low ? 0 : 1;
+
+	debug("%s\n", __func__);
+	gpio_direction_output(cs_gpio, 1);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	gpio_direction_output(reset_gpio, reset_val);
+	udelay(200);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	mdelay(200);
+}
+
+void enable_spi_rgb(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret;
+	struct spi_display_info *di = &spi_di[dev->addr];
+
+	g_dev = dev;
+	init_spi(dev);
+	gpio_direction_output(cs_gpio, 1);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	ret = di->spi_write_rtn(spi, di->init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	mdelay(200);
+	ret = di->spi_write_rtn(spi, di->on_cmds);
+	if (ret) {
+		printf("%s: Failed to display_on_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	ret = 1;
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return;
+}
+
+static int do_spid(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	int arg = 2;
+	uint reg;
+	u8 buf[80];
+
+	if (argc < 2)
+		return 1;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_w_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	if (argc > ARRAY_SIZE(buf) - 3)
+		argc = ARRAY_SIZE(buf) - 3;
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	buf[0] = reg >> 8;
+	buf[1] = reg;
+	buf[2] = argc - arg;
+	while (arg < argc) {
+		buf[arg + 1] = simple_strtoul(argv[arg], NULL, 16);
+		arg++;
+	}
+	arg++;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	di->spi_write_rtn(spi, buf);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spid, 70, 0, do_spid,
+	"write cmd, data to spi display",
+	"reg16 [byte]"
+);
+
+static int do_spidr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	uint reg;
+	int val;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_r_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_r, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	val = di->spi_read_rtn(spi, reg);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	printf("spidr: reg:0x%x = 0x%x\n", reg, val);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spidr, 70, 0, do_spidr,
+	"read spi display register",
+	"reg16"
+);
diff -Nru u-boot-2017.07/board/boundary/ioc/spi_display.h u-boot-imx6/board/boundary/ioc/spi_display.h
--- u-boot-2017.07/board/boundary/ioc/spi_display.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ioc/spi_display.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,2 @@
+int detect_spi(struct display_info_t const *dev);
+void enable_spi_rgb(struct display_info_t const *dev);
diff -Nru u-boot-2017.07/board/boundary/jlm/jlm_1g.cfg u-boot-imx6/board/boundary/jlm/jlm_1g.cfg
--- u-boot-2017.07/board/boundary/jlm/jlm_1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/jlm_1g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/jlm/jlm_2g.cfg u-boot-imx6/board/boundary/jlm/jlm_2g.cfg
--- u-boot-2017.07/board/boundary/jlm/jlm_2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/jlm_2g.cfg	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/jlm/jlm.c u-boot-imx6/board/boundary/jlm/jlm.c
--- u-boot-2017.07/board/boundary/jlm/jlm.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/jlm.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,461 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This board has a SOM1 cpu card
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "spi_display.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC4_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),	/* for spi displays */
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* i2c1_isl1208 */
+#define GPIRQ_RTC_ISL1208	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+
+	/* i2c1_isl29023 */
+#define GPIRQ_ISL29023		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+
+	/* i2c2 ov5640 mipi Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* i2c2 ov5642 Camera controls, J5 */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO_6__GPIO1_IO06, WEAK_PULLUP),
+#define GP_OV5642_RESET		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC2_PAD_CTRL),
+
+	/* USDHC3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC3_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_set_value(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_NOR_CS;
+	if (bus == 1 && cs == 0)
+		return GP_ECSPI2_CS;
+	if (cs >> 8)
+		return (cs >> 8);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			enable_spi_rgb(di);
+#endif
+		mdelay(100); /* let panel sync up before enabling backlight */
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+	VD_640_480M_60(HDMI, NULL, 1, 0x50),
+	VD_720_480M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+#ifdef CONFIG_MXC_SPI_DISPLAY
+	VD_AUO_G050(LCD, NULL, 1, 0),
+	VD_A030JN01_UPS051(LCD, NULL, 1, 2),
+	VD_A030JN01_YUV720(LCD, NULL, 1, 1),
+#endif
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_RGB,
+	/* Disable wl1271 */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_REG_USBOTG,
+	GP_OV5640_MIPI_RESET,
+	GP_OV5642_RESET,
+	GP_USB_HUB_RESET,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_OV5642_POWER_DOWN,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GPIRQ_RTC_ISL1208,
+	GPIRQ_ISL29023,
+	GPIRQ_WL1271_WL,
+	GP_USDHC4_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/jlm/Kconfig u-boot-imx6/board/boundary/jlm/Kconfig
--- u-boot-2017.07/board/boundary/jlm/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,21 @@
+if TARGET_JLM
+
+config SYS_BOARD
+	default "jlm"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "jlm"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/jlm/MAINTAINERS u-boot-imx6/board/boundary/jlm/MAINTAINERS
--- u-boot-2017.07/board/boundary/jlm/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/MAINTAINERS	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,6 @@
+NITROGEN6X BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/jlm/
+F:	include/configs/jlm.h
+F:	configs/jlm_defconfig
diff -Nru u-boot-2017.07/board/boundary/jlm/Makefile u-boot-imx6/board/boundary/jlm/Makefile
--- u-boot-2017.07/board/boundary/jlm/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/Makefile	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := jlm.o
+obj-$(CONFIG_MXC_SPI_DISPLAY) += spi_display.o
\      
diff -Nru u-boot-2017.07/board/boundary/jlm/spi_display.c u-boot-imx6/board/boundary/jlm/spi_display.c
--- u-boot-2017.07/board/boundary/jlm/spi_display.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/spi_display.c	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,462 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/video.h>
+#include <spi.h>
+#include "spi_display.h"
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define SPI_MOSI_R_PAD_CTRL	SPI_PAD_CTRL | PAD_CTL_ODE | PAD_CTL_PUS_22K_UP
+
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+
+static iomux_v3_cfg_t const spi_mosi_r_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_MOSI_R_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_mosi_w_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_pad[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT11__ECSPI2_SS0, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_gpio_pad[] = {
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),
+};
+
+static int AUO_G050_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = 0x20;
+			buf[1] = reg >> 8;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			buf[0] = 0;
+			buf[1] = reg;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			if (!len) {
+				debug("spi: reg:%04x\n", reg);
+				break;
+			}
+			buf[0] = 0x40;
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%04x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int AUO_G050_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = 0x20;
+	buf[1] = reg >> 8;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0;
+	buf[1] = reg;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0xC0;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%04x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	udelay(2);
+	return rbuf[1];
+}
+
+#define A(reg, cnt) (reg >> 8), (reg & 0xff), cnt
+
+static u8 AUO_G050_display_init_cmds[] = {
+/* Display Mode Setting */
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x00,
+	A(0xb100, 2), 0x0c, 0x00,
+	A(0xbc00, 3), 0x05, 0x05, 0x05,
+	A(0xb700, 2), 0x22, 0x22,
+	A(0xb800, 4), 0x01, 0x03, 0x03, 0x03,
+	A(0xc803, 1), 0x96,
+	A(0xc805, 1), 0x96,
+	A(0xc807, 1), 0x96,
+	A(0xc809, 1), 0x96,
+	A(0xc80b, 1), 0x2a,
+	A(0xc80c, 1), 0x2a,
+	A(0xc80f, 1), 0x2a,
+	A(0xc810, 1), 0x2a,
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x01,
+	A(0xb900, 3), 0x34, 0x34, 0x34,
+	A(0xba00, 3), 0x14, 0x14, 0x14,
+	A(0xbe00, 2), 0x00, 0x8c,
+	A(0xb000, 3), 0x00, 0x00, 0x00,
+	A(0xb800, 3), 0x24, 0x24, 0x24,
+	A(0xbc00, 3), 0x00, 0x88, 0x01,
+	A(0xbd00, 3), 0x00, 0x88, 0x01,
+	A(0xd100, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd200, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd300, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd400, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd500, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd600, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0x1100, 0),	/* exit sleep mode, wait 120 ms */
+	A(0, 0)
+};
+
+static u8 AUO_G050_display_on_cmds[] = {
+	A(0x2900, 0),
+	A(0, 0)
+};
+
+/* *************************************************** */
+
+static int A030JN01_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = reg + (reg & 0x40);
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%02x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int A030JN01_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = (reg + (reg & 0x40)) | 0x40;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%02x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	return rbuf[1];
+}
+
+static u8 A030JN01_display_YUV720_init_cmds[] = {
+/* Display Mode Setting */
+	A(4, 2), 0x6b, 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_UPS051_init_cmds[] = {
+	A(5, 1), 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_on_cmds[] = {
+	A(0, 0)
+};
+
+struct spi_display_info {
+	int mode;
+	int speed_r;
+	int speed_w;
+	int reset_active_low;
+	u8 *init_cmds;
+	u8 *on_cmds;
+	int (*spi_write_rtn)(struct spi_slave *spi, u8 *cmds);
+	int (*spi_read_rtn)(struct spi_slave *spi, int reg);
+};
+
+struct spi_display_info spi_di[] = {
+	{ .mode = SPI_MODE_0, .speed_r = 10000, .speed_w = 1000000, .reset_active_low = 1,
+			.init_cmds = AUO_G050_display_init_cmds, .on_cmds = AUO_G050_display_on_cmds,
+			.spi_write_rtn = AUO_G050_spi_write_rtn, .spi_read_rtn = AUO_G050_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_YUV720_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.init_cmds = A030JN01_display_UPS051_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+};
+
+const struct display_info_t *g_dev;
+
+/*
+ * Return 1 for successful detection of display
+ */
+int detect_spi(struct display_info_t const *dev)
+{
+	return 1;
+}
+
+static void init_spi(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	unsigned reset_gpio = GP_SPI_DISPLAY_RESET;
+	struct spi_display_info *di = &spi_di[dev->addr];
+	int reset_val = di->reset_active_low ? 0 : 1;
+
+	debug("%s\n", __func__);
+	gpio_direction_output(cs_gpio, 1);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	gpio_direction_output(reset_gpio, reset_val);
+	udelay(200);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	mdelay(200);
+}
+
+void enable_spi_rgb(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret;
+	struct spi_display_info *di = &spi_di[dev->addr];
+
+	g_dev = dev;
+	init_spi(dev);
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_w_pads);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	ret = di->spi_write_rtn(spi, di->init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	mdelay(200);
+	ret = di->spi_write_rtn(spi, di->on_cmds);
+	if (ret) {
+		printf("%s: Failed to display_on_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	ret = 1;
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return;
+}
+
+static int do_spid(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	int arg = 2;
+	uint reg;
+	u8 buf[80];
+
+	if (argc < 2)
+		return 1;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_w_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	if (argc > ARRAY_SIZE(buf) - 3)
+		argc = ARRAY_SIZE(buf) - 3;
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	buf[0] = reg >> 8;
+	buf[1] = reg;
+	buf[2] = argc - arg;
+	while (arg < argc) {
+		buf[arg + 1] = simple_strtoul(argv[arg], NULL, 16);
+		arg++;
+	}
+	arg++;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	di->spi_write_rtn(spi, buf);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spid, 70, 0, do_spid,
+	"write cmd, data to spi display",
+	"reg16 [byte]"
+);
+
+static int do_spidr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	uint reg;
+	int val;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	gpio_direction_output(cs_gpio, 1);
+	SETUP_IOMUX_PADS(spi_mosi_r_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, 0, di->speed_r, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	SETUP_IOMUX_PADS(spi_ss0_pad);
+	val = di->spi_read_rtn(spi, reg);
+	SETUP_IOMUX_PADS(spi_ss0_gpio_pad);
+	printf("spidr: reg:0x%x = 0x%x\n", reg, val);
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spidr, 70, 0, do_spidr,
+	"read spi display register",
+	"reg16"
+);
diff -Nru u-boot-2017.07/board/boundary/jlm/spi_display.h u-boot-imx6/board/boundary/jlm/spi_display.h
--- u-boot-2017.07/board/boundary/jlm/spi_display.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/jlm/spi_display.h	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,2 @@
+int detect_spi(struct display_info_t const *dev);
+void enable_spi_rgb(struct display_info_t const *dev);
diff -Nru u-boot-2017.07/board/boundary/ls/Kconfig u-boot-imx6/board/boundary/ls/Kconfig
--- u-boot-2017.07/board/boundary/ls/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ls/Kconfig	2018-08-27 21:35:36.944138364 +0300
@@ -0,0 +1,24 @@
+if TARGET_LS
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ls"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ls"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ls/ls2g.cfg u-boot-imx6/board/boundary/ls/ls2g.cfg
--- u-boot-2017.07/board/boundary/ls/ls2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ls/ls2g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn on main power */
+DATA 4, 0x020e03b4, 0xf0b0
+DATA 4, 0x020e00a0, 5
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ls/ls.c u-boot-imx6/board/boundary/ls/ls.c
--- u-boot-2017.07/board/boundary/ls/ls.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ls/ls.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,689 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+//	IOMUX_PAD_CTRL(GPIO_8__XTALOSC_REF_CLK_32K, OUTPUT_40OHM),	/* TiWi, WM5102, GTM609W */
+
+	/* Accelerometer (MPU-9250) (i2c3) */
+#ifdef CONFIG_NEW_REV
+#define GPIRQ_ACCEL		IMX_GPIO_NR(3, 28)
+	IOMUX_PAD_CTRL(EIM_D28__GPIO3_IO28, WEAK_PULLUP),
+#else
+#define GPIRQ_ACCEL		IMX_GPIO_NR(5, 30)
+	IOMUX_PAD_CTRL(CSI0_DAT12__GPIO5_IO30, WEAK_PULLUP),
+#endif
+
+	/* AUDMUX  - GSM */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* AUDMUX  - wm5102 */
+	IOMUX_PAD_CTRL(DI0_PIN4__AUD6_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__AUD6_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__AUD6_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__AUD6_TXFS, AUD_PAD_CTRL),
+
+	/* Camera (mipi) - LM3555 strobe/flash */
+#ifdef CONFIG_NEW_REV
+#define GP_CAM_STROBE		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN_OUTPUT),
+#define GP_CAM_TORCH		IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, WEAK_PULLDN_OUTPUT),
+#else
+#define GP_CAM_STROBE		IMX_GPIO_NR(3, 18)
+	IOMUX_PAD_CTRL(EIM_D18__GPIO3_IO18, WEAK_PULLDN_OUTPUT),
+#define GP_CAM_TORCH		IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLDN_OUTPUT),
+#endif
+
+#define GP_CAM_MIPI_RESET	IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLDN_OUTPUT),
+#define GP_CAM_MIPI_EN		IMX_GPIO_NR(1, 29)
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* XCLK */
+
+	/* Display (Braille) */
+#define GP_DISP_STROBE		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_DISP_HV_EN		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLDN_OUTPUT),
+
+#define GP_DISP_KEY_1		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN),
+#define GP_DISP_KEY_2		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN),
+#define GP_DISP_KEY_3		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLDN),
+#define GP_DISP_KEY_4		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN),
+#define GP_DISP_KEY_5		IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLDN),
+#define GP_DISP_KEY_6		IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLDN),
+#define GP_DISP_KEY_SHIFT	IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLDN),
+#define GP_DISP_KEY_SPACE	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN),
+#define GP_DISP_KEY_CTRL	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLDN),
+#define GP_DISP_LED_RED		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLDN_OUTPUT),
+#ifdef CONFIG_NEW_REV
+#define GP_DISP_LED_GREEN	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLDN_OUTPUT),
+#else
+#define GP_DISP_LED_GREEN	IMX_GPIO_NR(5, 10)
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLDN_OUTPUT),
+#endif
+
+	/* Keypad */
+	IOMUX_PAD_CTRL(KEY_COL0__KEY_COL0, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_COL1__KEY_COL1, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_COL2__KEY_COL2, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_COL3__KEY_COL3, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_COL4__KEY_COL4, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(GPIO_19__KEY_COL5, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_ROW0__KEY_ROW0, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_ROW1__KEY_ROW1, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(KEY_ROW2__KEY_ROW2, WEAK_PULLDN_OUTPUT),
+
+	/* ECSPI1 pads (serial nor eeprom) */
+#ifdef CONFIG_NEW_REV
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+#else
+	IOMUX_PAD_CTRL(DISP0_DAT22__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(5, 17)
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+#endif
+
+	/* ECSPI2 pads (Braille Display) */
+#ifdef CONFIG_NEW_REV
+	IOMUX_PAD_CTRL(DISP0_DAT16__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS0		IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+#else
+#define GP_BRL_MISO	IMX_GPIO_NR(5, 18)
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__GPIO5_IO18, WEAK_PULLUP),
+#define GP_BRL_MOSI		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLDN_OUTPUT),
+#define GP_BRL_CLK		IMX_GPIO_NR(4, 16)
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLDN_OUTPUT),
+#define GP_BRL_DATA_BUF_EN	IMX_GPIO_NR(5, 28)
+	IOMUX_PAD_CTRL(CSI0_DAT10__GPIO5_IO28, WEAK_PULLDN_OUTPUT),
+#endif
+
+	/* ECSPI3 pads GSM (GTM609W) */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI3_GSM		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+
+	/* ECSPI5 pads sound(wm5102) */
+	IOMUX_PAD_CTRL(SD1_DAT0__ECSPI5_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__ECSPI5_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CLK__ECSPI5_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI5_WM5102	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+
+	/* GSM sim (GTM609W) */
+#define GP_GSM_SIM_RESET	IMX_GPIO_NR(5, 19)
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),
+#define GP_GSM_HOST_WAKE_WWAN	IMX_GPIO_NR(5, 20)
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, WEAK_PULLUP),
+#define GP_GSM_PWR_EN		IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLUP),
+#define GP_GSM_RESET		IMX_GPIO_NR(6, 3)
+	IOMUX_PAD_CTRL(CSI0_DAT17__GPIO6_IO03, WEAK_PULLUP),
+#define GP_GSM_ON_OFF		IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLUP),
+#define GP_GSM_HOST_WAKE	IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLUP),
+//	IOMUX_PAD_CTRL(GPIO_8__XTALOSC_REF_CLK_32K, OUTPUT_40OHM),	/* slow clock */
+
+	/* GPS */
+#define GP_GPS_HEARTBEAT	IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_GPS		IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLDN_OUTPUT),
+#define GP_GPS_RESET		IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLDN_OUTPUT),
+
+	/* HDMI CEC */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* I2C1 - rv4162(rtc), */
+
+	/* I2C2 - J12(touch connector), */
+#define GP_I2C2_HDMI_EN	IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLDN_OUTPUT),
+#ifdef CONFIG_NEW_REV
+#define GP_I2C2_CAMERA_EN	IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLDN_OUTPUT),
+#define GP_I2C2_FLASH_EN	IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLDN_OUTPUT),
+#else
+#define GP_I2C2_CAMERA_EN	IMX_GPIO_NR(1, 31)
+	IOMUX_PAD_CTRL(ENET_MDC__GPIO1_IO31, WEAK_PULLDN_OUTPUT),
+#define GP_I2C2_FLASH_EN	IMX_GPIO_NR(3, 17)
+	IOMUX_PAD_CTRL(EIM_D17__GPIO3_IO17, WEAK_PULLDN_OUTPUT),
+#endif
+
+	/* I2C3 - MPR21 cap touch, MPU-9250(accelerometer) */
+#define GP_I2C3_ACCEL_EN	IMX_GPIO_NR(5, 31)
+	IOMUX_PAD_CTRL(CSI0_DAT13__GPIO5_IO31, WEAK_PULLDN_OUTPUT),
+#ifndef CONFIG_NEW_REV
+#define GP_I2C3_MAX77818_EN	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLDN_OUTPUT),
+#endif
+
+	/* MAX77818, ends with B(active low) */
+#define GP_MAX77818_INOKB		IMX_GPIO_NR(4, 26)	/* C5 */
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_MAX77818_INTB		IMX_GPIO_NR(5, 6)	/* C3 */
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+#define GP_MAX77818_WCINOKB		IMX_GPIO_NR(5, 7)	/* A5 */
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+
+	/* Power */
+#define GP_MAIN_ON_OFF		IMX_GPIO_NR(3, 20)	/* input to or gate */
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),
+#ifdef CONFIG_NEW_REV
+#define GP_ON_OFF_IRQ		IMX_GPIO_NR(5, 14)
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+#else
+#define GP_ON_OFF_IRQ		IMX_GPIO_NR(5, 11)
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+#endif
+
+	/* PMIC */
+#define GP_PMIC_C0_OUT		IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLUP),
+#define GP_PMIC_C1_OUT		IMX_GPIO_NR(2, 29)
+	IOMUX_PAD_CTRL(EIM_EB1__GPIO2_IO29, WEAK_PULLUP),
+#define GP_PMIC_C2_OUT		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),
+#define GP_PMIC_C3_OUT		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+#define GP_PMIC_C4_OUT		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+#define GP_PMIC_C5_OUT		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_PMIC_R0_IN		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_PMIC_R1_IN		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_PMIC_R2_IN		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_PMIC_R3_IN		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_PMIC_R4_IN		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+#define GP_PMIC_R5_IN		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+#define GP_PMIC_KEYPAD_LOCK	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+	/* PWM1 */
+#define GP_PWM1_BUZZER		IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLDN_OUTPUT),
+
+	/* Regulator - HDMI, USBH1_DN3, WM5102 speaker, braille display */
+#define GP_REG_5V_EN	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP_OUTPUT),
+
+	/* rtc */
+#ifdef CONFIG_NEW_REV
+#define GP_RTC_RV4162_IRQ	IMX_GPIO_NR(5, 15)
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+#else
+#define GP_RTC_RV4162_IRQ	IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+#endif
+
+	/* Test points */
+#define GP_TP6			IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),	/* 1.8V */
+#define GP_TP7			IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),	/* 1.8V */
+#define GP_TP24			IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLUP),	/* 1.8V */
+#define GP_TP29			IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLUP),	/* 1.8V */
+#define GP_TP30			IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),	/* 1.8V */
+#define GP_TP92			IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLUP),	/* 2.6V */
+#define GP_TP93			IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),	/* 2.6V */
+
+#ifdef CONFIG_NEW_REV
+#define GP_TP28			IMX_GPIO_NR(5, 16)
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, OUTPUT_40OHM),	/* tri-state */
+#define GP_TP107		IMX_GPIO_NR(5, 17)
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, OUTPUT_40OHM),	/* tri-state */
+#define GP_TP108		IMX_GPIO_NR(5, 30)
+	IOMUX_PAD_CTRL(CSI0_DAT12__GPIO5_IO30, WEAK_PULLUP),
+#define GP_TP110		IMX_GPIO_NR(5, 18)
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__GPIO5_IO18, WEAK_PULLUP),
+#define GP_TP111		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLDN),
+#else
+#define GP_TP25			IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, OUTPUT_40OHM),	/* tri-state */
+#define GP_TP27			IMX_GPIO_NR(3, 28)
+	IOMUX_PAD_CTRL(EIM_D28__GPIO3_IO28, OUTPUT_40OHM),	/* tri-state */
+#define GP_TP28			IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, OUTPUT_40OHM),	/* tri-state */
+#define GP_TP107		IMX_GPIO_NR(4, 13)
+	IOMUX_PAD_CTRL(KEY_ROW3__GPIO4_IO13, OUTPUT_40OHM),	/* tri-state */
+#endif
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART5 - gps */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLDN_OUTPUT),
+#define GP_VBUS_GOOD		IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),	/* 1.8V */
+
+	/* USB OTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_D21__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* USDHC2 - TiWi wl1271 pads */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+#define GP_WL12XX_WL_ENABLE	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, OUTPUT_40OHM),
+#define GP_WL12XX_BT_ENABLE	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, OUTPUT_40OHM),
+//	IOMUX_PAD_CTRL(GPIO_8__XTALOSC_REF_CLK_32K, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - micro SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_WP		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wm5102 */
+#define GP_WM5102_GPIO4		IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+#define GP_WM5102_GPIO5		IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+#define GP_WM5102_LINE_HP_DET		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_WM5102_LINE_HP_DET2		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GPIRQ_WM5102			IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_WM5102_RESET			IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_WM5102_LDO_EN		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* MCLK1 */
+//	IOMUX_PAD_CTRL(GPIO_8__XTALOSC_REF_CLK_32K, OUTPUT_40OHM),	/* MCLK2 */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, CSI0_DAT9, 5, 27, CSI0_DAT8, 5, 26, I2C_PAD_CTRL),
+#ifdef CONFIG_NEW_REV
+	I2C_PADS_INFO_ENTRY(I2C2, EIM_EB2, 2, 30, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+#else
+	I2C_PADS_INFO_ENTRY(I2C2, EIM_EB2, 2, 30, EIM_D16, 3, 16, I2C_PAD_CTRL),
+#endif
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+static void charge_from_usb(int enable)
+{
+	u8 val8 = enable ? 0x27 : 7;
+	u8 orig_i2c_bus = i2c_get_bus_num();
+
+	i2c_set_bus_num(2);
+	i2c_write(0x69, 0xc3, 1, &val8, 1);
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	int gp = port ? GP_USBH1_HUB_RESET : GP_USB_OTG_PWR;
+
+	if (!port && on)
+		charge_from_usb(0);
+	gpio_set_value(gp, on);
+	if (!port && !on)
+		charge_from_usb(1);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_CAM_STROBE,
+	GP_CAM_TORCH,
+	GP_CAM_MIPI_RESET,
+	GP_CAM_MIPI_EN,
+	GP_DISP_HV_EN,
+#ifndef CONFIG_NEW_REV
+	GP_BRL_DATA_BUF_EN,
+	GP_I2C3_MAX77818_EN,
+#endif
+	GP_DISP_LED_RED,
+	GP_DISP_LED_GREEN,
+	GP_GSM_SIM_RESET,
+	GP_GSM_PWR_EN,
+	GP_GSM_RESET,
+	GP_GSM_ON_OFF,
+	GP_GPS_RESET,
+	GP_I2C2_HDMI_EN,
+	GP_I2C2_CAMERA_EN,
+	GP_I2C2_FLASH_EN,
+	GP_I2C3_ACCEL_EN,
+	GP_PWM1_BUZZER,
+	GP_USBH1_HUB_RESET,
+	GP_USB_OTG_PWR,
+	GP_WL12XX_WL_ENABLE,
+	GP_WL12XX_BT_ENABLE,
+	GP_EMMC_RESET,
+	GP_WM5102_RESET,
+	GP_WM5102_LDO_EN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_MAIN_ON_OFF,
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI3_GSM,
+	GP_ECSPI5_WM5102,
+	GP_REG_5V_EN,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ACCEL,
+	GP_DISP_KEY_1,
+	GP_DISP_KEY_2,
+	GP_DISP_KEY_3,
+	GP_DISP_KEY_4,
+	GP_DISP_KEY_5,
+	GP_DISP_KEY_6,
+	GP_DISP_KEY_SHIFT,
+	GP_DISP_KEY_SPACE,
+	GP_DISP_KEY_CTRL,
+	GP_DISP_STROBE,
+#ifndef CONFIG_NEW_REV
+	GP_BRL_MISO,
+	GP_BRL_MOSI,
+	GP_BRL_CLK,
+#endif
+	GP_VBUS_GOOD,
+	GP_GSM_HOST_WAKE_WWAN,
+	GP_GSM_HOST_WAKE,
+	GP_GPS_HEARTBEAT,
+	GPIRQ_GPS,
+	GP_MAX77818_INOKB,
+	GP_MAX77818_INTB,
+	GP_MAX77818_WCINOKB,
+	GP_ON_OFF_IRQ,
+	GP_PMIC_C0_OUT,
+	GP_PMIC_C1_OUT,
+	GP_PMIC_C2_OUT,
+	GP_PMIC_C3_OUT,
+	GP_PMIC_C4_OUT,
+	GP_PMIC_C5_OUT,
+	GP_PMIC_R0_IN,
+	GP_PMIC_R1_IN,
+	GP_PMIC_R2_IN,
+	GP_PMIC_R3_IN,
+	GP_PMIC_R4_IN,
+	GP_PMIC_R5_IN,
+	GP_PMIC_KEYPAD_LOCK,
+	GP_RTC_RV4162_IRQ,
+	GP_TP6,
+	GP_TP7,
+	GP_TP24,
+	GP_TP29,
+	GP_TP30,
+	GP_TP92,
+	GP_TP93,
+#ifndef CONFIG_NEW_REV
+	GP_TP25,
+	GP_TP27,
+#endif
+	GP_TP28,
+	GP_TP107,
+#ifdef CONFIG_NEW_REV
+	GP_TP108,
+	GP_TP110,
+	GP_TP111,
+#endif
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_WP,
+	GP_USDHC3_CD,
+	GP_WM5102_GPIO4,
+	GP_WM5102_GPIO5,
+	GP_WM5102_LINE_HP_DET,
+	GP_WM5102_LINE_HP_DET2,
+	GPIRQ_WM5102,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
+
+	gpio_set_value(GP_MAIN_ON_OFF, 0);
+	writel(0x60, &snvs->lpcr);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+#ifndef CONFIG_NEW_REV
+	gpio_set_value(GP_I2C3_MAX77818_EN, 1);
+#endif
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+
+#ifndef CONFIG_NEW_REV
+	gpio_set_value(GP_I2C3_MAX77818_EN, 0);
+#endif
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{ "1",	GP_DISP_KEY_1,		'1', 0},
+	{ "2",	GP_DISP_KEY_2,		'2', 0},
+	{ "3",	GP_DISP_KEY_3,		'3', 0},
+	{ "4",	GP_DISP_KEY_4,		'4', 0},
+	{ "5",	GP_DISP_KEY_5,		'5', 0},
+	{ "6",	GP_DISP_KEY_6,		'6', 0},
+	{ "S",	GP_DISP_KEY_SHIFT,	'S', 0},
+	{ "P",	GP_DISP_KEY_SPACE,	'P', 0},
+	{ "C",	GP_DISP_KEY_CTRL,	'C', 0},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/ls/MAINTAINERS u-boot-imx6/board/boundary/ls/MAINTAINERS
--- u-boot-2017.07/board/boundary/ls/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ls/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,6 @@
+LS BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ls/
+F:	include/configs/ls.h
+F:	configs/ls_defconfig
diff -Nru u-boot-2017.07/board/boundary/ls/Makefile u-boot-imx6/board/boundary/ls/Makefile
--- u-boot-2017.07/board/boundary/ls/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ls/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,6 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+obj-y  := ls.o
diff -Nru u-boot-2017.07/board/boundary/lshore/Kconfig u-boot-imx6/board/boundary/lshore/Kconfig
--- u-boot-2017.07/board/boundary/lshore/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_LSHORE
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "lshore"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "lshore"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/lshore/lshore.c u-boot-imx6/board/boundary/lshore/lshore.c
--- u-boot-2017.07/board/boundary/lshore/lshore.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/lshore.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	       \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |	       \
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* WiFi/BT pads */
+#define GP_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLUP),
+#define GP_BT_EN	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLUP),
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+
+	/* GPIOs */
+#define GPIRQ_ACC_INT1	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GPIRQ_ACC_INT2	IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+#define GPIRQ_USB320_INTR	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_LED_GREEN	IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLDN),
+#define GP_LED_RED	IMX_GPIO_NR(3, 6)
+        IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN),
+#define GP_LED_YELLOW	IMX_GPIO_NR(3, 5)
+        IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLDN),
+
+#define GP_SW1	IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLUP),
+#define GP_SW2	IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),
+#define GP_SW3	IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),
+#define GP_SW4	IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),
+#define GP_SW5	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLUP),
+
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+
+	/* PWM1 - Backlight on RGB connector */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+
+	/* PWM4 on LVDS connector */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* DISP0_CONTRAST */
+#define GP_BACKLIGHT_LVDS_EN	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* USDHC2 - Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 */
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+	gpio_direction_output(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* LCD */
+	VD_ASIT500MA6F5D(LCD, NULL, 2, 0x38),
+
+	/* LVDS */
+	VD_HANNSTAR7(LVDS, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_HANNSTAR(LVDS, NULL, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WVGA_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	/* Disable wifi */
+	GP_WLAN_EN,
+	GP_BT_EN,
+	GP_REG_USBOTG,
+	GP_LED_GREEN,
+	GP_LED_RED,
+	GP_LED_YELLOW,
+	GP_EMMC_RESET,
+};
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BACKLIGHT_RGB,
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_LVDS_EN,
+	GPIRQ_ACC_INT1,
+	GPIRQ_ACC_INT2,
+	GPIRQ_USB320_INTR,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+	GP_SW1,
+	GP_SW2,
+	GP_SW3,
+	GP_SW4,
+	GP_SW5,
+	GP_TP71,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
+
+unsigned short switches[] = {
+	GP_SW1,
+	GP_SW2,
+	GP_SW3,
+	GP_SW4,
+	GP_SW5,
+};
+
+static int get_board_rev(void)
+{
+	int i, v;
+	int value = 0;
+
+	for (i = 0; i < ARRAY_SIZE(switches); i++) {
+		v = gpio_get_value(switches[i]);
+		value |= (v ? 1 : 0) << i;
+	}
+	return value;
+}
+
+#ifndef CONFIG_SYS_BOARD
+
+static char board_name[] = "lshore\0\0\0\0\0";
+const char *board_get_board_type(void)
+{
+	int value = get_board_rev();
+
+	if (value != 31)
+		snprintf(board_name, sizeof(board_name), "lshore-r%d", value);
+	return board_name;
+}
+#endif
+
+static int do_board_rev(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char buf[32];
+
+	snprintf(buf, sizeof(buf), "%d", get_board_rev());
+	setenv("board_rev", buf);
+	printf("%s\n", buf);
+	return 0;
+}
+
+U_BOOT_CMD(
+	board_rev, 1, 1, do_board_rev,
+	"Determine board revision #",
+	"Prints revision."
+);
diff -Nru u-boot-2017.07/board/boundary/lshore/lshore_dl.cfg u-boot-imx6/board/boundary/lshore/lshore_dl.cfg
--- u-boot-2017.07/board/boundary/lshore/lshore_dl.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/lshore_dl.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 1 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x423c0238
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02200224
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x42100218
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x020c0210
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x44484e4e
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x484a4a42
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x38362c2c
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3032322e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00470054
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x003f0044
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00220024
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00280036
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/lshore/lshore_solo.cfg u-boot-imx6/board/boundary/lshore/lshore_solo.cfg
--- u-boot-2017.07/board/boundary/lshore/lshore_solo.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/lshore_solo.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 1 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42380238
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02200220
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42484e52
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x38362c2a
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x003d004a
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0036003d
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/lshore/MAINTAINERS u-boot-imx6/board/boundary/lshore/MAINTAINERS
--- u-boot-2017.07/board/boundary/lshore/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+LSHORE BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/lshore/
+F:	include/configs/lshore.h
+F:	configs/lshore_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/lshore/Makefile u-boot-imx6/board/boundary/lshore/Makefile
--- u-boot-2017.07/board/boundary/lshore/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/lshore/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := lshore.o
diff -Nru u-boot-2017.07/board/boundary/ltch/Kconfig u-boot-imx6/board/boundary/ltch/Kconfig
--- u-boot-2017.07/board/boundary/ltch/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ltch/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_LTCH
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ltch"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ltch"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ltch/ltch.c u-boot-imx6/board/boundary/ltch/ltch.c
--- u-boot-2017.07/board/boundary/ltch/ltch.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ltch/ltch.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,447 @@
+/*
+ * Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* CAN1 - TJA1040T */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_CAN1_STANDBY		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP_OUTPUT),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* GP - Hogs */
+#define GP_BT_CLK_REQ		IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+#define GP_BT_HOST_WAKE		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+
+#define GP_LVDS			IMX_GPIO_NR(4, 5)	/* J4 pin 19 */
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLDN),
+
+#define GP_LVDS2		IMX_GPIO_NR(2, 23)	/* J5 pin 19 */
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN),
+
+#define GP_TP55			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP124		IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GP_TP125		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+#define GP_TP151		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),
+#define GP_TP152		IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+#define GP_TP153		IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLUP),
+
+	/* i2c1 - TCA9546APWR,  a - wm8960, b - touch, c - pcie, d - J6 */
+	/* A0/A1 are i2c address selects, 0x70 - 0x73 */
+#define GP_I2C1_TCA9546_A0	IMX_GPIO_NR(4, 19)
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLDN),
+#define GP_I2C1_TCA9546_A1	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLDN),
+#define GP_I2C1_TCA9546_RESET	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),
+
+	/* i2c1a wm8960 - Amplifier Mute, TDA7491LP13TR */
+#define GP_WM8960_AMP_STDBY	IMX_GPIO_NR(4, 7)		/* Low is standby */
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+#define GP_WM8960_AMP_MUTE		IMX_GPIO_NR(4, 21)		/* Low is muted */
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLDN),
+#define GP_WM8960_AMP_G0	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLDN),
+#define GP_WM8960_AMP_G1	IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLDN),
+#define GP_WM8960_MIC_DET	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* mclk */
+
+	/* i2c1b touch J7, pin 4 */
+#define GPIRQ_I2C1B_J7	IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* i2c1d touch J6, pin 4 */
+#define GPIRQ_I2C1D_J6		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+
+	/* i2c2 - TCA9546APWR, a : DAC, b: ADC, c: RV4162, d: J14 */
+#define GP_I2C2_TCA9546_RESET	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLDN),
+
+	/* i2c2b ISL28022FUZ ADC */
+#define GPIRQ_ISL28022		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+
+	/* i2c2c rv4162 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* i2c2d J14, pin 4 */
+#define GPIRQ_I2C2D_J14		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+
+#define GPIRQ_I2C3_J22	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLDN),
+
+	/* PWM2 - Backlight on LVDS2 connector: J5, pin 20 */
+#define GP_BACKLIGHT_LVDS2	IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J4, pin 20 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for bluetooth */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+#define GP_UART5_TX_EN		IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLDN),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Silex */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLDN),
+
+	/* Silex */
+#define GPIRQ_WIFI		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, wm8960 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2  */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable);
+}
+
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_BACKLIGHT_LVDS2, enable);
+}
+
+int board_fbp_detect_i2c(struct display_info_t const *di)
+{
+	int ret;
+	int gp = di->bus >> 8;
+	u8 orig_i2c_bus;
+
+	if (gp)
+		gpio_set_value(gp, 1);
+	orig_i2c_bus = i2c_get_bus_num();
+	ret = i2c_set_bus_num(di->bus & 0xff);
+	if (ret == 0) {
+		ret = i2c_write(0x70, (di->fbtype == FB_LVDS2) ? 8 : 2,
+				1, NULL, 0);
+		if (!ret) {
+			ret = i2c_probe(di->addr);
+			i2c_write(0x70, 0, 1, NULL, 0);
+		}
+	}
+	i2c_set_bus_num(orig_i2c_bus);
+	if (gp)
+		gpio_set_value(gp, 0);
+	return (ret == 0);
+}
+
+static const struct display_info_t displays[] = {
+	/* ft5x06 */
+	VD_DT070BTFT(LVDS, board_fbp_detect_i2c, GP_I2C1_TCA9546_RESET << 8, 0x38),
+	VD_DT070BTFT(LVDS2, board_fbp_detect_i2c, GP_I2C1_TCA9546_RESET << 8, 0x38),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_CAN1_STANDBY,
+	GP_RGMII_PHY_RESET,
+	GP_I2C1_TCA9546_A0,
+	GP_I2C1_TCA9546_A1,
+	GP_I2C1_TCA9546_RESET,
+	GP_WM8960_AMP_STDBY,
+	GP_WM8960_AMP_MUTE,
+	GP_WM8960_AMP_G0,
+	GP_WM8960_AMP_G1,
+	GP_I2C2_TCA9546_RESET,
+	GP_PCIE_RESET,
+	GP_PCIE_DISABLE,
+	GP_BACKLIGHT_LVDS2,
+	GP_BACKLIGHT_LVDS,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_UART5_TX_EN,
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_BT_CLK_REQ,
+	GP_BT_HOST_WAKE,
+	GP_WIFI_WAKE,
+	GP_WIFI_QOW,
+	GP_TP55,
+	GP_TP71,
+	GP_TP74,
+	GP_TP124,
+	GP_TP125,
+	GP_TP151,
+	GP_TP152,
+	GP_TP153,
+	GP_WM8960_MIC_DET,
+	GPIRQ_I2C1B_J7,
+	GPIRQ_I2C1D_J6,
+	GPIRQ_ISL28022,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_I2C2D_J14,
+	GP_LVDS,
+	GP_LVDS2,
+	GPIRQ_I2C3_J22,
+	GP_USDHC3_CD,
+	GPIRQ_WIFI,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp55",	GP_TP55,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/ltch/ltch_q2g.cfg u-boot-imx6/board/boundary/ltch/ltch_q2g.cfg
--- u-boot-2017.07/board/boundary/ltch/ltch_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ltch/ltch_q2g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ltch/MAINTAINERS u-boot-imx6/board/boundary/ltch/MAINTAINERS
--- u-boot-2017.07/board/boundary/ltch/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ltch/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+LTCH BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ltch/
+F:	include/configs/ltch.h
+F:	configs/ltch_q2g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/ltch/Makefile u-boot-imx6/board/boundary/ltch/Makefile
--- u-boot-2017.07/board/boundary/ltch/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ltch/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ltch.o
diff -Nru u-boot-2017.07/board/boundary/mcs/6x_bootscript-recovery.txt u-boot-imx6/board/boundary/mcs/6x_bootscript-recovery.txt
--- u-boot-2017.07/board/boundary/mcs/6x_bootscript-recovery.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/6x_bootscript-recovery.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,39 @@
+setenv stdout serial,vga;
+
+setenv bootargs enable_wait_mode=off console=ttymxc1,115200 consoleblank=0
+setenv bootargs $bootargs rootwait root=/dev/mmcblk0p1
+
+fivewire='';
+if gpio input 193 ; then ; else fivewire=1 ; fi
+if gpio input 130 ; then fivewire=1 ; fi
+
+if itest.s x == x$fivewire ; then
+        # pin 193 (GP7:1) is low - 4-wire screen
+        echo "------ Four wire screen" ;
+        setenv bootargs $bootargs ar1020_i2c.calibration=-20,-21308,85584968,13901,-11,-1120224,65536,1280,800
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB666
+else
+        echo "------ Five wire screen" ;
+        setenv bootargs $bootargs ar1020_i2c.calibration=22737,-182,-4169360,5,-14290,54938792,65536,1280,800
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB24
+fi
+
+setenv nextcon 1;
+while test "4" -ne $nextcon ; do
+        setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+        setexpr nextcon $nextcon + 1 ;
+done
+
+if ${fs}load ${dtype} ${disk}:1 10800000 uImage-usbwrite ; then
+        if ${fs}load ${dtype} ${disk}:1 12800000 uramdisk-usbwrite.img ; then
+           if itest.s x$havedtb == x ; then
+                        bootm 10800000 12800000 ;
+           else
+                        bootm 10800000 12800000 12000000 ;
+           fi
+        else
+                echo "------ error loading ram-disk uramdisk-usbwrite.img";
+        fi
+else
+        echo "------ error loading kernel uImage-usbwrite";
+fi
diff -Nru u-boot-2017.07/board/boundary/mcs/6x_bootscript.txt u-boot-imx6/board/boundary/mcs/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/mcs/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/6x_bootscript.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,55 @@
+setenv stdout serial,vga;
+
+setenv bootargs enable_wait_mode=off console=ttymxc1,115200 consoleblank=0
+setenv bootargs $bootargs rootwait root=/dev/mmcblk0p1
+
+fivewire='';
+if gpio input 193 ; then ; else fivewire=1 ; fi
+if gpio input 130 ; then ; else fivewire=1 ; fi
+
+if itest.s x == x$fivewire ; then
+        # pin 193 (GP7:1) is low - 4-wire screen
+        echo "------ Four wire screen" ;
+        setenv bootargs $bootargs ar1020_i2c.calibration=-20808,53,84144280,-140,13747,-878712,65536,1280,800
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB666
+else
+        echo "------ Five wire screen" ;
+        setenv bootargs $bootargs ar1020_i2c.calibration=22737,-182,-4169360,5,-14290,54938792,65536,1280,800
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB24
+fi
+
+setenv nextcon 1;
+while test "4" -ne $nextcon ; do
+        setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+        setexpr nextcon $nextcon + 1 ;
+done
+
+if kbd ; then
+        if itest.s xP == x$keybd ; then
+                if ${fs}load ${dtype} ${disk}:1 10800000 /boot/uImage-usbwrite ; then
+                        if ${fs}load ${dtype} ${disk}:1 12800000 /boot/uramdisk-usbwrite.img ; then
+                           if itest.s x$havedtb == x ; then
+                                        bootm 10800000 12800000 ;
+                           else
+                                        bootm 10800000 12800000 12000000 ;
+                           fi
+                        fi
+                fi
+        fi
+fi
+
+setenv initrd_addr 0x12a00000
+setenv initrd_high 0xffffffff
+
+if ${fs}load mmc ${disk}:1 ${initrd_addr} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+echo 'Loading Linux...' ;
+if ${fs}load mmc ${disk}:1 10800000 /vmlinuz ; then
+	bootz 10800000 ${initrd_addr}:${initrd_size}
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/mcs/6x_bootscript-ubuntu-3.14.txt u-boot-imx6/board/boundary/mcs/6x_bootscript-ubuntu-3.14.txt
--- u-boot-2017.07/board/boundary/mcs/6x_bootscript-ubuntu-3.14.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/6x_bootscript-ubuntu-3.14.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,157 @@
+setenv stdout serial,vga;
+setenv bootargs ''
+
+a_script=0x10800000
+a_zImage=0x10800000
+a_fdt=0x13000000
+a_ramdisk=0x13800000
+a_initrd=0x13a00000
+
+setenv initrd_high 0xffffffff
+if itest.s "x" == "x${dtbname}" ; then
+	if itest.s x6SOLO == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	else
+		dtbname=imx6q-${board}.dtb;
+	fi
+fi
+
+
+if itest.s x${bootpart} == x ; then
+	bootpart=1
+fi
+
+if itest.s x${dtype} == x ; then
+	dtype=mmc
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_fdt} ${bootdir}${dtbname} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}${dtbname}";
+	exit;
+fi
+
+cmd_xxx_present=
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+	cmd_xxx_present=1;
+fi
+
+setenv bootargs "${bootargs} enable_wait_mode=off console=${console},115200 consoleblank=0 rootwait fixrtc"
+
+fivewire='';
+if gpio input 193 ; then ; else fivewire=1 ; fi
+if gpio input 130 ; then ; else fivewire=1 ; fi
+
+if itest.s x == x$fivewire ; then
+        # pin 193 (GP7:1) is low - 4-wire screen
+        echo "------ Four wire screen" ;
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB666
+        setenv bootargs $bootargs fbcon=rotate:2
+else
+        echo "------ Five wire screen" ;
+        setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB24
+fi
+setenv bootargs "${bootargs} ar1020_i2c.calibration=65536,0,0,0,65536,0,65536,4095,4095"
+
+setenv nextcon 1;
+while test "4" -ne $nextcon ; do
+        setenv bootargs "${bootargs} video=mxcfb${nextcon}:off"
+        setexpr nextcon $nextcon + 1 ;
+done
+
+if itest.s "x" != "x${cmd_lcd}" ; then
+	run cmd_lcd
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds}" ; then
+	run cmd_lvds
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds2}" ; then
+	run cmd_lvds2
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" == "x${cmd_xxx_present}" ; then
+	echo "!!!!!!!!!!!!!!!!"
+	echo "warning: your u-boot may be outdated, please upgrade"
+	echo "!!!!!!!!!!!!!!!!"
+fi
+
+
+if test "usb" = "${dtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bootpart}" ;
+else
+	setenv bootargs "${bootargs} root=/dev/mmcblk${disk}p${bootpart}"
+fi
+
+if itest.s "yes" == "${dosplash}" ; then
+	setenv bootargs ${bootargs} splash quiet plymouth.ignore-serial-consoles
+fi
+
+if itest.s "x" != "x${overlayfs}" ; then
+	setenv bootargs ${bootargs} overlayfs=${overlayfs}
+	if itest.s "x" != "x${ofs-size}" ; then
+		setenv bootargs ${bootargs} ofs-size=${ofs-size}
+	fi
+fi
+
+if itest.s "x" != "x${cma}" ; then
+	setenv bootargs ${bootargs} cma=${cma}
+fi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if kbd ; then
+        if itest.s xP == x${keybd} ; then
+                if ${fs}load ${dtype} ${disk}:${bootpart} ${a_zImage} ${bootdir}/uImage-usbwrite ; then
+                        if ${fs}load ${dtype} ${disk}:${bootpart} ${a_ramdisk} ${bootdir}/uramdisk-usbwrite.img ; then
+                           if itest.s x$havedtb == x ; then
+                                        bootm ${a_zImage} ${a_ramdisk} ;
+                           else
+                                        bootm ${a_zImage} ${a_initrd} ${a_fdt} ;
+                           fi
+                        fi
+                fi
+        fi
+fi
+
+echo "----------- trying to load /initrd.img";
+if load ${dtype} ${disk}:${bootpart} ${a_initrd} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+echo 'Loading Linux...' ;
+if itest.s x${haverd} == x ; then
+	if load ${dtype} ${disk}:${bootpart} ${a_zImage} /vmlinuz ; then
+		bootz ${a_zImage} - ${a_fdt}
+	fi
+else
+	if load ${dtype} ${disk}:${bootpart} ${a_zImage} /vmlinuz ; then
+		bootz ${a_zImage} ${a_initrd}:${initrd_size} ${a_fdt} ;
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/mcs/Kconfig u-boot-imx6/board/boundary/mcs/Kconfig
--- u-boot-2017.07/board/boundary/mcs/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,20 @@
+if TARGET_MCS
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "mcs"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mcs"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/mcs/MAINTAINERS u-boot-imx6/board/boundary/mcs/MAINTAINERS
--- u-boot-2017.07/board/boundary/mcs/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,8 @@
+MCS BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/mcs/
+F:	include/configs/mcs.h
+F:	configs/mcsquad_defconfig
+F:	configs/mcssolo_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/mcs/Makefile u-boot-imx6/board/boundary/mcs/Makefile
--- u-boot-2017.07/board/boundary/mcs/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mcs.o
diff -Nru u-boot-2017.07/board/boundary/mcs/mcs.c u-boot-imx6/board/boundary/mcs/mcs.c
--- u-boot-2017.07/board/boundary/mcs/mcs.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/mcs.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+static iomux_v3_cfg_t const init_pads[] = {
+	/* ECSPI1 pads */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS		IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* GPIO_KEYS - Shutdown request on J55 */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+	/* J5 4-wire/5-wire select (4-wire is 0) */
+#define GP_4_5_WIRE_SELECT	IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLDN),
+	/* SD3_DAT4 - jumpered 4-wire/5-wire select on first rev (4-wire was low) */
+#define GP_4_5_WIRE_SELECT_R1	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLDN),
+
+	/* HOGS - general gpios */
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),	/* J54 pin 9 */
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),	/* J54 pin 6 */
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLUP),	/* J54 pin 5 */
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLUP),	/* J54 pin 4 */
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLUP),	/* J54 pin 3 */
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLUP),	/* J54 pin 2 */
+
+	/* i2c1_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+
+	/* i2c3_ar1021 touch screen */
+#define GPIRQ_AR1021		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),
+
+	/* PWM4 on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+#define GP_LVDS_DE_15_4	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),	/* usbotg power */
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+#define GP_UART3_TX_EN		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLDN),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+#define GP_UART4_TX_EN		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(CSI0_DAT14__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__UART5_RX_DATA, UART_PAD_CTRL),
+#define GP_UART5_TX_EN		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLDN),
+
+	/* USB host */
+//	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC2_CD		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* USDHC3 */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP), /* RESET */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, RV4162 RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 through TXS0108E buffer - external J54 pins 7(clock) and 8(data) */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, AR1021 touch, external J4 (pin 30 clock, 32 data)  */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int board_ehci_power(int port, int on)
+{
+       if (port)
+               return 0;
+       gpio_set_value(GP_REG_USBOTG, on);
+       return 0;
+}
+
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC2_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		mdelay(100);	/* let panel sync up before enabling backlight */
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+int fbp_detect_gpio(struct display_info_t const *di)
+{
+	int val;
+
+	val = gpio_get_value(GP_4_5_WIRE_SELECT);
+	if (val)
+		return 1;	/* 5 wire */
+	val = gpio_get_value(GP_4_5_WIRE_SELECT_R1);
+	return val;
+}
+
+static const struct display_info_t displays[] = {
+	VD_HANNSTAR7(LVDS, NULL, 0, 0x38),
+	/* has 5 - wire touchscreen */
+	VD_LD101WX1(LVDS, fbp_detect_gpio, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_UART3_TX_EN,
+	GP_UART4_TX_EN,
+	GP_UART5_TX_EN,
+	GP_BACKLIGHT_LVDS,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_4_5_WIRE_SELECT,
+	GP_4_5_WIRE_SELECT_R1,
+	GPIRQ_ENET_PHY,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_AR1021,
+	GP_USDHC2_CD,
+	GP_USDHC3_CD,
+	GP_GPIOKEY_POWER,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"power",	GP_GPIOKEY_POWER,	'P', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/mcs/mcsquad.cfg u-boot-imx6/board/boundary/mcs/mcsquad.cfg
--- u-boot-2017.07/board/boundary/mcs/mcsquad.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/mcsquad.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K256M16HA-125:E */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/mcs/mcssolo1g_64bit.cfg u-boot-imx6/board/boundary/mcs/mcssolo1g_64bit.cfg
--- u-boot-2017.07/board/boundary/mcs/mcssolo1g_64bit.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/mcssolo1g_64bit.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 13 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x423f0240
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x022e022c
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4221022e
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0215021b
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4a4c504d
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x4d4e4f4b
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x33342c32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3333322c
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00470048
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x003d0046
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x002d002f
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x002d0045
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/mcs/mcssolo.cfg u-boot-imx6/board/boundary/mcs/mcssolo.cfg
--- u-boot-2017.07/board/boundary/mcs/mcssolo.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/mcssolo.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* MT41K256M16HA-125:E */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/mcs/savesplash.txt u-boot-imx6/board/boundary/mcs/savesplash.txt
--- u-boot-2017.07/board/boundary/mcs/savesplash.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mcs/savesplash.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,41 @@
+if itest.s a$splashfile == a; then
+        splashfile=mcs.bmp.gz
+fi
+
+splashflashaddr=0xf0000;
+
+setenv stdout serial,vga
+if ${fs}load ${dtype} ${disk}:1 12000000 $splashfile ; then
+      echo "read $filesize bytes from SD card" ;
+      if sf probe ; then
+	   if sf read 0x12400000 $splashflashaddr $filesize ; then
+	       if cmp.b 0x12000000 0x12400000 $filesize ; then
+		   echo "------- splash images match" ;
+	       else
+		   echo "re-program splash image" ;
+		   sf erase $splashflashaddr +0x$filesize ;
+		   sf write 0x12000000 $splashflashaddr $filesize ;
+		   echo "verifying" ;
+		   if sf read 0x12400000 $splashflashaddr $filesize ; then
+		       if cmp.b 0x12000000 0x12400000 $filesize ; then
+			   echo "Splash image upgraded.";
+		       else
+			   echo "Read verification error" ;
+		       fi
+		   else
+			echo "Error re-reading EEPROM" ;
+		   fi
+	       fi
+               if itest.s "$bmpsize" != "$filesize" ; then
+                   setenv bmpsize $filesize;
+                   saveenv;
+               fi
+	   else
+	       echo "Error reading splash image from EEPROM" ;
+	   fi
+      else
+	   echo "Error initializing EEPROM" ;
+      fi ;
+else
+     echo "No splash image $splashfile found on SD card" ;
+fi
diff -Nru u-boot-2017.07/board/boundary/med/6x_bootscript.txt u-boot-imx6/board/boundary/med/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/med/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/6x_bootscript.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,126 @@
+if ${fs}load mmc ${disk}:1 10008000 logo.bmp.gz ; then
+	bmp d 10008000
+fi
+
+setenv bootargs enable_wait_mode=off
+
+setenv i2cres rtcerr
+if i2c dev 2 ; then
+	if i2c read 0x6f 0.1 6 0x10004000 ; then
+		mw.b 10004006 0 6
+		if cmp.b 10004000 10004006 6 ; then
+			echo "RTC not programmed" ;
+			if i2c mw 0x6f 7.1 0x90 ; then
+				if i2c mw 0x6f 0.1 0x04 6 ; then
+					echo "Initialized RTC" ;
+					setenv i2cres rtcinit ;
+				else
+					setenv i2cres rtcerr-fill
+				fi
+			else
+				setenv i2cres rtcerr-wrinit
+			fi
+		else
+			echo "non-blank RTC data";
+			setenv i2cres rtcok ;
+		fi
+	else
+		setenv i2cres rtcerr-read
+	fi
+else
+	setenv i2cres rtcerr-dev
+fi
+setenv bootargs $bootargs $i2cres
+setenv i2cres
+
+setenv nextcon 0;
+setenv bootargs $bootargs video=mxcfb0:dev=lcd,LB043,if=RGB24
+setenv bootargs $bootargs ft5x06_ts.screenres=800,1280
+# rotate touch coordinates 90 degrees clockwise
+setenv bootargs $bootargs ft5x06_ts.calibration=0,-40928,31391744,40941,0,0,65536
+setenv bootargs $bootargs g_ether.dev_addr=55:aa:55:aa:55:aa
+setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+setenv fbmem 28M
+setenv nextcon 1
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+	setenv fbmem $fbmem,28M
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+fi
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if kbd ; then
+	if itest.s xD == x$keybd ; then
+		if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage-usbwrite ; then
+			if ${fs}load ${dtype} ${disk}:1 12800000 ${bootdir}uramdisk-usbwrite.img ; then
+			   if itest.s x$havedtb == x ; then
+					bootm 10800000 12800000 ;
+			   else
+					bootm 10800000 12800000 12000000 ;
+			   fi
+			fi
+		fi
+	fi
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/med/6x_bootscript-yocto.txt u-boot-imx6/board/boundary/med/6x_bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/med/6x_bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/6x_bootscript-yocto.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,130 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+if ${fs}load mmc ${disk}:1 10008000 logo.bmp.gz ; then
+	bmp d 10008000
+fi
+
+setenv bootargs enable_wait_mode=off
+
+setenv i2cres rtcerr
+if i2c dev 2 ; then
+	if i2c read 0x6f 0.1 6 0x10004000 ; then
+		mw.b 10004006 0 6
+		if cmp.b 10004000 10004006 6 ; then
+			echo "RTC not programmed" ;
+			if i2c mw 0x6f 7.1 0x90 ; then
+				if i2c mw 0x6f 0.1 0x04 6 ; then
+					echo "Initialized RTC" ;
+					setenv i2cres rtcinit ;
+				else
+					setenv i2cres rtcerr-fill
+				fi
+			else
+				setenv i2cres rtcerr-wrinit
+			fi
+		else
+			echo "non-blank RTC data";
+			setenv i2cres rtcok ;
+		fi
+	else
+		setenv i2cres rtcerr-read
+	fi
+else
+	setenv i2cres rtcerr-dev
+fi
+setenv bootargs $bootargs $i2cres
+setenv i2cres
+
+setenv nextcon 0;
+setenv bootargs $bootargs video=mxcfb0:dev=lcd,LB043,if=RGB24
+setenv bootargs $bootargs ft5x06_ts.screenres=800,1280
+# rotate touch coordinates 90 degrees clockwise
+setenv bootargs $bootargs ft5x06_ts.calibration=0,-40928,31391744,40941,0,0,65536
+setenv bootargs $bootargs g_ether.dev_addr=55:aa:55:aa:55:aa
+setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+setenv fbmem 28M
+setenv nextcon 1
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+	setenv fbmem $fbmem,28M
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+fi
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if kbd ; then
+	if itest.s xD == x$keybd ; then
+		if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage-usbwrite ; then
+			if ${fs}load ${dtype} ${disk}:1 12800000 ${bootdir}uramdisk-usbwrite.img ; then
+			   if itest.s x$havedtb == x ; then
+					bootm 10800000 12800000 ;
+			   else
+					bootm 10800000 12800000 12000000 ;
+			   fi
+			fi
+		fi
+	fi
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/med/Kconfig u-boot-imx6/board/boundary/med/Kconfig
--- u-boot-2017.07/board/boundary/med/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,20 @@
+if TARGET_MED
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "med"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "med"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/med/MAINTAINERS u-boot-imx6/board/boundary/med/MAINTAINERS
--- u-boot-2017.07/board/boundary/med/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,6 @@
+MED BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/med/
+F:	include/configs/med.h
+F:	configs/med_defconfig
diff -Nru u-boot-2017.07/board/boundary/med/Makefile u-boot-imx6/board/boundary/med/Makefile
--- u-boot-2017.07/board/boundary/med/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := med.o
diff -Nru u-boot-2017.07/board/boundary/med/med.c u-boot-imx6/board/boundary/med/med.c
--- u-boot-2017.07/board/boundary/med/med.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/med.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <spi.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC4_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+
+	/* GPIO_KEYS */
+#define GP_S2	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),	/* S2 */
+#define GP_S4	IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),	/* S4 */
+#define GP_S3	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),	/* S3 */
+
+	/* Misc inputs */
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),	/* bidirectional - NXP P0-8 */
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),	/* bidirectional - NXP P0-14 */
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),	/* bidirectional - NXP P0-21 */
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),	/* bidirectional - NXP P0-21 */
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, WEAK_PULLUP),	/* bidirectional - NXP P2-10 */
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),	/* bidirectional - NXP RST_OUT */
+	/* Misc outputs */
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),	/* TPS3823 - reset generator for NXP active hi */
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),	/* output - to NXP P4-30 */
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),	/* 74LVC1G32 - WDT active low - reset to I.MX */
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP), 	/* output - to NXP P4-31 */
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* output - to NXP P1-10 */
+
+	/* Backlight on LVDS connector */
+#define GP_BACKLIGHT_LVDS IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* UART1 */
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC_PAD_CTRL),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP), /* CD */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, J15:pins 5-6 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2, HDMI EDID, RTC */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3,  Touch screen, FDC6301 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BACKLIGHT_LVDS,
+	GP_S2,
+	GP_S4,
+	GP_S3,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"S2",	GP_S2,	'2', 1},
+	{"S4",	GP_S4,	'4', 1},
+	{"S3",	GP_S3,	'3', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/med/med_q1g.cfg u-boot-imx6/board/boundary/med/med_q1g.cfg
--- u-boot-2017.07/board/boundary/med/med_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/med_q1g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/med/savesplash.txt u-boot-imx6/board/boundary/med/savesplash.txt
--- u-boot-2017.07/board/boundary/med/savesplash.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/med/savesplash.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,46 @@
+if itest.s a$splashfile == a; then
+        splashfile=${board}.bmp.gz
+fi
+
+setenv stdout serial,vga
+if ${fs}load ${dtype} ${disk}:1 12000000 $splashfile ; then
+      echo "read $filesize bytes from SD card" ;
+      if sf probe ; then
+	   if sf read 0x12400000 $splashflash $filesize ; then
+	       if cmp.b 0x12000000 0x12400000 $filesize ; then
+		   echo "------- splash images match" ;
+                   if itest.s "x$filesize" != "x$splashsize" ; then
+                        echo "update splashsize" ;
+                        setenv splashsize $filesize;
+                        saveenv
+                   fi
+	       else
+		   echo "re-program splash image" ;
+		   sf erase $splashflash +0x$filesize ;
+		   sf write 0x12000000 $splashflash $filesize ;
+		   echo "verifying" ;
+		   if sf read 0x12400000 $splashflash $filesize ; then
+		       if cmp.b 0x12000000 0x12400000 $filesize ; then
+			   echo "Splash image upgraded.";
+                           setenv splashsize $filesize;
+                           saveenv
+		       else
+			   echo "Read verification error" ;
+		       fi
+		   else
+			echo "Error re-reading EEPROM" ;
+		   fi
+	       fi
+               if itest.s "$bmpsize" != "$filesize" ; then
+                   setenv bmpsize $filesize;
+                   saveenv;
+               fi
+	   else
+	       echo "Error reading splash image from EEPROM" ;
+	   fi
+      else
+	   echo "Error initializing EEPROM" ;
+      fi ;
+else
+     echo "No splash image $splashfile found on SD card" ;
+fi
diff -Nru u-boot-2017.07/board/boundary/mtp/Kconfig u-boot-imx6/board/boundary/mtp/Kconfig
--- u-boot-2017.07/board/boundary/mtp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_MTP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "mtp"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mtp"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/mtp/MAINTAINERS u-boot-imx6/board/boundary/mtp/MAINTAINERS
--- u-boot-2017.07/board/boundary/mtp/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+MTP BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/mtp/
+F:	include/configs/mtp.h
+F:	configs/mtp_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/mtp/Makefile u-boot-imx6/board/boundary/mtp/Makefile
--- u-boot-2017.07/board/boundary/mtp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mtp.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff -Nru u-boot-2017.07/board/boundary/mtp/mtp2g.cfg u-boot-imx6/board/boundary/mtp/mtp2g.cfg
--- u-boot-2017.07/board/boundary/mtp/mtp2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/mtp2g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#ifdef CONFIG_MX6QP
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43120327
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x030f0307
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x431b032c
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0312025e
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4434383b
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3e363345
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37373c38
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4331453d
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00130013
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001c0015
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000f0021
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000a0017
+#define WALAT	1
+#else
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+#endif
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/mtp/mtp.c u-boot-imx6/board/boundary/mtp/mtp.c
--- u-boot-2017.07/board/boundary/mtp/mtp.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/mtp.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+/* PAD_CTL_DSE_80ohm is 50 Ohms at 3.3V */
+#define I2C_PAD_CTRL_3P3V (PAD_CTL_PUS_100K_UP |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_80ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USBH2_CTRL	(PAD_CTL_PUS_100K_DOWN | 		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_SPEED_HIGH |		\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 pads */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+#define GP_TP142		IMX_GPIO_NR(1, 29)
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLUP),
+
+	/* i2c1 rtc rv4162 */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, OUTPUT_40OHM),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBH2 */
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__USB_H2_STROBE, USBH2_CTRL),
+	IOMUX_PAD_CTRL(RGMII_TXC__USB_H2_DATA, USBH2_CTRL),
+#define GP_USBH2_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, OUTPUT_40OHM),
+
+	/* USB OTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 pads */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, OUTPUT_40OHM),	/* eMMC reset */
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL_3P3V),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL_3P3V),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL_3P3V),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port != 2)
+		return 0;
+	/* Reset USB hub */
+	gpio_direction_output(GP_USBH2_HUB_RESET, 0);
+	mdelay(2);
+	gpio_set_value(GP_USBH2_HUB_RESET, 1);
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+static const unsigned short gpios_out_low[] = {
+	GP_REG_USBOTG,
+	GP_USBH2_HUB_RESET,
+	/* Disable wl1271 */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_PCIE_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,		/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_USDHC3_CD,
+	GPIRQ_WL1271_WL,
+	GP_TP142,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			NULL, 0, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp142",	GP_TP142,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/mtp/mtp.cfg u-boot-imx6/board/boundary/mtp/mtp.cfg
--- u-boot-2017.07/board/boundary/mtp/mtp.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/mtp.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#ifdef CONFIG_MX6QP
+/* 1 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x430c0320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0300026c
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43140324
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x030c0260
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42343c3e
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x423e364a
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x36343838
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3e30403a
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00140014
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001d0016
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000f001f
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00080017
+#define WALAT	0
+#else
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+#endif
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TQ2G63FFR-H9C */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/mtp/spl.c u-boot-imx6/board/boundary/mtp/spl.c
--- u-boot-2017.07/board/boundary/mtp/spl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mtp/spl.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/mx6-ddr.h>
+#include <asm/imx-common/boot_mode.h>
+
+#include <i2c.h>
+#include <spl.h>
+
+#if 0
+void board_init_f(ulong dummy)
+{
+#if 0
+	arch_cpu_init();
+	board_early_init_f();
+	timer_init();
+	preloader_console_init();
+
+	print_cpuinfo();
+	board_init_r(NULL, 0);
+#endif
+}
+#endif
+
+void spl_board_init(void)
+{
+#if 0
+	int i;
+	u32 const *regs ;
+	int num_regs;
+	unsigned char mac_address[6];
+        imx_get_mac_from_fuse(0,mac_address);
+	printf("ethaddr: %pM\n", mac_address);
+
+	if (is_cpu_type(MXC_CPU_MX6Q)) {
+#if 1
+		regs = mx6q_1g;
+		num_regs = ARRAY_SIZE(mx6q_1g);
+#else
+		regs = mx6q_2g;
+		num_regs = ARRAY_SIZE(mx6q_2g);
+#endif
+	} else {
+#if CONFIG_DDR_MB == 512
+		regs = mx6dl_512m;
+		num_regs = ARRAY_SIZE(mx6dl_512m);
+printf("Configuring for 512MiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 1024
+		regs = mx6dl_1gn;
+		num_regs = ARRAY_SIZE(mx6dl_1gn);
+printf("Configuring for 1GiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 2048
+		regs = mx6dl_2g;
+		num_regs = ARRAY_SIZE(mx6dl_2g);
+printf("Configuring for 2GiB wide memory bus\n");
+#endif
+	}
+	for (i=0; i < num_regs; i+=2) {
+		writel(regs[i+1],regs[i]);
+	}
+        dram_init();
+#endif
+	printf("%s\n", __func__);
+}
+
+u32 spl_boot_device(void)
+{
+	printf("%s\n", __func__);
+#if 0
+	unsigned reg;
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	printf("%s: sbmr1 == 0x%08x\n", __func__, psrc->sbmr1);
+	printf("%s: gpr9  == 0x%08x\n", __func__, psrc->gpr9);
+	printf("%s: gpr10 == 0x%08x\n", __func__, psrc->gpr10);
+	return BOOT_DEVICE_USB;
+#endif
+#if 1
+	return BOOT_DEVICE_SPI;
+#endif
+}
+
+#if 0
+void spl_usb_load_image(void)
+{
+	boot_mode_apply(MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00));
+	reset_cpu(0);
+}
+
+#endif
diff -Nru u-boot-2017.07/board/boundary/mx6_r/6x_bootscript.txt u-boot-imx6/board/boundary/mx6_r/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/mx6_r/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/6x_bootscript.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,126 @@
+if ${fs}load mmc ${disk}:1 10008000 logo.bmp.gz ; then
+	bmp d 10008000
+fi
+
+setenv bootargs enable_wait_mode=off
+
+setenv i2cres rtcerr
+if i2c dev 2 ; then
+	if i2c read 0x6f 0.1 6 0x10004000 ; then
+		mw.b 10004006 0 6
+		if cmp.b 10004000 10004006 6 ; then
+			echo "RTC not programmed" ;
+			if i2c mw 0x6f 7.1 0x90 ; then
+				if i2c mw 0x6f 0.1 0x04 6 ; then
+					echo "Initialized RTC" ;
+					setenv i2cres rtcinit ;
+				else
+					setenv i2cres rtcerr-fill
+				fi
+			else
+				setenv i2cres rtcerr-wrinit
+			fi
+		else
+			echo "non-blank RTC data";
+			setenv i2cres rtcok ;
+		fi
+	else
+		setenv i2cres rtcerr-read
+	fi
+else
+	setenv i2cres rtcerr-dev
+fi
+setenv bootargs $bootargs $i2cres
+setenv i2cres
+
+setenv nextcon 0;
+setenv bootargs $bootargs video=mxcfb0:dev=lcd,LB043,if=RGB24
+setenv bootargs $bootargs ft5x06_ts.screenres=800,1280
+# rotate touch coordinates 90 degrees clockwise
+setenv bootargs $bootargs ft5x06_ts.calibration=0,-40928,31391744,40941,0,0,65536
+setenv bootargs $bootargs g_ether.dev_addr=55:aa:55:aa:55:aa
+setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+setenv fbmem 28M
+setenv nextcon 1
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+	setenv fbmem $fbmem,28M
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+fi
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if kbd ; then
+	if itest.s xD == x$keybd ; then
+		if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage-usbwrite ; then
+			if ${fs}load ${dtype} ${disk}:1 12800000 ${bootdir}uramdisk-usbwrite.img ; then
+			   if itest.s x$havedtb == x ; then
+					bootm 10800000 12800000 ;
+			   else
+					bootm 10800000 12800000 12000000 ;
+			   fi
+			fi
+		fi
+	fi
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/mx6_r/6x_bootscript-yocto.txt u-boot-imx6/board/boundary/mx6_r/6x_bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/mx6_r/6x_bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/6x_bootscript-yocto.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,130 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+if ${fs}load mmc ${disk}:1 10008000 logo.bmp.gz ; then
+	bmp d 10008000
+fi
+
+setenv bootargs enable_wait_mode=off
+
+setenv i2cres rtcerr
+if i2c dev 2 ; then
+	if i2c read 0x6f 0.1 6 0x10004000 ; then
+		mw.b 10004006 0 6
+		if cmp.b 10004000 10004006 6 ; then
+			echo "RTC not programmed" ;
+			if i2c mw 0x6f 7.1 0x90 ; then
+				if i2c mw 0x6f 0.1 0x04 6 ; then
+					echo "Initialized RTC" ;
+					setenv i2cres rtcinit ;
+				else
+					setenv i2cres rtcerr-fill
+				fi
+			else
+				setenv i2cres rtcerr-wrinit
+			fi
+		else
+			echo "non-blank RTC data";
+			setenv i2cres rtcok ;
+		fi
+	else
+		setenv i2cres rtcerr-read
+	fi
+else
+	setenv i2cres rtcerr-dev
+fi
+setenv bootargs $bootargs $i2cres
+setenv i2cres
+
+setenv nextcon 0;
+setenv bootargs $bootargs video=mxcfb0:dev=lcd,LB043,if=RGB24
+setenv bootargs $bootargs ft5x06_ts.screenres=800,1280
+# rotate touch coordinates 90 degrees clockwise
+setenv bootargs $bootargs ft5x06_ts.calibration=0,-40928,31391744,40941,0,0,65536
+setenv bootargs $bootargs g_ether.dev_addr=55:aa:55:aa:55:aa
+setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+setenv fbmem 28M
+setenv nextcon 1
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb1:dev=hdmi,1280x720M@60 video=mxcfb2:off video=mxcfb3:off
+	setenv fbmem $fbmem,28M
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+fi
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if kbd ; then
+	if itest.s xD == x$keybd ; then
+		if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage-usbwrite ; then
+			if ${fs}load ${dtype} ${disk}:1 12800000 ${bootdir}uramdisk-usbwrite.img ; then
+			   if itest.s x$havedtb == x ; then
+					bootm 10800000 12800000 ;
+			   else
+					bootm 10800000 12800000 12000000 ;
+			   fi
+			fi
+		fi
+	fi
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/mx6_r/Kconfig u-boot-imx6/board/boundary/mx6_r/Kconfig
--- u-boot-2017.07/board/boundary/mx6_r/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,20 @@
+if TARGET_MX6_R
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "mx6_r"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6_r"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/mx6_r/MAINTAINERS u-boot-imx6/board/boundary/mx6_r/MAINTAINERS
--- u-boot-2017.07/board/boundary/mx6_r/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+MX6_R BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/mx6_r/
+F:	include/configs/mx6_r.h
+F:	configs/mx6_r_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/mx6_r/Makefile u-boot-imx6/board/boundary/mx6_r/Makefile
--- u-boot-2017.07/board/boundary/mx6_r/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6_r.o
diff -Nru u-boot-2017.07/board/boundary/mx6_r/mx6_r.c u-boot-imx6/board/boundary/mx6_r/mx6_r.c
--- u-boot-2017.07/board/boundary/mx6_r/mx6_r.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/mx6_r.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,637 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <spi.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP),	/* pin 1 - back */
+#define GP_GPIOKEY_UP		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),	/* pin 2 - up */
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),	/* pin 3 - Menu */
+#define GP_GPIOKEY_LEFT		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),	/* pin 4 - Left */
+#define GP_GPIOKEY_RIGHT	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),	/* pin 5 - Right */
+#define GP_GPIOKEY_DOWN		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),	/* pin 6 - Down */
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),	/* pin 7 - NC */
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),	/* pin 8 - NC */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(6, 1)
+	IOMUX_PAD_CTRL(CSI0_DAT15__GPIO6_IO01, WEAK_PULLDN),	/* pin 9 inverted, Main power off request */
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLUP),	/* pin 10 - NC */
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),	/* pin 11 - NC */
+
+#define GP_MAIN_POWER			IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, OUTPUT_40OHM),
+
+	/* i2c2 ov5640 mipi Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(5, 21)
+	IOMUX_PAD_CTRL(CSI0_VSYNC__GPIO5_IO21, OUTPUT_40OHM),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(5, 20)
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, OUTPUT_40OHM),
+
+#define GP_LED			IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, OUTPUT_40OHM),
+	/* BAT status */
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),
+
+	/* Misc outputs */
+#define GP_L1			IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, OUTPUT_40OHM),
+
+#define GP_L2			IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, OUTPUT_40OHM),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* reg 3.3v */
+#define GP_REG_3P3V		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, OUTPUT_40OHM),
+
+	/* reg 5v */
+#define GP_REG_5V		IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, OUTPUT_40OHM),
+
+	/* reg 5.4v */
+#define GP_REG_5P4V		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, OUTPUT_40OHM),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__SD3_DATA7, USDHC_PAD_CTRL),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, NO_PAD_CTRL), /* CD */
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static iomux_v3_cfg_t const rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+#ifdef CONFIG_MXC_SPI_DISPLAY
+static int spi_display_read(struct spi_slave *spi, u8 addr, u8 reg, u8 *data, size_t data_len)
+{
+	u8 cmd[2];
+	int ret;
+
+	cmd[0] = addr;
+	cmd[1] = reg;
+	ret = spi_xfer(spi, 2 * 8, cmd, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(3);
+	cmd[0] = addr | 3;
+	ret = spi_xfer(spi, 1 * 8, cmd, NULL, SPI_XFER_BEGIN);
+	if (ret) {
+		debug("%s: Failed to start read for reg 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	ret = spi_xfer(spi, data_len * 8, NULL, data, SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to read data for reg 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	return ret;
+}
+
+static int spi_display_cmds(struct spi_slave *spi, u8 addr, u8 *cmds)
+{
+	u8 cmd_buf[16];
+	int ret = 0;
+
+	printf("%s\n", __func__);
+	while (*cmds) {
+		u8 reg = *cmds++;
+		size_t len = *cmds++;
+
+		cmd_buf[0] = addr;
+		cmd_buf[1] = reg;
+		ret = spi_xfer(spi, 2 * 8, cmd_buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+		if (ret) {
+			debug("%s: Failed to select reg 0x%x, %d\n", __func__, reg, ret);
+			return ret;
+		}
+		udelay(3);
+		cmd_buf[0] = addr | 2;
+		memcpy(&cmd_buf[1], cmds, len);
+		cmds += len;
+		ret = spi_xfer(spi, (len + 1) * 8, cmd_buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+		if (ret) {
+			debug("%s: Failed to write for reg 0x%x, %d\n", __func__, reg, ret);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+static u8 display_init_cmds[] = {
+/* Display Mode Setting */
+	0x36, 1, 0x08,
+	0x3a, 1, 0x70,
+	0xb1, 3, 0x0e, 0x28, 0x0a,
+	0xb2, 2, 0x00, 0xc8,
+	0xb3, 1, 0x00,
+	0xb4, 1, 0x04,
+	0xb5, 5, 0x42, 0x10, 0x10, 0x00, 0x20,
+	0xb6, 6, 0x0b, 0x0f, 0x3c, 0x13, 0x13, 0xe8,
+	0xb7, 5, 0x46, 0x06, 0x0c, 0x00, 0x00,
+/* Power Setting */
+	0xc0, 2, 0x01, 0x11,
+	0xc3, 5, 0x07, 0x03, 0x04, 0x04, 0x04,
+	0xc4, 6, 0x12, 0x24, 0x18, 0x18, 0x02, 0x49,
+	0xc5, 1, 0x6f,
+	0xc6, 2, 0x41, 0x63,
+/* Gamma Setting */
+	0xd0, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+	0xd2, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+	0xd4, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+	0xd1, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+	0xd3, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+	0xd5, 9, 0x03, 0x07, 0x73, 0x35, 0x00, 0x01, 0x20, 0x00, 0x03,
+/* Sleep out */
+	0x11, 0,
+	0
+};
+
+static u8 display_on_cmds[] = {
+	0x29, 0,
+	0
+};
+
+static void enable_spi_rgb(struct display_info_t const *dev)
+{
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	struct spi_slave *spi;
+	int ret;
+
+	printf("%s\n", __func__);
+	gpio_direction_output(GP_BACKLIGHT_RGB, 1);
+	gpio_direction_output(cs_gpio, 1);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, cs_gpio << 8, 1000000, SPI_MODE_3);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	ret = spi_display_cmds(spi, dev->addr, display_init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	mdelay(200);
+	ret = spi_display_cmds(spi, dev->addr, display_on_cmds);
+	if (ret) {
+		printf("%s: Failed to display_on_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	ret = 1;
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return;
+}
+
+/*
+ * Return 1 for successful detection of display
+ */
+static int detect_spi(struct display_info_t const *dev)
+{
+	int ret;
+	unsigned cs_gpio = GP_ECSPI2_CS;
+	unsigned reset_gpio = GP_SPI_DISPLAY_RESET;	/* nandf_d5 */
+	struct spi_slave *spi;
+	u8 data[8];
+
+	printf("%s\n", __func__);
+	gpio_direction_output(cs_gpio, 1);
+	gpio_direction_output(reset_gpio, 1);
+	udelay(1);
+	gpio_direction_output(reset_gpio, 0);
+	udelay(2000);
+	gpio_direction_output(reset_gpio, 1);
+	udelay(1);
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, cs_gpio << 8, 1000000, SPI_MODE_3);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 0;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		ret = 0;
+		goto free_bus;
+	}
+
+	/* Read the dispctl1 */
+	ret = spi_display_read(spi, dev->addr, 0xb5, data, 2);
+	if (ret) {
+		printf("%s: Failed to read dispctl1, %d\n", __func__, ret);
+		ret = 0;
+		goto release_bus;
+	}
+	debug("%s: *(0x%02x) = 0x%02x 0x%02x\n", __func__, 0xb5, data[0], data[1]);
+
+	if ((data[1] == 0) || (data[1] == 0xff)) {
+		ret = 0;
+		goto release_bus;
+	}
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	ret = spi_display_cmds(spi, dev->addr, display_init_cmds);
+	if (ret) {
+		printf("%s: Failed to init %d\n", __func__, ret);
+		ret = 0;
+		goto release_bus;
+	}
+	ret = 1;
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	return ret;
+}
+#endif
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			return enable_spi_rgb(di);
+#endif
+	} else {
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+#ifdef CONFIG_MXC_SPI_DISPLAY
+	VDF_LB043(LCD, "LB043", RGB24, FBF_MODESTR | FBF_SPI, detect_spi, 1, 0x70),
+#endif
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	/* Disable wl1271 */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_REG_USBOTG,
+	GP_OV5640_MIPI_RESET,
+	GP_LED,
+	GP_REG_5V,
+	GP_REG_3P3V,
+	GP_REG_5P4V,
+	GP_L1,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_MAIN_POWER,
+	GP_ECSPI1_NOR_CS,
+	GP_OV5640_MIPI_POWER_DOWN,
+	GP_L2,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BACKLIGHT_RGB,
+	GPIRQ_WL1271_WL,
+	GP_USDHC4_CD,
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_UP,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_LEFT,
+	GP_GPIOKEY_RIGHT,
+	GP_GPIOKEY_DOWN,
+	GP_GPIOKEY_POWER,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"up",		GP_GPIOKEY_UP,		'U', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"left",	GP_GPIOKEY_LEFT,	'L', 1},
+	{"right",	GP_GPIOKEY_RIGHT,	'R', 1},
+	{"down",	GP_GPIOKEY_DOWN,	'D', 1},
+	{"power",	GP_GPIOKEY_POWER,	'P', 0},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
+
+void board_poweroff(void)
+{
+	/* Turn off main power */
+	gpio_direction_output(GP_MAIN_POWER, 0);
+	udelay(1000000);
+}
+
+static int _do_poweroff(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(poweroff, 1, 1, _do_poweroff, "Turn off power", "");
diff -Nru u-boot-2017.07/board/boundary/mx6_r/mx6_r_q2g.cfg u-boot-imx6/board/boundary/mx6_r/mx6_r_q2g.cfg
--- u-boot-2017.07/board/boundary/mx6_r/mx6_r_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/mx6_r/mx6_r_q2g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/neol/Kconfig u-boot-imx6/board/boundary/neol/Kconfig
--- u-boot-2017.07/board/boundary/neol/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/neol/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_NEOL
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "neol"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "neol"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/neol/MAINTAINERS u-boot-imx6/board/boundary/neol/MAINTAINERS
--- u-boot-2017.07/board/boundary/neol/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/neol/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+NEOL BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/neol/
+F:	include/configs/neol.h
+F:	configs/neol_q2g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/neol/Makefile u-boot-imx6/board/boundary/neol/Makefile
--- u-boot-2017.07/board/boundary/neol/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/neol/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := neol.o
diff -Nru u-boot-2017.07/board/boundary/neol/neol.c u-boot-imx6/board/boundary/neol/neol.c
--- u-boot-2017.07/board/boundary/neol/neol.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/neol/neol.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,505 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_SS0              IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+
+	/* ENET(AR8035) pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hog pins*/
+	/*
+	 * reg_5v_dlp
+	 *
+	 * Rev 0 boards should default to DLP enabled, because
+	 * the ROM enables it, and u-boot disabling it causes
+	 * problems.
+	 *
+	 * Rev 1 boards should default to DLP disabled, because
+	 * Linux should be in charge of when to enable
+	 */
+#define GP_5V_DLP_EN_REV0	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+#define GP_5V_DLP_EN_REV1	IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN),
+
+#define GP_STDBY_MODE	IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLUP),
+#define GP_DLPC_BOOTED	IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLUP),
+#define GP_INIT_DONE	IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_RESET	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_KILL		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+#define GP_MICRO_RESET	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+
+#define GP_KEY_IO01	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_KEY_IO02	IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+#define GP_KEY_IO03	IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+
+#define GP_KEY_IO07	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+#define GP_KEY_IO08	IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),
+#define GP_KEY_IO09	IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLUP),
+#define GP_KEY_IO10	IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_KEY_IO11	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+
+#define GP_TP71		IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP72		IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLUP),
+#define GP_TP74		IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP76		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_TP113	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_TP114	IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_TP116	IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_TP118        IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GP_TP121	IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, WEAK_PULLUP),
+#define GP_TP122	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* I2C2 - J14 */
+#define GP_I2C2_J14_PIN3	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GP_I2C2_J14_PIN4	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP),
+#define GP_I2C2_J14_PIN5	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* i2c2_rv4162 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* i2c3, J7 - touch */
+#define GPIRQ_I2C3_J7           IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* PWM1 - Backlight on RGB connector: J15, pin 37 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2  */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC2 - wlan */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+#define GP_WIFI_CLK_REQ		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+#define GP_BT_HOST_WAKE		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_5V_DLP_EN_REV1,
+	GP_RGMII_PHY_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_SS0,
+	GP_5V_DLP_EN_REV0,
+	GP_STDBY_MODE,
+	GP_DLPC_BOOTED,
+	GP_INIT_DONE,
+	GP_RESET,
+	GP_KILL,
+	GP_MICRO_RESET,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_KEY_IO01,
+	GP_KEY_IO02,
+	GP_KEY_IO03,
+	GP_KEY_IO07,
+	GP_KEY_IO08,
+	GP_KEY_IO09,
+	GP_KEY_IO10,
+	GP_KEY_IO11,
+	GP_TP71,
+	GP_TP72,
+	GP_TP74,
+	GP_TP76,
+	GP_TP113,
+	GP_TP114,
+	GP_TP116,
+	GP_TP118,
+	GP_TP121,
+	GP_TP122,
+	GP_I2C2_J14_PIN3,
+	GP_I2C2_J14_PIN4,
+	GP_I2C2_J14_PIN5,
+	GPIRQ_I2C3_J7,
+	GPIRQ_RTC_RV4162,
+	GP_USDHC3_CD,
+	GPIRQ_WL1271_WL,
+	GP_WIFI_WAKE,
+	GP_WIFI_QOW,
+	GP_WIFI_CLK_REQ,
+	GP_BT_HOST_WAKE,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	'1', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/neol/neol_q2g.cfg u-boot-imx6/board/boundary/neol/neol_q2g.cfg
--- u-boot-2017.07/board/boundary/neol/neol_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/neol/neol_q2g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ddr frequency to 528 Mhz using PLL2 */
+
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43100320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x030a027d
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x03150326
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03100258
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42333842
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3d383244
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x373a3c31
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4230443b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0012001b
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001d0015
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00100022
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000d001b
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript.txt u-boot-imx6/board/boundary/nit6xlite/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/6x_bootscript.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,108 @@
+setenv bootargs enable_wait_mode=off fec.disable_giga=1;
+setenv nextcon 0;
+setenv lvds 0;
+
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 1024x600 display";
+fi
+
+if i2c probe 0x41 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no ILI210x touch controller";
+fi
+
+if test "0" -eq $lvds; then
+	echo "Default to wqvga (480x272) display";
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,okaya_480x272,if=RGB24
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "usb" = "${dtype}" ; then
+        setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+elif itest.s "x" == "x$sdphys" ; then
+        setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+elif itest 0 -eq ${disk}; then
+        setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+else
+        setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+dtbname="imx6dl-nit6xlite.dtb";
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript-yocto-3.10.53.txt u-boot-imx6/board/boundary/nit6xlite/6x_bootscript-yocto-3.10.53.txt
--- u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript-yocto-3.10.53.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/6x_bootscript-yocto-3.10.53.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,117 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+setenv bootargs ''
+
+if ${fs}load ${dtype} ${disk}:1 10800000 uEnv.txt ; then
+    env import -t 10800000 $filesize
+fi
+
+if itest.s "x" == "x$dtbname" ; then
+	dtbname=imx6dl-nit6xlite.dtb;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+setenv fdt_addr 0x12000000
+if ${fs}load ${dtype} ${disk}:1 $fdt_addr ${bootdir}$dtbname ; then
+	fdt addr $fdt_addr
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}$dtbname";
+	exit;
+fi
+
+# ------------------- HDMI detection
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	echo "------ have HDMI monitor";
+	if itest.s x == x$allow_noncea ; then
+		setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+else
+	fdt rm hdmi_display
+	echo "------ no HDMI monitor";
+fi
+
+# ------------------- LVDS detection
+# -------- LVDS0
+setenv have_lvds
+i2c dev 2
+if i2c probe 0x04 ; then
+	echo "------ have Freescale display";
+	setenv have_lvds 1
+else
+	echo "------ no Freescale display";
+	fdt rm hannstar;
+fi
+
+if i2c probe 0x38 ; then
+	if itest.s "xLDB-WXGA" == "x$panel"; then
+		screenres=1280,800
+		fdt rm okaya1024x600
+	else
+		screenres=1024,600
+		fdt rm lg1280x800
+	fi
+	setenv have_lvds 1
+	setenv bootargs $bootargs ft5x06_ts.screenres=$screenres
+	if itest.s "x" -ne "x$calibration" ; then
+		setenv bootargs $bootargs ft5x06_ts.calibration=$calibration
+	fi
+else
+	echo "------ no ft5x06 touch controller";
+	fdt rm okaya1024x600
+	fdt rm lg1280x800
+fi
+
+if itest.s "x" == "x$have_lvds"; then
+	fdt rm lvds_display;
+fi
+
+# ------------------- LCD detection
+# since the Nitrogen6_Lite board has on-board TSC2004,
+# we can't test for it.
+#
+# set ignore_lcd to 1 to disable the 480x272 display
+#
+if itest.s "x" != "x$ignore_lcd" ; then
+	echo "------ ignoring LCD display";
+	fdt rm lcd_display;
+fi
+
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "usb" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+elif itest 0 -eq ${disk}; then
+	setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+fi
+
+setenv bootargs $bootargs fec.disable_giga=1
+
+if itest.s "x" != "x$show_fdt" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x$show_env" ; then
+	printenv
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	bootm 10800000 - $fdt_addr
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript-yocto.txt u-boot-imx6/board/boundary/nit6xlite/6x_bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/nit6xlite/6x_bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/6x_bootscript-yocto.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,112 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+setenv bootargs enable_wait_mode=off fec.disable_giga=1;
+setenv nextcon 0;
+setenv lvds 0;
+
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 1024x600 display";
+fi
+
+if i2c probe 0x41 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no ILI210x touch controller";
+fi
+
+if test "0" -eq $lvds; then
+	echo "Default to wqvga (480x272) display";
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,okaya_480x272,if=RGB24
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "usb" = "${dtype}" ; then
+        setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+elif itest.s "x" == "x$sdphys" ; then
+        setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+elif itest 0 -eq ${disk}; then
+        setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+else
+        setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+dtbname="imx6dl-nit6xlite.dtb";
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/Kconfig u-boot-imx6/board/boundary/nit6xlite/Kconfig
--- u-boot-2017.07/board/boundary/nit6xlite/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_NIT6XLITE
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nit6xlite"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nit6xlite"
+
+config ENV_BD_ADDR
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/MAINTAINERS u-boot-imx6/board/boundary/nit6xlite/MAINTAINERS
--- u-boot-2017.07/board/boundary/nit6xlite/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,8 @@
+NIT6XLITE BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nit6xlite/
+F:	include/configs/nit6xlite.h
+F:	configs/nit6xlite_defconfig
+F:	configs/nit6xlite1g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/Makefile u-boot-imx6/board/boundary/nit6xlite/Makefile
--- u-boot-2017.07/board/boundary/nit6xlite/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nit6xlite.o
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/nit6xlite1g.cfg u-boot-imx6/board/boundary/nit6xlite/nit6xlite1g.cfg
--- u-boot-2017.07/board/boundary/nit6xlite/nit6xlite1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/nit6xlite1g.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/nit6xlite.c u-boot-imx6/board/boundary/nit6xlite/nit6xlite.c
--- u-boot-2017.07/board/boundary/nit6xlite/nit6xlite.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/nit6xlite.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,450 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BRM_BT_RESET		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+#define GP_BRM_BT_SHUTDOWN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+#define GP_BRM_BT_WAKE		IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLUP),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpios */
+#define GP_BARCODE_SCANNER	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GP_HOME			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_BACK			IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+
+
+	/* gpio - test points */
+#define GP_TP71			IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+#define GP_TP_SD3_WP		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLDN),
+
+	/* hdmi_cec, 4/21/2017 version no longer has sgtl5000 mute */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* I2C1 - sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* sys_mclk */
+
+	/* I2C3 */
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+#define GPIRQ_ISL1208		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+
+#define GPIRQ_TSC2004		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_TSC2004_RESET	IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+
+	/* LEDS */
+#define GP_LED_GREEN		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP_OUTPUT),
+#define GP_LED_RED		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP_OUTPUT),
+#define GP_J14_POWER_ON		IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN_OUTPUT),
+#define GP_J46_PIN2_I		IMX_GPIO_NR(1, 7)		/* inverted */
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP_OUTPUT),
+#define GP_J46_PIN3_I		IMX_GPIO_NR(1, 8)		/* inverted */
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP_OUTPUT),
+
+#define GP_LVDS_J6_PIN19	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* WiFi/BT pads */
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLDN),
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, WEAK_PULLUP),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+
+	/* PWM3 - Backlight on LVDS connector(J6): J33 */
+#define GP_BACKLIGHT_LVDS_EN IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+
+	/* PWM4 on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),	/* may not be connected */
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+#endif
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+	gpio_direction_output(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* don't auto-detect because TSC2004 is on-board */
+	VD_OKAYA_480_272(LCD, NULL, 2, 0x48),
+	VD_HITACHI_HVGA(LCD, NULL, 2, 0x48),
+	VD_CLAA_WVGA(LCD, NULL, 2, 0x48),
+
+	VD_ASIT500MA6F5D(LCD, NULL, 2, 0x38),
+
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WVGA_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	/* Disable wifi */
+	GP_REG_WLAN_EN,
+	GP_BRM_BT_RESET,
+	GP_BRM_BT_SHUTDOWN,
+	GP_RGMII_PHY_RESET,
+	GP_REG_USBOTG,
+	GP_LED_GREEN,
+	GP_LED_RED,
+	GP_J46_PIN2_I,
+	GP_J46_PIN3_I,
+//	GP_TSC2004_RESET,
+//	GP_J14_POWER_ON,
+};
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BRM_BT_WAKE,
+	GPIRQ_ENET_PHY,
+	GPIRQ_TSC2004,
+	GP_BARCODE_SCANNER,
+	GP_HOME,
+	GP_BACK,
+	GP_TP_SD3_WP,
+	GPIRQ_I2C3_J7,
+	GPIRQ_ISL1208,
+	GP_BACKLIGHT_RGB,
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_LVDS_EN,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+	GP_LVDS_J6_PIN19,
+	GP_TP71,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nit6xlite/nit6xlite.cfg u-boot-imx6/board/boundary/nit6xlite/nit6xlite.cfg
--- u-boot-2017.07/board/boundary/nit6xlite/nit6xlite.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nit6xlite/nit6xlite.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/Kconfig u-boot-imx6/board/boundary/nitrogen51_e/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen51_e/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/Kconfig	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,24 @@
+if TARGET_NITROGEN51_E
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen51_e"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx5"
+
+config SYS_CONFIG_NAME
+	default "nitrogen51_e"
+
+config BOARD_LATE_SPECIFIC_INIT
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/MAINTAINERS u-boot-imx6/board/boundary/nitrogen51_e/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen51_e/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/MAINTAINERS	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_E BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen51_e/
+F:	include/configs/nitrogen51_e.h
+F:	configs/nitrogen51_e_256m_defconfig
+F:	configs/nitrogen51_e_512m_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/Makefile u-boot-imx6/board/boundary/nitrogen51_e/Makefile
--- u-boot-2017.07/board/boundary/nitrogen51_e/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/Makefile	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen51_e.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen51_e.c u-boot-imx6/board/boundary/nitrogen51_e/nitrogen51_e.c
--- u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen51_e.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/nitrogen51_e.c	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,596 @@
+/*
+ * Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux-mx51.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <power/pmic.h>
+#include <fsl_pmic.h>
+#include <mc13892.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_HIGH | \
+			PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define ESDHC_PAD_CTRL	(PAD_CTL_DSE_HIGH | PAD_CTL_DVS | \
+			PAD_CTL_PUS_47K_UP | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_DSE_HIGH | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define I2C2_PAD_CTRL	(PAD_CTL_DSE_HIGH | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	(PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(AUD3_BB_TXD__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_RXD__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_CK__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_FS__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(CSPI1_MISO__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSPI1_MOSI__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSPI1_SCLK__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_PMIC	IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(CSPI1_SS0__GPIO4_24, WEAK_PULLDN), /* SS0 - active high */
+#define GP_ECSPI1_FLASH	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(CSPI1_SS1__GPIO4_25, WEAK_PULLUP), /* SS1 - active low */
+
+	/* ESDHC1 - FULL sd */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA0__SD1_DATA0, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA1__SD1_DATA1, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA2__SD1_DATA2, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA3__SD1_DATA3, ESDHC_PAD_CTRL),
+#define GP_ESDHC1_CD	IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO1_0__GPIO1_0, WEAK_PULLUP),
+#define GP_ESDHC1_WP	IMX_GPIO_NR(1, 1)
+	IOMUX_PAD_CTRL(GPIO1_1__GPIO1_1, WEAK_PULLUP),
+
+	/* ESDHC2  */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__SD2_DATA0, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__SD2_DATA1, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__SD2_DATA2, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__SD2_DATA3, ESDHC_PAD_CTRL),
+#define GP_ESDHC2_SPARE	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(UART1_RTS__GPIO4_30, 0x1e5),	/* spare */
+#define GPIRQ_ESDHC2	IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(UART1_CTS__GPIO4_31, 0x1e5),	/* sdio_int */
+
+	/* FEC pads */
+	IOMUX_PAD_CTRL(EIM_EB2__FEC_MDIO, 0x01f5),
+	IOMUX_PAD_CTRL(NANDF_CS3__FEC_MDC, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_RDY_INT__FEC_TX_CLK, 0x2180),
+	IOMUX_PAD_CTRL(NANDF_CS2__FEC_TX_ER, 0x2004),	/* unused */
+	IOMUX_PAD_CTRL(NANDF_CS7__FEC_TX_EN, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_D8__FEC_TDATA0, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS4__FEC_TDATA1, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS5__FEC_TDATA2, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS6__FEC_TDATA3, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_RB3__FEC_RX_CLK, 0x0180),
+	IOMUX_PAD_CTRL(EIM_CS4__FEC_RX_ER, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_D11__FEC_RX_DV, 0x20a4),
+	IOMUX_PAD_CTRL(EIM_CS5__FEC_CRS, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_RB2__FEC_COL, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_D9__FEC_RDATA0, 0x2180),
+	IOMUX_PAD_CTRL(EIM_EB3__FEC_RDATA1, 0x0085),
+	IOMUX_PAD_CTRL(EIM_CS2__FEC_RDATA2, 0x0085),
+	IOMUX_PAD_CTRL(EIM_CS3__FEC_RDATA3, 0x0085),
+
+	/* GPIO_KEYS */
+#define GP_GPIOKEYS_1		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO1_9__GPIO1_9, WEAK_PULLUP),
+#define GP_GPIOKEYS_2		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO1_4__GPIO1_4, WEAK_PULLUP),
+#define GPIRQ_TP29		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO1_3__GPIO1_3, WEAK_PULLUP),
+
+	/* GPIO_LEDS */
+#define GP_GPIOLEDS_GREEN	IMX_GPIO_NR(1, 5)
+	IOMUX_PAD_CTRL(GPIO1_5__GPIO1_5, WEAK_PULLDN_OUTPUT),
+#define GP_GPIOLEDS_RED		IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO1_6__GPIO1_6, WEAK_PULLDN_OUTPUT),
+#define GP_DRY_CONTACT		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO1_7__GPIO1_7, WEAK_PULLDN_OUTPUT),
+
+	/* Hog, adc_trig */
+	IOMUX_PAD_CTRL(CSI2_VSYNC__GPIO4_13, 0xe5),
+
+	/* hs_i2c1 */
+	IOMUX_PAD_CTRL(I2C1_CLK__I2C1_CLK, I2C_PAD_CTRL),
+	IOMUX_PAD_CTRL(I2C1_DAT__I2C1_DAT, I2C_PAD_CTRL),
+
+	/* hs_i2c1_tfp410 */
+#define GPIRQ_DVI		IMX_GPIO_NR(3, 28)
+	IOMUX_PAD_CTRL(NANDF_D12__GPIO3_28, WEAK_PULLUP),
+#define GP_TFP410_I2C_SEL	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(DISPB2_SER_DIN__GPIO3_5, WEAK_PULLDN),
+
+	/* i2c1 SGTL5000 */
+#define GP_SGTL5000_HP_MUTE	IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO2_17, WEAK_PULLDN_OUTPUT),
+
+	/* i2c2 - ov5642 parallel camera */
+	IOMUX_PAD_CTRL(CSI1_D8__CSI1_D8, 0x85),
+	IOMUX_PAD_CTRL(CSI1_D9__CSI1_D9, 0x85),
+	IOMUX_PAD_CTRL(CSI1_D10__CSI1_D10, 0),
+	IOMUX_PAD_CTRL(CSI1_D11__CSI1_D11, 0),
+	IOMUX_PAD_CTRL(CSI1_D12__CSI1_D12, 0),
+	IOMUX_PAD_CTRL(CSI1_D13__CSI1_D13, 0),
+	IOMUX_PAD_CTRL(CSI1_D14__CSI1_D14, 0),
+	IOMUX_PAD_CTRL(CSI1_D15__CSI1_D15, 0),
+	IOMUX_PAD_CTRL(CSI1_D16__CSI1_D16, 0),
+	IOMUX_PAD_CTRL(CSI1_D17__CSI1_D17, 0),
+	IOMUX_PAD_CTRL(CSI1_D18__CSI1_D18, 0),
+	IOMUX_PAD_CTRL(CSI1_D19__CSI1_D19, 0),
+	IOMUX_PAD_CTRL(CSI1_PIXCLK__CSI1_PIXCLK, 0),
+	IOMUX_PAD_CTRL(CSI1_HSYNC__CSI1_HSYNC, 0),
+	IOMUX_PAD_CTRL(CSI1_VSYNC__CSI1_VSYNC, 0),
+	IOMUX_PAD_CTRL(CSI1_MCLK__CSI1_MCLK, 0x85),
+	IOMUX_PAD_CTRL(CSI2_D12__GPIO4_9, 0x85),
+	IOMUX_PAD_CTRL(CSI2_D13__GPIO4_10, 0x85),
+#define GP_OV5642_RESET		IMX_GPIO_NR(4, 14)
+	IOMUX_PAD_CTRL(CSI2_HSYNC__GPIO4_14, WEAK_PULLDN),
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(CSI2_PIXCLK__GPIO4_15, WEAK_PULLUP),
+
+	/* ipu_disp1 */
+	IOMUX_PAD_CTRL(DI1_DISP_CLK__DI1_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI1_PIN15__DI1_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI1_PIN2__DI1_PIN2, RGB_PAD_CTRL),	/* HSYNC */
+	IOMUX_PAD_CTRL(DI1_PIN3__DI1_PIN3, RGB_PAD_CTRL),	/* VSYNC */
+	IOMUX_PAD_CTRL(DISP1_DAT0__DISP1_DAT0, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT1__DISP1_DAT1, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT2__DISP1_DAT2, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT3__DISP1_DAT3, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT4__DISP1_DAT4, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT5__DISP1_DAT5, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT6__DISP1_DAT6, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT7__DISP1_DAT7, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT8__DISP1_DAT8, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT9__DISP1_DAT9, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT10__DISP1_DAT10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT11__DISP1_DAT11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT12__DISP1_DAT12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT13__DISP1_DAT13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT14__DISP1_DAT14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT15__DISP1_DAT15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT16__DISP1_DAT16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT17__DISP1_DAT17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT18__DISP1_DAT18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT19__DISP1_DAT19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT20__DISP1_DAT20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT21__DISP1_DAT21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT22__DISP1_DAT22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT23__DISP1_DAT23, RGB_PAD_CTRL),
+
+	/* ipu_disp2 */
+	IOMUX_PAD_CTRL(DI2_DISP_CLK__DI2_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI_GP4__DI2_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DISP2_DAT0__DISP2_DAT0, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT1__DISP2_DAT1, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT2__DISP2_DAT2, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT3__DISP2_DAT3, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT4__DISP2_DAT4, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT5__DISP2_DAT5, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT6__DISP2_DAT6, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT7__DISP2_DAT7, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT8__DISP2_DAT8, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT9__DISP2_DAT9, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT10__DISP2_DAT10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT11__DISP2_DAT11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT12__DISP2_DAT12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT13__DISP2_DAT13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT14__DISP2_DAT14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT15__DISP2_DAT15, RGB_PAD_CTRL),
+
+	/* PMIC */
+#define GPIRQ_PMIC	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO1_8__GPIO1_8, WEAK_PULLUP),
+
+	/* PWM1 - lcd backlight */
+#define GP_LCD_BACKLIGHT	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO1_2__GPIO1_2, WEAK_PULLDN_OUTPUT),
+
+	/* reg 3p3v - always enabled */
+#define GP_REG3P3V_EN		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO2_6, WEAK_PULLUP_OUTPUT),
+
+	/* Short pins 4 & 5 of J8 to enable uart1 */
+#define GP_UART1_REQ		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(CSPI1_RDY__GPIO4_26, WEAK_PULLUP),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(UART2_TXD__UART2_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART2_RXD__UART2_RXD, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(UART3_TXD__UART3_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART3_RXD__UART3_RXD, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(USBH1_CLK__USBH1_CLK, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DIR__USBH1_DIR, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_NXT__USBH1_NXT, 0x1e5),
+#define GP_USBH1_STP		IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(USBH1_STP__GPIO1_27, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA0__USBH1_DATA0, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA1__USBH1_DATA1, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA2__USBH1_DATA2, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA3__USBH1_DATA3, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA4__USBH1_DATA4, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA5__USBH1_DATA5, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA6__USBH1_DATA6, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA7__USBH1_DATA7, 0x1e5),
+#define GP_USBH1_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(EIM_D21__GPIO2_5, WEAK_PULLDN_OUTPUT),
+
+	/* USBOTG */
+#define GPIRQ_USBOTG_OC		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(DI1_PIN11__GPIO3_0, PAD_CTRL_INPUT),
+};
+
+static const iomux_v3_cfg_t usbh1_stp_gpio[] = {
+	IOMUX_PAD_CTRL(USBH1_STP__GPIO1_27, 0x1e5),
+};
+
+static const iomux_v3_cfg_t usbh1_stp_usb[] = {
+	IOMUX_PAD_CTRL(USBH1_STP__USBH1_STP, 0x1e5),
+};
+
+static const iomux_v3_cfg_t usbotg_power_on_pads[] = {
+	IOMUX_PAD_CTRL(EIM_D26__KEY_COL7, WEAK_PULLDN_OUTPUT),		/* low is on */
+};
+
+static const iomux_v3_cfg_t usbotg_power_off_pads[] = {
+	IOMUX_PAD_CTRL(EIM_D26__KEY_COL7, WEAK_PULLUP_OUTPUT),		/* high is off */
+};
+
+/* UART1  */
+static const iomux_v3_cfg_t uart1_pads[] = {
+	IOMUX_PAD_CTRL(UART1_TXD__UART1_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART1_RXD__UART1_RXD, UART_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t uart1_gpio_pads[] = {
+	IOMUX_PAD_CTRL(UART1_TXD__GPIO4_29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(UART1_RXD__GPIO4_28, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D19, 2, 3, EIM_D16, 2, 0, I2C_PAD_CTRL),
+	/* I2C2 */
+	I2C_PADS_INFO_ENTRY(I2C2, EIM_D27, 2, 9, EIM_D24, 2, 8, I2C2_PAD_CTRL),
+};
+#define I2C_BUS_CNT	2
+
+#ifdef CONFIG_USB_EHCI_MX5
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Set USBH1_STP to GPIO and toggle it */
+		gpio_set_value(GP_USBH1_RESET, 0);
+		gpio_set_value(GP_USBH1_STP, 0);
+		SETUP_IOMUX_PADS(usbh1_stp_gpio);
+		mdelay(10);
+		gpio_set_value(GP_USBH1_STP, 1);
+		SETUP_IOMUX_PADS(usbh1_stp_usb);
+		mdelay(2);
+
+		gpio_set_value(GP_USBH1_RESET, 1);
+		return 0;
+	}
+	SETUP_IOMUX_PADS(usbotg_power_on_pads);
+	return 0;
+}
+
+#endif
+
+#define REV_ATLAS_LITE_1_0         0x8
+#define REV_ATLAS_LITE_1_1         0x9
+#define REV_ATLAS_LITE_2_0         0x10
+#define REV_ATLAS_LITE_2_1         0x11
+
+#define SREV3_0 0x10
+
+static unsigned get_srev(void)
+{
+	struct iim_regs *piim = (struct iim_regs *)IIM_BASE_ADDR;
+	return readl(&piim->srev);
+}
+
+static void power_init(void)
+{
+	unsigned val, sw1, sw2, sw3;
+	unsigned sw1_volt, sw2_volt, sw3_volt;
+	unsigned mode;
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
+	struct pmic *p;
+	int ret;
+
+	ret = pmic_init(CONFIG_FSL_PMIC_BUS);
+	if (ret)
+		return;
+
+	p = pmic_get("FSL_PMIC");
+	if (!p)
+		return;
+
+	/* Write needed to Power Gate 2 register */
+	pmic_reg_read(p, REG_POWER_MISC, &val);
+	val &= ~PWGT2SPIEN;
+	pmic_reg_write(p, REG_POWER_MISC, val);
+
+	/* Externally powered */
+	pmic_reg_read(p, REG_CHARGE, &val);
+	val |= ICHRG0 | ICHRG1 | ICHRG2 | ICHRG3 | CHGAUTOB;
+	pmic_reg_write(p, REG_CHARGE, val);
+
+	/* power up the system first */
+	pmic_reg_write(p, REG_POWER_MISC, PWUP);
+
+	/* Set core voltage to 1.1V */
+	sw1_volt = SWx_1_100V;
+	/* Setup VCC (SW2) to 1.25 */
+	sw2_volt = SWx_1_250V;
+	/* Setup 1V2_DIG1 (SW3) to 1.275 */
+	sw3_volt = SWx_1_275V;
+
+	pmic_reg_read(p, REG_SW_0, &sw1);
+	sw1 = (sw1 & ~SWx_VOLT_MASK) | sw1_volt;
+	pmic_reg_write(p, REG_SW_0, sw1);
+
+	pmic_reg_read(p, REG_SW_1, &sw2);
+	sw2 = (sw2 & ~SWx_VOLT_MASK) | sw2_volt;
+	pmic_reg_write(p, REG_SW_1, sw2);
+
+	pmic_reg_read(p, REG_SW_2, &sw3);
+	sw3 = (sw3 & ~SWx_VOLT_MASK) | sw3_volt;
+	pmic_reg_write(p, REG_SW_2, sw3);
+
+	if (get_srev() < SREV3_0) {
+		udelay(50);
+
+		/* Raise the core frequency to 800MHz */
+		writel(CONFIG_SYS_ARM_PODF, &mxc_ccm->cacrr);
+	}
+
+	pmic_reg_read(p, REG_IDENTIFICATION, &val);
+	if (((val & 0x1f) < REV_ATLAS_LITE_2_0) || (((val >> 9) & 0x3) == 0)) {
+		mode = SWMODE_PWM_PWM;
+	} else {
+		mode = SWMODE_AUTO_AUTO;
+	}
+	/* Set switchers in Auto in NORMAL mode & STANDBY mode */
+	/* Setup the switcher mode for SW1 & SW2*/
+	pmic_reg_read(p, REG_SW_4, &val);
+	val &= ~((SWMODE_MASK << SWMODE1_SHIFT) |
+		(SWMODE_MASK << SWMODE2_SHIFT));
+	val |= (mode << SWMODE1_SHIFT) |
+		(mode << SWMODE2_SHIFT);
+	pmic_reg_write(p, REG_SW_4, val);
+
+	/* Setup the switcher mode for SW3 & SW4 */
+	pmic_reg_read(p, REG_SW_5, &val);
+	val &= ~((SWMODE_MASK << SWMODE3_SHIFT) |
+		(SWMODE_MASK << SWMODE4_SHIFT));
+	val |= (mode << SWMODE3_SHIFT) |
+		(mode << SWMODE4_SHIFT);
+	pmic_reg_write(p, REG_SW_5, val);
+
+	/* Set VDIG to 1.65V, VGEN3 to 1.8V, VCAM to 2.5V */
+	pmic_reg_read(p, REG_SETTING_0, &val);
+	val &= ~(VCAM_MASK | VGEN3_MASK | VDIG_MASK);
+	val |= VDIG_1_65 | VGEN3_1_8 | VCAM_2_5;
+	pmic_reg_write(p, REG_SETTING_0, val);
+
+	/* Set VVIDEO to 2.775V, VAUDIO to 3V, VSD to 3.15V */
+	pmic_reg_read(p, REG_SETTING_1, &val);
+	val &= ~(VVIDEO_MASK | VSD_MASK | VAUDIO_MASK);
+	val |= VSD_3_15 | VAUDIO_3_0 | VVIDEO_2_775;
+	pmic_reg_write(p, REG_SETTING_1, val);
+
+	/* Configure VGEN3 and VCAM regulators to use external PNP */
+	val = VGEN3CONFIG | VCAMCONFIG;
+	pmic_reg_write(p, REG_MODE_1, val);
+	udelay(200);
+
+	/* Enable VGEN3, VCAM, VAUDIO, VVIDEO, VSD regulators */
+	val = VGEN3EN | VGEN3CONFIG | VCAMEN | VCAMCONFIG |
+		VVIDEOEN | VAUDIOEN  | VSDEN;
+	pmic_reg_write(p, REG_MODE_1, val);
+
+	udelay(500);
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = MMC_SDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_ESDHC1_CD},
+	{.esdhc_base = MMC_SDHC2_BASE_ADDR, .bus_width = 4,},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_PMIC;
+	if (bus == 0 && cs == 1)
+		return GP_ECSPI1_FLASH;
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LCD_BACKLIGHT, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* PIC16F616 */
+	VD_NEON_TOUCH640X240(LCD2, NULL, 0, 0x38),
+	VD_HITACHI_HVGA565(LCD2, NULL, 0, 0x38),
+	/* PMIC touch controller */
+	VD_800X300_565(LCD2, NULL, 0, 0x38),
+	VD_OKAYA_480_272(LCD, NULL, 0, 0x48),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_OV5642_RESET,	/* camera reset */
+	GP_ECSPI1_PMIC,
+	GP_GPIOLEDS_GREEN,
+	GP_GPIOLEDS_RED,
+	GP_DRY_CONTACT,
+	GP_TFP410_I2C_SEL,
+	GP_SGTL5000_HP_MUTE,
+	GP_LCD_BACKLIGHT,
+	GP_USBH1_STP,
+	GP_USBH1_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_REG3P3V_EN,
+	GP_OV5642_POWER_DOWN,
+	GP_ECSPI1_FLASH,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ESDHC1_CD,
+	GP_ESDHC1_WP,
+	GP_ESDHC2_SPARE,
+	GPIRQ_ESDHC2,
+	GP_GPIOKEYS_1,
+	GP_GPIOKEYS_2,
+	GPIRQ_TP29,
+	GPIRQ_DVI,
+	GPIRQ_PMIC,
+	GP_UART1_REQ,
+	GPIRQ_USBOTG_OC,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(usbotg_power_off_pads);
+#ifdef CONFIG_SPI_FLASH_ATMEL
+	/* Rev 0 boards cannot test GP_UART1_REQ */
+	SETUP_IOMUX_PADS(uart1_pads);
+#else
+	/* If J8 pins 4 &5 are shorted, then enable console  */
+	if (!gpio_get_value(GP_UART1_REQ))
+		SETUP_IOMUX_PADS(uart1_pads);
+	else
+		SETUP_IOMUX_PADS(uart1_gpio_pads);
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0, displays, display_cnt, 0);
+	return 0;
+}
+
+void board_late_specific_init(void)
+{
+#ifdef CONFIG_MXC_SPI
+	power_init();
+#endif
+#ifndef CONFIG_SPI_FLASH_ATMEL
+	/* Rev 0 boards cannot test GP_UART1_REQ */
+	/* If J8 pins 4 & 5 are shorted, then enable console  */
+	if (!gpio_get_value(GP_UART1_REQ))
+		setenv("console", "ttymxc0");
+	/*
+	 * Now that the environment is available,
+	 * check if we should enable uart1
+	 */
+	if (getenv("console"))
+		SETUP_IOMUX_PADS(uart1_pads);
+#endif
+}
+
+const struct button_key board_buttons[] = {
+#ifndef CONFIG_SPI_FLASH_ATMEL
+	/* Rev 0 boards cannot test GP_UART1_REQ */
+	{"uart_req",	GP_UART1_REQ,	'u', 1},
+#endif
+	{"tp29",	GPIRQ_TP29,	'9', 1},
+	{NULL, 0, 0, 0},
+};
+
+/* i.MX51 does not support BMODE yet, maybe can't */
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen51_e.cfg u-boot-imx6/board/boundary/nitrogen51_e/nitrogen51_e.cfg
--- u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen51_e.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/nitrogen51_e.cfg	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* H5PS1G63JFR-S5C-C */
+
+/* image version */
+IMAGE_VERSION 1
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/*
+ * 512MB board uses CS0 and CS1, we will disable CS1 if ram doesn't appear to work
+ */
+#if CONFIG_DDR_MB==512
+#define USE_CSD1
+#endif
+
+/* Setting IOMUXC */
+DATA 4 0x73fa8418 0x000000e0	/* SW_PAD_CTL_PAD_EIM_D26, usb OTG power off */
+DATA 4 0x73fa8084 0x00000001	/* SW_MUX_CTL_PAD_EIM_D26, ALT1 kpp column 7, GPIO on next board */
+
+DATA 4 0x73fa88a0 0x200		/* SW_PAD_CTL_GRP_INMODE1, ddr2 input type */
+DATA 4 0x73fa850c 0x20c3	/* SW_PAD_CTL_PAD_EIM_SDODT1, 100K Pull Down, medium drive strength */
+DATA 4 0x73fa8510 0x20c3	/* SW_PAD_CTL_PAD_EIM_SDODT0, 100K Pull Down, medium drive strength */
+DATA 4 0x73fa883c 0x3		/* SW_PAD_CTL_GRP_DDR_A0, (a0-a7)Medium drive strength */
+DATA 4 0x73fa8848 0x3		/* SW_PAD_CTL_GRP_DDR_A1, (a8-a14,ba0-ba2)Medium drive strength */
+DATA 4 0x73fa84b8 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCLK1, medium drive strength */
+DATA 4 0x73fa84bc 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS0, Disable pull down */
+DATA 4 0x73fa84c0 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS1, Disable pull down */
+DATA 4 0x73fa84c4 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS2, Disable pull down */
+DATA 4 0x73fa84c8 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS3, Disable pull down */
+DATA 4 0x73fa8820 0x0		/* SW_PAD_CTL_GRP_DDRPKS, select keeper */
+DATA 4 0x73fa84a4 0x3		/* SW_PAD_CTL_PAD_DRAM_RAS, Medium Drive Strength */
+DATA 4 0x73fa84a8 0x3		/* SW_PAD_CTL_PAD_DRAM_CAS, Medium Drive Strength */
+DATA 4 0x73fa84ac 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDWE, Medium Drive Strength */
+DATA 4 0x73fa84b0 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCKE0, Medium Drive Strength */
+DATA 4 0x73fa84b4 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCKE1, Medium Drive Strength */
+DATA 4 0x73fa84cc 0xe3		/* SW_PAD_CTL_PAD_DRAM_CS0, Medium Drive Strength */
+DATA 4 0x73fa84d0 0xe3		/* SW_PAD_CTL_PAD_DRAM_CS1, Medium Drive Strength */
+
+#ifndef  USE_CSD1
+DATA 4 0x73fa882c 0x2		/* SW_PAD_CTL_GRP_DRAM_B4 (D24-D31), Medium drive strength */
+DATA 4 0x73fa88a4 0x2		/* SW_PAD_CTL_GRP_DRAM_B0 (D0-D7), Medium drive strength */
+DATA 4 0x73fa88ac 0x2		/* SW_PAD_CTL_GRP_DRAM_B1 (D8-D15, Medium drive strength */
+DATA 4 0x73fa88b8 0x2		/* SW_PAD_CTL_GRP_DRAM_B2 (D16-D23), Medium drive strength */
+#endif
+/*
+ * Setting DDR for micron
+ * 13 Rows, 10 Cols, 32 bit, SREF=4 Micron Model
+ * CAS=3 BL=4
+ */
+
+DATA 4 0x83fd9000 0x82a20000	/* ESDCTL_ESDCTL0 */
+#ifdef USE_CSD1
+DATA 4 0x83fd9008 0x82a20000	/* ESDCTL_ESDCTL1 */
+#endif
+DATA 4 0x83fd9010 0x055ad0d0	/* ESDCTL_ESDMISC */
+/*
+ * Samsung K4T1G164Q[E/F]-BCE6000 - E6 means DDR2-667, tCK, CL=3 : 5 - 8 ns
+ * 					K4T1G164QF-BCE6000
+ * tRFC(refresh to any command)		127.5 ns (26 clocks)	Bits 31-28: 3 = 26 clocks (130 ns)(ESDCTL0[23] is double tRFC)
+ * tXSR(exit self refresh)		137.5 ns (28 clocks)	Bits 27-24: 3 = 28 clocks (140 ns)
+ * tXP (exit power down to command)	2 clocks		Bits 23-21: 1 = 2 clocks (10 ns)
+ * tWTR(write to read command)		7.5 ns (2 clocks)	Bits 20:    1 = 2 clocks (10 ns)
+ * tRP (row precharge)			15 ns (3 clocks)	Bits 19-18: 1 = 3 clocks (15 ns)
+ * tMRD(load mode register)		2 clocks		Bits 17-16: 1 = 2 clocks (10 ns)
+ * tRAS(Active to precharge Command)	45 ns (9 clocks)	Bits 15-12: 8 = 9 clocks (45 ns), was 7 = 8 clocks (40ns)
+ * tRRD(Active Bank A to Active B)	10 ns (2 clocks)	Bits 11-10: 1 = 2 clocks (10 ns)
+ * tWR (write to precharge)		15 ns (3 clocks)	Bits 7:     1 = 3 clocks (15 ns)
+ * tRCD(row to columnn delay)		15 ns (3 clocks)	Bits 6-4:   2 = 3 clocks (15 ns)
+ * tRC(ACTIVE to ACTIVE, same bank)	60 ns (12 clocks)	Bits 3-0:   0xb - 12 clocks(60ns), was 0xa = 11 clocks (55 ns)
+ */
+DATA 4 0x83fd9004 0x333584ab	/* ESDCTL_ESDCFG0 */
+#ifdef USE_CSD1
+DATA 4 0x83fd900C 0x333584ab	/* ESDCTL_ESDCFG1 */
+#endif
+
+/* Init DRAM on CS0 */
+/* ESDCTL_ESDSCR */
+DATA 4 0x83fd9014 0x04008008	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x0000801a	/* emrs(2) */
+DATA 4 0x83fd9014 0x0000801b	/* emrs(3) */
+DATA 4 0x83fd9014 0x00428019	/* emrs(1) - 150 ohms ODT */
+DATA 4 0x83fd9014 0x07328018	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x04008008	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x00008010	/* auto-refresh */
+DATA 4 0x83fd9014 0x00008010	/* auto-refresh */
+DATA 4 0x83fd9014 0x06328018	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x03c28019	/* emrs(1) - calibrate */
+DATA 4 0x83fd9014 0x00428019	/* emrs(1) - OCD calibration mode exit */
+DATA 4 0x83fd9014 0x00008000	/* nop */
+
+#ifdef USE_CSD1
+/* Init DRAM on CS1 */
+DATA 4 0x83fd9014 0x0400800c	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x0000801e	/* emrs(2) */
+DATA 4 0x83fd9014 0x0000801f	/* emrs(3) */
+DATA 4 0x83fd9014 0x0042801d	/* emrs(1) - 50 ohms ODT vs 0x0000801d */
+DATA 4 0x83fd9014 0x0732801c	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x0400800c	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x00008014	/* auto-refresh */
+DATA 4 0x83fd9014 0x00008014	/* auto-refresh */
+DATA 4 0x83fd9014 0x0632801c	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x03c2801d	/* emrs(1) - calibrate */
+DATA 4 0x83fd9014 0x0042801d	/* emrs(1) - OCD calibration mode exit */
+DATA 4 0x83fd9014 0x00008004	/* nop */
+#endif
+
+/* Write to CTL0 */
+DATA 4 0x83fd9000 0xb2a20000	/* refresh 4 rows each refresh clock */
+
+#ifdef USE_CSD1
+/* Write to CTL1 */
+DATA 4 0x83fd9008 0xb2a20000
+#endif
+
+
+DATA 4 0x83fd9010 0x055af6d0	/* ESDMISC */
+DATA 4 0x83fd9020 0x00f48c00	/* ESD_DLY1 - D0-D7 read delay */
+DATA 4 0x83fd9024 0x00f48c00	/* ESD_DLY2 - D8-D15 read delay */
+DATA 4 0x83fd9028 0x00f48c00	/* ESD_DLY3 - D16-D23 read delay */
+DATA 4 0x83fd902c 0x00f48c00	/* ESD_DLY4 - D24-D31 read delay */
+DATA 4 0x83fd9030 0x00f48000	/* ESD_DLY5 - D0-D31 write delay */
+
+DATA 4 0x83fd9034 0x88000000	/* DQS gating delays */
+DATA 4 0x83fd9014 0x00000000	/* ESDSCR, AXI address readies normal operation */
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen_bootscript_upgrade.txt u-boot-imx6/board/boundary/nitrogen51_e/nitrogen_bootscript_upgrade.txt
--- u-boot-2017.07/board/boundary/nitrogen51_e/nitrogen_bootscript_upgrade.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_e/nitrogen_bootscript_upgrade.txt	2018-08-27 21:35:36.947471682 +0300
@@ -0,0 +1,128 @@
+offset=0x400
+erase_size=0xC0000
+
+a_uImage1=0x92000400
+a_uImage2=0x92400400
+a_script=0x92000000
+
+blew=0
+for addr in 0x83f98c24 0x83f98c28 0x83f98c2c 0x83f98c30 0x83f98c34 0x83f98c38 ; do
+  if itest.l *${addr} != 0 ; then
+    blew=1;
+  fi
+done
+
+setenv stdout serial,vga
+
+if itest.s "${ethaddr}_" != "_" ; then
+  if itest.l ${blew} != 0 ; then
+    echo already blew fuse;
+    iim read fecmac
+  else
+    echo blowing mac fuses ${ethaddr}
+    iim blow fecmac ${ethaddr}
+  fi
+fi
+
+if sf probe 1 27000000 || sf probe 1 27000000 ; then
+  echo "probed SPI ROM" ;
+else
+  echo "Error initializing EEPROM"
+  exit
+fi
+
+small=1
+if sf read ${a_uImage2} 0x80400 0x400 ; then
+  if sf read ${a_uImage1} 0x400 0x400 ; then
+    if cmp.b ${a_uImage1} ${a_uImage2} 0x400 ; then
+    else
+      small=0;
+    fi
+  fi
+fi
+if itest.l ${small} != 0 ; then
+  rev="rev0_"
+  erase_size=0x7e000
+  echo "small spi-nor chip, erase size changed to 0x7e000"
+fi
+
+if itest.l *0x83fd9008 < 0 ; then
+  size_str="512m"
+else
+  size_str="256m"
+fi
+
+if itest.s "${uboot_defconfig}_" == "_" ; then
+  uboot_defconfig="nitrogen51_e_${rev}${size_str}"
+fi
+
+echo "check U-Boot with u-boot.${uboot_defconfig}" ;
+
+mw.b ${a_uImage1} 0xff ${erase_size}
+
+if fatload mmc 0 ${a_uImage1} u-boot.${uboot_defconfig} ; then
+else
+  echo "File u-boot.${uboot_defconfig} not found on SD card" ;
+  exit
+fi
+echo "read $filesize bytes from SD card" ;
+if sf read ${a_uImage2} ${offset} ${filesize} ; then
+else
+  echo "Error reading boot loader from EEPROM" ;
+  exit
+fi
+
+if cmp.b ${a_uImage1} ${a_uImage2} ${filesize} ; then
+  echo "------- U-Boot versions match" ;
+  echo "------- upgrade not needed" ;
+  if itest.s "${next}_" != "_" ; then
+    if fatload mmc 0 ${a_script} ${next} ; then
+      source ${a_script}
+    else
+      echo "${next} not found on SD card"
+    fi
+  fi
+  exit
+fi
+
+echo "Need U-Boot upgrade" ;
+echo "Program in 5 seconds" ;
+for n in 5 4 3 2 1 ; do
+  echo $n ;
+  sleep 1 ;
+done
+echo "erasing" ;
+sf erase 0 ${erase_size} ;
+
+# two steps to prevent bricking
+echo "programming" ;
+a1=0x92000800
+o1=0x800
+s1=${filesize}
+sf write ${a1} ${o1} ${s1} ;
+sf write ${a_uImage1} $offset 0x400 ;
+
+
+echo "verifying" ;
+if sf read ${a_uImage2} $offset $filesize ; then
+else
+  echo "Error re-reading EEPROM" ;
+  exit
+fi
+if cmp.b ${a_uImage1} ${a_uImage2} $filesize ; then
+else
+  echo "Read verification error" ;
+  exit
+fi
+
+if itest.s "${next}_" != "_" ; then
+  if fatload mmc 0 ${a_script} ${next} ; then
+    source ${a_script}
+  else
+    echo "${next} not found on mmc 0"
+  fi
+fi
+
+while echo "---- U-Boot upgraded. reset" ; do
+  sleep 120
+done
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_vm/Kconfig u-boot-imx6/board/boundary/nitrogen51_vm/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen51_vm/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_vm/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,24 @@
+if TARGET_NITROGEN51_VM
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen51_vm"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx5"
+
+config SYS_CONFIG_NAME
+	default "nitrogen51_vm"
+
+config BOARD_LATE_SPECIFIC_INIT
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_vm/MAINTAINERS u-boot-imx6/board/boundary/nitrogen51_vm/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen51_vm/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_vm/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+NITROGEN6_VM BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen51_vm/
+F:	include/configs/nitrogen51_vm.h
+F:	configs/nitrogen51_vm_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_vm/Makefile u-boot-imx6/board/boundary/nitrogen51_vm/Makefile
--- u-boot-2017.07/board/boundary/nitrogen51_vm/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_vm/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen51_vm.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_vm/nitrogen51_vm.c u-boot-imx6/board/boundary/nitrogen51_vm/nitrogen51_vm.c
--- u-boot-2017.07/board/boundary/nitrogen51_vm/nitrogen51_vm.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_vm/nitrogen51_vm.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2017, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux-mx51.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <power/pmic.h>
+#include <fsl_pmic.h>
+#include <mc13892.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_HIGH | \
+			PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define ESDHC_PAD_CTRL	(PAD_CTL_DSE_HIGH | PAD_CTL_DVS | \
+			PAD_CTL_PUS_47K_UP | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_HIGH | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define I2C2_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_DSE_HIGH | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	(PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_DSE_MED | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_DSE_MED |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(AUD3_BB_TXD__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_RXD__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_CK__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(AUD3_BB_FS__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(CSPI1_MISO__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSPI1_MOSI__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSPI1_SCLK__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_PMIC	IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(CSPI1_SS0__GPIO4_24, WEAK_PULLDN), /* SS0 - active high */
+#define GP_ECSPI1_FLASH	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(CSPI1_SS1__GPIO4_25, WEAK_PULLUP), /* SS1 - active low */
+
+	/* ESDHC1 - FULL sd */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA0__SD1_DATA0, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA1__SD1_DATA1, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA2__SD1_DATA2, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA3__SD1_DATA3, ESDHC_PAD_CTRL),
+#define GP_ESDHC1_CD	IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO1_0__GPIO1_0, WEAK_PULLUP),
+#define GP_ESDHC1_WP	IMX_GPIO_NR(1, 1)
+	IOMUX_PAD_CTRL(GPIO1_1__GPIO1_1, WEAK_PULLUP),
+
+	/* ESDHC2  */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__SD2_DATA0, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__SD2_DATA1, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__SD2_DATA2, ESDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__SD2_DATA3, ESDHC_PAD_CTRL),
+#define GP_ESDHC2_SPARE	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(UART1_RTS__GPIO4_30, 0x1e5),	/* spare */
+#define GPIRQ_ESDHC2	IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(UART1_CTS__GPIO4_31, 0x1e5),	/* sdio_int */
+
+	/* FEC pads */
+	IOMUX_PAD_CTRL(EIM_EB2__FEC_MDIO, 0x01f5),
+	IOMUX_PAD_CTRL(NANDF_CS3__FEC_MDC, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_RDY_INT__FEC_TX_CLK, 0x2180),
+	IOMUX_PAD_CTRL(NANDF_CS2__FEC_TX_ER, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS7__FEC_TX_EN, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_D8__FEC_TDATA0, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS4__FEC_TDATA1, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS5__FEC_TDATA2, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_CS6__FEC_TDATA3, 0x2004),
+	IOMUX_PAD_CTRL(NANDF_RB3__FEC_RX_CLK, 0x0180),
+	IOMUX_PAD_CTRL(EIM_CS4__FEC_RX_ER, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_D11__FEC_RX_DV, 0x20a4),
+	IOMUX_PAD_CTRL(EIM_CS5__FEC_CRS, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_RB2__FEC_COL, 0x0180),
+	IOMUX_PAD_CTRL(NANDF_D9__FEC_RDATA0, 0x2180),
+	IOMUX_PAD_CTRL(EIM_EB3__FEC_RDATA1, 0x0085),
+	IOMUX_PAD_CTRL(EIM_CS2__FEC_RDATA2, 0x0085),
+	IOMUX_PAD_CTRL(EIM_CS3__FEC_RDATA3, 0x0085),
+
+	/* GPIO_KEYS */
+#define GP_GPIOKEYS_1		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO3_7, WEAK_PULLUP),
+#define GP_GPIOKEYS_2		IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO3_8, WEAK_PULLUP),
+#define GP_GPIOKEYS_3		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(NANDF_RB1__GPIO3_9, WEAK_PULLUP),
+#define GP_GPIOKEYS_4		IMX_GPIO_NR(3, 16)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO3_16, WEAK_PULLUP),
+
+	/* GPIO_LEDS */
+#define GP_GPIOLEDS_1		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(NANDF_WE_B__GPIO3_3, WEAK_PULLUP_OUTPUT),
+#define GP_GPIOLEDS_2		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(NANDF_RE_B__GPIO3_4, WEAK_PULLUP_OUTPUT),
+#define GP_GPIOLEDS_3		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO1_4__GPIO1_4, WEAK_PULLUP_OUTPUT),
+#define GP_GPIOLEDS_4		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO3_6, WEAK_PULLUP_OUTPUT),
+
+	/* Hog */
+#define GP_HOG_TP27		IMX_GPIO_NR(3, 17)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO3_17, WEAK_PULLUP),
+	/* Hog, adc_trig */
+	IOMUX_PAD_CTRL(CSI2_VSYNC__GPIO4_13, 0xe5),
+
+	/* hs_i2c1 */
+	IOMUX_PAD_CTRL(I2C1_CLK__I2C1_CLK, I2C_PAD_CTRL),
+	IOMUX_PAD_CTRL(I2C1_DAT__I2C1_DAT, I2C_PAD_CTRL),
+
+	/* hs_i2c1_pic16f616 */
+#define GPIRQ_PIC16F616		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(EIM_D17__GPIO2_1, WEAK_PULLUP),
+
+	/* hs_i2c1_tfp410 */
+#define GPIRQ_DVI		IMX_GPIO_NR(3, 28)
+	IOMUX_PAD_CTRL(NANDF_D12__GPIO3_28, WEAK_PULLUP),
+#define GP_TFP410_I2C_SEL	IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(DISPB2_SER_DIN__GPIO3_5, WEAK_PULLDN),
+
+	/* i2c1 SGTL5000 */
+#define GP_SGTL5000_HP_MUTE	IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO2_17, WEAK_PULLDN_OUTPUT),
+
+	/* i2c2 - ov5642 parallel camera */
+	IOMUX_PAD_CTRL(CSI1_D8__CSI1_D8, 0x85),
+	IOMUX_PAD_CTRL(CSI1_D9__CSI1_D9, 0x85),
+	IOMUX_PAD_CTRL(CSI1_D10__CSI1_D10, 0),
+	IOMUX_PAD_CTRL(CSI1_D11__CSI1_D11, 0),
+	IOMUX_PAD_CTRL(CSI1_D12__CSI1_D12, 0),
+	IOMUX_PAD_CTRL(CSI1_D13__CSI1_D13, 0),
+	IOMUX_PAD_CTRL(CSI1_D14__CSI1_D14, 0),
+	IOMUX_PAD_CTRL(CSI1_D15__CSI1_D15, 0),
+	IOMUX_PAD_CTRL(CSI1_D16__CSI1_D16, 0),
+	IOMUX_PAD_CTRL(CSI1_D17__CSI1_D17, 0),
+	IOMUX_PAD_CTRL(CSI1_D18__CSI1_D18, 0),
+	IOMUX_PAD_CTRL(CSI1_D19__CSI1_D19, 0),
+	IOMUX_PAD_CTRL(CSI1_PIXCLK__CSI1_PIXCLK, 0),
+	IOMUX_PAD_CTRL(CSI1_HSYNC__CSI1_HSYNC, 0),
+	IOMUX_PAD_CTRL(CSI1_VSYNC__CSI1_VSYNC, 0),
+	IOMUX_PAD_CTRL(CSI1_MCLK__CSI1_MCLK, 0x85),
+	IOMUX_PAD_CTRL(CSI2_D12__GPIO4_9, 0x85),
+	IOMUX_PAD_CTRL(CSI2_D13__GPIO4_10, 0x85),
+#define GP_OV5642_RESET		IMX_GPIO_NR(4, 14)
+	IOMUX_PAD_CTRL(CSI2_HSYNC__GPIO4_14, WEAK_PULLDN),
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(CSI2_PIXCLK__GPIO4_15, WEAK_PULLUP),
+
+	/* ipu_disp1 */
+	IOMUX_PAD_CTRL(DI1_DISP_CLK__DI1_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI1_PIN15__DI1_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI1_PIN2__DI1_PIN2, RGB_PAD_CTRL),	/* HSYNC */
+	IOMUX_PAD_CTRL(DI1_PIN3__DI1_PIN3, RGB_PAD_CTRL),	/* VSYNC */
+	IOMUX_PAD_CTRL(DISP1_DAT0__DISP1_DAT0, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT1__DISP1_DAT1, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT2__DISP1_DAT2, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT3__DISP1_DAT3, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT4__DISP1_DAT4, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT5__DISP1_DAT5, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT6__DISP1_DAT6, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT7__DISP1_DAT7, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT8__DISP1_DAT8, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT9__DISP1_DAT9, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT10__DISP1_DAT10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT11__DISP1_DAT11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT12__DISP1_DAT12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT13__DISP1_DAT13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT14__DISP1_DAT14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT15__DISP1_DAT15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT16__DISP1_DAT16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT17__DISP1_DAT17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT18__DISP1_DAT18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT19__DISP1_DAT19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT20__DISP1_DAT20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT21__DISP1_DAT21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT22__DISP1_DAT22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP1_DAT23__DISP1_DAT23, RGB_PAD_CTRL),
+
+	/* ipu_disp2 */
+	IOMUX_PAD_CTRL(DI2_DISP_CLK__DI2_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI_GP4__DI2_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DISP2_DAT0__DISP2_DAT0, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT1__DISP2_DAT1, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT2__DISP2_DAT2, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT3__DISP2_DAT3, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT4__DISP2_DAT4, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT5__DISP2_DAT5, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT6__DISP2_DAT6, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT7__DISP2_DAT7, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT8__DISP2_DAT8, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT9__DISP2_DAT9, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT10__DISP2_DAT10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT11__DISP2_DAT11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT12__DISP2_DAT12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT13__DISP2_DAT13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT14__DISP2_DAT14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP2_DAT15__DISP2_DAT15, RGB_PAD_CTRL),
+
+	/* PMIC */
+#define GPIRQ_PMIC	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO1_8__GPIO1_8, WEAK_PULLUP),
+
+	/* PWM1 - lcd backlight */
+#define GP_LCD_BACKLIGHT	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO1_2__GPIO1_2, WEAK_PULLDN_OUTPUT),
+
+	/* reg 3p3v - always enabled */
+#define GP_REG3P3V_EN		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO2_6, WEAK_PULLUP_OUTPUT),
+
+	/* UART1  */
+	IOMUX_PAD_CTRL(UART1_TXD__UART1_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART1_RXD__UART1_RXD, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(UART2_TXD__UART2_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART2_RXD__UART2_RXD, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(UART3_TXD__UART3_TXD, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART3_RXD__UART3_RXD, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(USBH1_CLK__USBH1_CLK, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DIR__USBH1_DIR, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_NXT__USBH1_NXT, 0x1e5),
+#define GP_USBH1_STP		IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(USBH1_STP__GPIO1_27, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA0__USBH1_DATA0, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA1__USBH1_DATA1, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA2__USBH1_DATA2, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA3__USBH1_DATA3, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA4__USBH1_DATA4, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA5__USBH1_DATA5, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA6__USBH1_DATA6, 0x1e5),
+	IOMUX_PAD_CTRL(USBH1_DATA7__USBH1_DATA7, 0x1e5),
+#define GP_USBH1_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(EIM_D21__GPIO2_5, WEAK_PULLDN_OUTPUT),
+
+	/* USBOTG */
+#define GPIRQ_USBOTG_OC		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(DI1_PIN11__GPIO3_0, PAD_CTRL_INPUT),
+};
+
+static const iomux_v3_cfg_t usbh1_stp_gpio[] = {
+	IOMUX_PAD_CTRL(USBH1_STP__GPIO1_27, 0x1e5),
+};
+
+static const iomux_v3_cfg_t usbh1_stp_usb[] = {
+	IOMUX_PAD_CTRL(USBH1_STP__USBH1_STP, 0x1e5),
+};
+
+static const iomux_v3_cfg_t usbotg_power_on_pads[] = {
+	IOMUX_PAD_CTRL(EIM_D26__KEY_COL7, WEAK_PULLDN_OUTPUT),		/* low is on */
+};
+
+static const iomux_v3_cfg_t usbotg_power_off_pads[] = {
+	IOMUX_PAD_CTRL(EIM_D26__KEY_COL7, WEAK_PULLUP_OUTPUT),		/* high is off */
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D19, 2, 3, EIM_D16, 2, 0, I2C_PAD_CTRL),
+	/* I2C2 */
+	I2C_PADS_INFO_ENTRY(I2C2, EIM_D27, 2, 9, EIM_D24, 2, 8, I2C2_PAD_CTRL),
+};
+#define I2C_BUS_CNT	2
+
+#ifdef CONFIG_USB_EHCI_MX5
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Set USBH1_STP to GPIO and toggle it */
+		gpio_set_value(GP_USBH1_RESET, 0);
+		gpio_set_value(GP_USBH1_STP, 0);
+		SETUP_IOMUX_PADS(usbh1_stp_gpio);
+		mdelay(10);
+		gpio_set_value(GP_USBH1_STP, 1);
+		SETUP_IOMUX_PADS(usbh1_stp_usb);
+		mdelay(2);
+
+		gpio_set_value(GP_USBH1_RESET, 1);
+		return 0;
+	}
+	SETUP_IOMUX_PADS(usbotg_power_on_pads);
+	return 0;
+}
+
+#endif
+
+#define REV_ATLAS_LITE_1_0         0x8
+#define REV_ATLAS_LITE_1_1         0x9
+#define REV_ATLAS_LITE_2_0         0x10
+#define REV_ATLAS_LITE_2_1         0x11
+
+#define SREV3_0 0x10
+
+static unsigned get_srev(void)
+{
+	struct iim_regs *piim = (struct iim_regs *)IIM_BASE_ADDR;
+	return readl(&piim->srev);
+}
+
+static void power_init(void)
+{
+	unsigned val, sw1, sw2, sw3;
+	unsigned sw1_volt, sw2_volt, sw3_volt;
+	unsigned mode;
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)MXC_CCM_BASE;
+	struct pmic *p;
+	int ret;
+
+	ret = pmic_init(CONFIG_FSL_PMIC_BUS);
+	if (ret)
+		return;
+
+	p = pmic_get("FSL_PMIC");
+	if (!p)
+		return;
+
+	/* Write needed to Power Gate 2 register */
+	pmic_reg_read(p, REG_POWER_MISC, &val);
+	val &= ~PWGT2SPIEN;
+	pmic_reg_write(p, REG_POWER_MISC, val);
+
+	/* Externally powered */
+	pmic_reg_read(p, REG_CHARGE, &val);
+	val |= ICHRG0 | ICHRG1 | ICHRG2 | ICHRG3 | CHGAUTOB;
+	pmic_reg_write(p, REG_CHARGE, val);
+
+	/* power up the system first */
+	pmic_reg_write(p, REG_POWER_MISC, PWUP);
+
+	/* Set core voltage to 1.1V */
+	sw1_volt = SWx_1_100V;
+	/* Setup VCC (SW2) to 1.25 */
+	sw2_volt = SWx_1_250V;
+	/* Setup 1V2_DIG1 (SW3) to 1.275 */
+	sw3_volt = SWx_1_275V;
+
+	pmic_reg_read(p, REG_SW_0, &sw1);
+	sw1 = (sw1 & ~SWx_VOLT_MASK) | sw1_volt;
+	pmic_reg_write(p, REG_SW_0, sw1);
+
+	pmic_reg_read(p, REG_SW_1, &sw2);
+	sw2 = (sw2 & ~SWx_VOLT_MASK) | sw2_volt;
+	pmic_reg_write(p, REG_SW_1, sw2);
+
+	pmic_reg_read(p, REG_SW_2, &sw3);
+	sw3 = (sw3 & ~SWx_VOLT_MASK) | sw3_volt;
+	pmic_reg_write(p, REG_SW_2, sw3);
+
+	if (get_srev() < SREV3_0) {
+		udelay(50);
+
+		/* Raise the core frequency to 800MHz */
+		writel(CONFIG_SYS_ARM_PODF, &mxc_ccm->cacrr);
+	}
+
+	pmic_reg_read(p, REG_IDENTIFICATION, &val);
+	if (((val & 0x1f) < REV_ATLAS_LITE_2_0) || (((val >> 9) & 0x3) == 0)) {
+		mode = SWMODE_PWM_PWM;
+	} else {
+		mode = SWMODE_AUTO_AUTO;
+	}
+	/* Set switchers in Auto in NORMAL mode & STANDBY mode */
+	/* Setup the switcher mode for SW1 & SW2*/
+	pmic_reg_read(p, REG_SW_4, &val);
+	val &= ~((SWMODE_MASK << SWMODE1_SHIFT) |
+		(SWMODE_MASK << SWMODE2_SHIFT));
+	val |= (mode << SWMODE1_SHIFT) |
+		(mode << SWMODE2_SHIFT);
+	pmic_reg_write(p, REG_SW_4, val);
+
+	/* Setup the switcher mode for SW3 & SW4 */
+	pmic_reg_read(p, REG_SW_5, &val);
+	val &= ~((SWMODE_MASK << SWMODE3_SHIFT) |
+		(SWMODE_MASK << SWMODE4_SHIFT));
+	val |= (mode << SWMODE3_SHIFT) |
+		(mode << SWMODE4_SHIFT);
+	pmic_reg_write(p, REG_SW_5, val);
+
+	/* Set VDIG to 1.65V, VGEN3 to 1.8V, VCAM to 2.5V */
+	pmic_reg_read(p, REG_SETTING_0, &val);
+	val &= ~(VCAM_MASK | VGEN3_MASK | VDIG_MASK);
+	val |= VDIG_1_65 | VGEN3_1_8 | VCAM_2_5;
+	pmic_reg_write(p, REG_SETTING_0, val);
+
+	/* Set VVIDEO to 2.775V, VAUDIO to 3V, VSD to 3.15V */
+	pmic_reg_read(p, REG_SETTING_1, &val);
+	val &= ~(VVIDEO_MASK | VSD_MASK | VAUDIO_MASK);
+	val |= VSD_3_15 | VAUDIO_3_0 | VVIDEO_2_775;
+	pmic_reg_write(p, REG_SETTING_1, val);
+
+	/* Configure VGEN3 and VCAM regulators to use external PNP */
+	val = VGEN3CONFIG | VCAMCONFIG;
+	pmic_reg_write(p, REG_MODE_1, val);
+	udelay(200);
+
+	/* Enable VGEN3, VCAM, VAUDIO, VVIDEO, VSD regulators */
+	val = VGEN3EN | VGEN3CONFIG | VCAMEN | VCAMCONFIG |
+		VVIDEOEN | VAUDIOEN  | VSDEN;
+	pmic_reg_write(p, REG_MODE_1, val);
+
+	udelay(500);
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = MMC_SDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_ESDHC1_CD},
+	{.esdhc_base = MMC_SDHC2_BASE_ADDR, .bus_width = 4,},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_PMIC;
+	if (bus == 0 && cs == 1)
+		return GP_ECSPI1_FLASH;
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LCD_BACKLIGHT, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* PIC16F616 */
+	VD_NEON_TOUCH640X240(LCD2, NULL, 0, 0x38),
+	VD_HITACHI_HVGA565(LCD2, NULL, 0, 0x38),
+	/* PMIC touch controller */
+	VD_800X300_565(LCD2, NULL, 0, 0x38),
+	VD_OKAYA_480_272(LCD, NULL, 0, 0x48),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_OV5642_RESET,	/* camera reset */
+	GP_ECSPI1_PMIC,
+	GP_TFP410_I2C_SEL,
+	GP_SGTL5000_HP_MUTE,
+	GP_LCD_BACKLIGHT,
+	GP_USBH1_STP,
+	GP_USBH1_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_REG3P3V_EN,
+	GP_OV5642_POWER_DOWN,
+	GP_ECSPI1_FLASH,	/* SS1 of spi nor */
+	GP_GPIOLEDS_1,
+	GP_GPIOLEDS_2,
+	GP_GPIOLEDS_3,
+	GP_GPIOLEDS_4,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ESDHC1_CD,
+	GP_ESDHC1_WP,
+	GP_ESDHC2_SPARE,
+	GPIRQ_ESDHC2,
+	GP_GPIOKEYS_1,
+	GP_GPIOKEYS_2,
+	GP_GPIOKEYS_3,
+	GP_GPIOKEYS_4,
+	GP_HOG_TP27,
+	GPIRQ_PIC16F616,
+	GPIRQ_DVI,
+	GPIRQ_PMIC,
+	GPIRQ_USBOTG_OC,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(usbotg_power_off_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0, displays, display_cnt, 0);
+	return 0;
+}
+
+void board_late_specific_init(void)
+{
+#ifdef CONFIG_MXC_SPI
+	power_init();
+#endif
+}
+
+const struct button_key board_buttons[] = {
+	{"tp27",	GP_HOG_TP27,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+/* i.MX51 does not support BMODE yet, maybe can't */
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen51_vm/nitrogen51_vm.cfg u-boot-imx6/board/boundary/nitrogen51_vm/nitrogen51_vm.cfg
--- u-boot-2017.07/board/boundary/nitrogen51_vm/nitrogen51_vm.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen51_vm/nitrogen51_vm.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* H5PS1G63JFR-S5C-C */
+
+/* image version */
+IMAGE_VERSION 1
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/*
+ * 512MB board uses CS0 and CS1, we will disable CS1 if ram doesn't appear to work
+ */
+#if CONFIG_DDR_MB==512
+#define USE_CSD1
+#endif
+
+/* Setting IOMUXC */
+DATA 4 0x73fa8418 0x000000e0	/* SW_PAD_CTL_PAD_EIM_D26, usb OTG power off */
+DATA 4 0x73fa8084 0x00000001	/* SW_MUX_CTL_PAD_EIM_D26, ALT1 kpp column 7, GPIO on next board */
+
+DATA 4 0x73fa88a0 0x200		/* SW_PAD_CTL_GRP_INMODE1, ddr2 input type */
+DATA 4 0x73fa850c 0x20c3	/* SW_PAD_CTL_PAD_EIM_SDODT1, 100K Pull Down, medium drive strength */
+DATA 4 0x73fa8510 0x20c3	/* SW_PAD_CTL_PAD_EIM_SDODT0, 100K Pull Down, medium drive strength */
+DATA 4 0x73fa883c 0x3		/* SW_PAD_CTL_GRP_DDR_A0, (a0-a7)Medium drive strength */
+DATA 4 0x73fa8848 0x3		/* SW_PAD_CTL_GRP_DDR_A1, (a8-a14,ba0-ba2)Medium drive strength */
+DATA 4 0x73fa84b8 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCLK1, medium drive strength */
+DATA 4 0x73fa84bc 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS0, Disable pull down */
+DATA 4 0x73fa84c0 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS1, Disable pull down */
+DATA 4 0x73fa84c4 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS2, Disable pull down */
+DATA 4 0x73fa84c8 0x43		/* SW_PAD_CTL_PAD_DRAM_SDQS3, Disable pull down */
+DATA 4 0x73fa8820 0x0		/* SW_PAD_CTL_GRP_DDRPKS, select keeper */
+DATA 4 0x73fa84a4 0x3		/* SW_PAD_CTL_PAD_DRAM_RAS, Medium Drive Strength */
+DATA 4 0x73fa84a8 0x3		/* SW_PAD_CTL_PAD_DRAM_CAS, Medium Drive Strength */
+DATA 4 0x73fa84ac 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDWE, Medium Drive Strength */
+DATA 4 0x73fa84b0 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCKE0, Medium Drive Strength */
+DATA 4 0x73fa84b4 0xe3		/* SW_PAD_CTL_PAD_DRAM_SDCKE1, Medium Drive Strength */
+DATA 4 0x73fa84cc 0xe3		/* SW_PAD_CTL_PAD_DRAM_CS0, Medium Drive Strength */
+DATA 4 0x73fa84d0 0xe3		/* SW_PAD_CTL_PAD_DRAM_CS1, Medium Drive Strength */
+
+#ifndef  USE_CSD1
+DATA 4 0x73fa882c 0x2		/* SW_PAD_CTL_GRP_DRAM_B4 (D24-D31), Medium drive strength */
+DATA 4 0x73fa88a4 0x2		/* SW_PAD_CTL_GRP_DRAM_B0 (D0-D7), Medium drive strength */
+DATA 4 0x73fa88ac 0x2		/* SW_PAD_CTL_GRP_DRAM_B1 (D8-D15, Medium drive strength */
+DATA 4 0x73fa88b8 0x2		/* SW_PAD_CTL_GRP_DRAM_B2 (D16-D23), Medium drive strength */
+#endif
+/*
+ * Setting DDR for micron
+ * 13 Rows, 10 Cols, 32 bit, SREF=4 Micron Model
+ * CAS=3 BL=4
+ */
+
+DATA 4 0x83fd9000 0x82a20000	/* ESDCTL_ESDCTL0 */
+#ifdef USE_CSD1
+DATA 4 0x83fd9008 0x82a20000	/* ESDCTL_ESDCTL1 */
+#endif
+DATA 4 0x83fd9010 0x055ad0d0	/* ESDCTL_ESDMISC */
+/*
+ * Samsung K4T1G164Q[E/F]-BCE6000 - E6 means DDR2-667, tCK, CL=3 : 5 - 8 ns
+ * 					K4T1G164QF-BCE6000
+ * tRFC(refresh to any command)		127.5 ns (26 clocks)	Bits 31-28: 3 = 26 clocks (130 ns)(ESDCTL0[23] is double tRFC)
+ * tXSR(exit self refresh)		137.5 ns (28 clocks)	Bits 27-24: 3 = 28 clocks (140 ns)
+ * tXP (exit power down to command)	2 clocks		Bits 23-21: 1 = 2 clocks (10 ns)
+ * tWTR(write to read command)		7.5 ns (2 clocks)	Bits 20:    1 = 2 clocks (10 ns)
+ * tRP (row precharge)			15 ns (3 clocks)	Bits 19-18: 1 = 3 clocks (15 ns)
+ * tMRD(load mode register)		2 clocks		Bits 17-16: 1 = 2 clocks (10 ns)
+ * tRAS(Active to precharge Command)	45 ns (9 clocks)	Bits 15-12: 8 = 9 clocks (45 ns), was 7 = 8 clocks (40ns)
+ * tRRD(Active Bank A to Active B)	10 ns (2 clocks)	Bits 11-10: 1 = 2 clocks (10 ns)
+ * tWR (write to precharge)		15 ns (3 clocks)	Bits 7:     1 = 3 clocks (15 ns)
+ * tRCD(row to columnn delay)		15 ns (3 clocks)	Bits 6-4:   2 = 3 clocks (15 ns)
+ * tRC(ACTIVE to ACTIVE, same bank)	60 ns (12 clocks)	Bits 3-0:   0xb - 12 clocks(60ns), was 0xa = 11 clocks (55 ns)
+ */
+DATA 4 0x83fd9004 0x333584ab	/* ESDCTL_ESDCFG0 */
+#ifdef USE_CSD1
+DATA 4 0x83fd900C 0x333584ab	/* ESDCTL_ESDCFG1 */
+#endif
+
+/* Init DRAM on CS0 */
+/* ESDCTL_ESDSCR */
+DATA 4 0x83fd9014 0x04008008	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x0000801a	/* emrs(2) */
+DATA 4 0x83fd9014 0x0000801b	/* emrs(3) */
+DATA 4 0x83fd9014 0x00428019	/* emrs(1) - 150 ohms ODT */
+DATA 4 0x83fd9014 0x07328018	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x04008008	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x00008010	/* auto-refresh */
+DATA 4 0x83fd9014 0x00008010	/* auto-refresh */
+DATA 4 0x83fd9014 0x06328018	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x03c28019	/* emrs(1) - calibrate */
+DATA 4 0x83fd9014 0x00428019	/* emrs(1) - OCD calibration mode exit */
+DATA 4 0x83fd9014 0x00008000	/* nop */
+
+#ifdef USE_CSD1
+/* Init DRAM on CS1 */
+DATA 4 0x83fd9014 0x0400800c	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x0000801e	/* emrs(2) */
+DATA 4 0x83fd9014 0x0000801f	/* emrs(3) */
+DATA 4 0x83fd9014 0x0042801d	/* emrs(1) - 50 ohms ODT vs 0x0000801d */
+DATA 4 0x83fd9014 0x0732801c	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x0400800c	/* PRECHARGE ALL */
+DATA 4 0x83fd9014 0x00008014	/* auto-refresh */
+DATA 4 0x83fd9014 0x00008014	/* auto-refresh */
+DATA 4 0x83fd9014 0x0632801c	/* MRS (load mode register) */
+DATA 4 0x83fd9014 0x03c2801d	/* emrs(1) - calibrate */
+DATA 4 0x83fd9014 0x0042801d	/* emrs(1) - OCD calibration mode exit */
+DATA 4 0x83fd9014 0x00008004	/* nop */
+#endif
+
+/* Write to CTL0 */
+DATA 4 0x83fd9000 0xb2a20000	/* refresh 4 rows each refresh clock */
+
+#ifdef USE_CSD1
+/* Write to CTL1 */
+DATA 4 0x83fd9008 0xb2a20000
+#endif
+
+
+DATA 4 0x83fd9010 0x055af6d0	/* ESDMISC */
+DATA 4 0x83fd9020 0x00f48c00	/* ESD_DLY1 - D0-D7 read delay */
+DATA 4 0x83fd9024 0x00f48c00	/* ESD_DLY2 - D8-D15 read delay */
+DATA 4 0x83fd9028 0x00f48c00	/* ESD_DLY3 - D16-D23 read delay */
+DATA 4 0x83fd902c 0x00f48c00	/* ESD_DLY4 - D24-D31 read delay */
+DATA 4 0x83fd9030 0x00f48000	/* ESD_DLY5 - D0-D31 write delay */
+
+DATA 4 0x83fd9034 0x88000000	/* DQS gating delays */
+DATA 4 0x83fd9014 0x00000000	/* ESDSCR, AXI address readies normal operation */
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/Kconfig u-boot-imx6/board/boundary/nitrogen6_max/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6_max/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,24 @@
+if TARGET_NITROGEN6_MAX
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen6_max"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nitrogen6_max"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/MAINTAINERS u-boot-imx6/board/boundary/nitrogen6_max/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen6_max/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen6_max/
+F:	include/configs/nitrogen6_max.h
+F:	configs/nitrogen6_max_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/Makefile u-boot-imx6/board/boundary/nitrogen6_max/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6_max/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen6_max.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max4g.cfg u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max4g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max4g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max4g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#ifdef CONFIG_MX6QP
+/* 4 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x4327033b
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0324031a
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43240337
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03210269
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x483c3e4a
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x423a3848
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x33363a2c
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3e314137
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00200026
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00260021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00180028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f001e
+#define WALAT	1
+
+#else
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03400338
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03400304
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x423A3E4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x443A3648
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383E4238
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x42364A3E
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001f0024
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00240021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00150028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x0009001c
+#define WALAT	1
+
+#endif
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 1
+#define BUS_WIDTH 64
+/* H5TC8G63AMR-PBA */
+#include "../common/mx6/1066mhz_256mx16-hynix.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_4gr0.cfg u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_4gr0.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_4gr0.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_4gr0.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03400338
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x433C0350
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03400304
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x423A3E4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x443A3648
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383E4238
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x42364A3E
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001f0024
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00240021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00150028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x0009001c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* MT41K512M16HA-107 IT:A */
+#include "../common/mx6/1066mhz_512mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max.c u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max.c
--- u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,638 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* GPIO_KEYS assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* i2c1_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 - Amplifier Mute */
+#define GP_SGTL5000_MUTE	IMX_GPIO_NR(1, 29)		/* Low is muted */
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN),
+#define GP_HEADPHONE_DET	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, INPUT_FLOAT),
+
+	/* i2c2a ov5642 Camera controls */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+#define GP_OV5642_RESET		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* i2c2b ov5640 Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+
+	/* i2c2 TC358743 interrupt */
+#define GPIRQ_TC3587		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* i2c2mux - ov5642 camera i2c enable */
+#define GP_I2C2MUX_A		IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLDN),
+	/* i2c2mux - ov5640_mipi camera i2c enable */
+#define GP_I2C2MUX_B		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN),
+
+#define GP_LVDS_LP8860_EN	IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLDN),
+#define GP_LVDS2_LP8860_EN	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN),
+
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, WEAK_PULLDN),
+
+	/* i2c3mux - pcie i2c enable */
+#define GP_I2C3MUX_A	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),
+
+	/* i2c3 ov5640 Camera controls */
+#define GP_OV5640_POWER_DOWN	IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLUP),		/* pin 32 - Power */
+#define GP_OV5640_RESET	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),		/* pin 36 - Reset */
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN),
+
+	/* PWM1 - Backlight on RGB connector: J15, pin 37 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM2 - Backlight on LVDS2 connector: J11, pin 20 */
+#define GP_BACKLIGHT_LVDS2	IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* PWM3  */
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6, pin 20 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART5 - ISL3330IAZ rs485/rs232 selection */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+	/* RS485 RX Enable */
+#define GP_UART5_RX_EN		IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, WEAK_PULLDN),
+	/* RS485 TX Enable */
+#define GP_UART5_TX_EN		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN),
+	/* RS485/RS232 Select 2.5V */
+#define GP_UART5_RS485_EN	IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLDN),
+	/* ON - meaning depends on others */
+#define GP_UART5_AON		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#define GP_USDHC3_POWER_SEL	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__SD3_VSELECT, OUTPUT_40OHM),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+static unsigned char setup_serializer_data[] = {
+	0x0c, 0x03, 0xda,	/* passthough i2c accesses to de-serialized/backlight */
+	0x0c, 0x07, 0x5a,	/* setup backlight lp8860 address */
+	0x0c, 0x08, 0x5a,
+	0x0c, 0x77, 0xba,	/* setup gt911 touch controller address */
+	0x0c, 0x70, 0xba,
+	0x0c, 0x0d, 0x05,	/* gpio0 output from de-serializer */
+	0x2c, 0x1d, 0x03,
+	0x0c, 0x0f, 0x03,	/* gpio3 output to de-serializer */
+	0x2c, 0x1f, 0x05,
+#if 1
+	0x0c, 0x0e, 0x03,	/* gpio1 output to de-serializer */
+	0x2c, 0x1e, 0x05,
+#else
+	0x2c, 0x1e, 0x01,	/* gpio1 local to de-serializer, low */
+	0x2c, 0x1e, 0x09,	/* gpio1 local to de-serializer, high */
+#endif
+};
+
+static unsigned char enable_backlight_data[] = {
+	0x2d, 0x00, 0xff,	/* 100% brightness */
+	0x2d, 0x01, 0xff,
+};
+
+void write_i2c_table(unsigned char *p, int size)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < size; i += 3, p += 3) {
+		int retry = 0;
+		while (1) {
+			ret = i2c_write(p[0], p[1], 1, &p[2], 1);
+			if (!ret)
+				break;
+			if (retry++ > 10) {
+				printf("error writing 0x%02x:0x%02x = 0x%02x\n",
+					p[0], p[1], p[2]);
+				break;
+			}
+			mdelay(100);
+		}
+	}
+}
+
+void enable_backlight(const struct display_info_t *di, int enable, int gp_backlight, int gp_lp8860)
+{
+	if (di->addr == 0x0c) {
+		/* enable lp8860 backlight */
+		int gp = di->bus >> 8;
+		int ret = i2c_set_bus_num(di->bus & 0xff);
+
+		if (ret)
+			return;
+		if (gp)
+			gpio_set_value(gp, 1);
+
+		gpio_direction_output(gp_lp8860, 0);
+		if (!enable)
+			return;
+
+		write_i2c_table(setup_serializer_data,
+			sizeof(setup_serializer_data));
+		mdelay(2);
+		gpio_direction_output(gp_lp8860, enable);
+		mdelay(60);
+
+		write_i2c_table(enable_backlight_data,
+			sizeof(enable_backlight_data));
+		if (gp)
+			gpio_set_value(gp, 0);
+	} else {
+		gpio_direction_output(gp_backlight, enable);
+	}
+}
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	enable_backlight(di, enable, GP_BACKLIGHT_LVDS, GP_LVDS_LP8860_EN);
+}
+
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+	enable_backlight(di, enable, GP_BACKLIGHT_LVDS2, GP_LVDS2_LP8860_EN);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+int fbp_detect_serializer(struct display_info_t const *di)
+{
+	int ret;
+	int gp = di->bus >> 8;
+
+	if (gp)
+		gpio_set_value(gp, 1);
+	ret = i2c_set_bus_num(di->bus & 0xff);
+	if (ret == 0) {
+		int gp_lp8860 = (di->fbtype == FB_LVDS2) ? GP_LVDS2_LP8860_EN :
+				GP_LVDS_LP8860_EN;
+		ret = i2c_probe(di->addr);
+		if (!ret) {
+			gpio_direction_output(gp_lp8860, 0);
+			write_i2c_table(setup_serializer_data,
+				sizeof(setup_serializer_data));
+		}
+	}
+	if (gp)
+		gpio_set_value(gp, 0);
+	return (ret == 0);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_HANNSTAR7(LVDS2, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS2, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS2, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+	VD_ND1024_600(LVDS, fbp_detect_i2c, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_HANNSTAR(LVDS2, NULL, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_LD070WSVGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* 0x0c is a serializer */
+	VD_TFC_A9700LTWV35TC_C1(LVDS, fbp_detect_serializer, 2, 0x0c),
+	VD_TFC_A9700LTWV35TC_C1(LVDS2, fbp_detect_serializer, (GP_I2C2MUX_A << 8) | 1, 0x0c),
+
+	/* uses both lvds connectors */
+	VD_1080P60(LVDS, NULL, 0, 0x00),
+	VD_1080P60_J(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_SGTL5000_MUTE,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_RGMII_PHY_RESET,
+	GP_OV5642_RESET,	/* camera reset */
+	GP_OV5640_RESET,	/* camera reset */
+	GP_PCIE_RESET,
+	GP_UART5_RX_EN,		/* power down uart5 */
+	GP_UART5_TX_EN,
+	GP_UART5_RS485_EN,
+	GP_UART5_AON,
+	GP_I2C2MUX_A,
+	GP_I2C2MUX_B,
+	GP_I2C3MUX_A,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_OV5642_POWER_DOWN,	/* camera power down */
+	GP_OV5640_MIPI_POWER_DOWN,	/* camera power down */
+	GP_OV5640_POWER_DOWN,	/* camera power down */
+	GP_USDHC3_POWER_SEL,	/* high=3.3v */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GP_HEADPHONE_DET,
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_LVDS2,
+	GP_BACKLIGHT_RGB,
+	GPIRQ_ENET_PHY,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_TC3587,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_dl2g.cfg u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_dl2g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_dl2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_dl2g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x424e024e
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02380238
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4224022c
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x021e0222
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4545494f
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x45474943
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37392929
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x2e2e3028
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0052005c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00420046
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x002d002c
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x002b003e
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_dl4g.cfg u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_dl4g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_max/nitrogen6_max_dl4g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/nitrogen6_max_dl4g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x424e024e
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02380238
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4224022c
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x021e0222
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4545494f
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x45474943
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37392929
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x2e2e3028
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0052005c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00420046
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x002d002c
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x002b003e
+#define WALAT	1
+
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 1
+#define BUS_WIDTH 64
+/* H5TC8G63AMR-PBA */
+#include "../common/mx6/800mhz_256mx16-hynix.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_max/spl.c u-boot-imx6/board/boundary/nitrogen6_max/spl.c
--- u-boot-2017.07/board/boundary/nitrogen6_max/spl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_max/spl.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/mx6-ddr.h>
+#include <asm/imx-common/boot_mode.h>
+
+#include <i2c.h>
+#include <spl.h>
+
+#if 0
+void board_init_f(ulong dummy)
+{
+#if 0
+	arch_cpu_init();
+	board_early_init_f();
+	timer_init();
+	preloader_console_init();
+
+	print_cpuinfo();
+	board_init_r(NULL, 0);
+#endif
+}
+#endif
+
+void spl_board_init(void)
+{
+#if 0
+	int i;
+	u32 const *regs ;
+	int num_regs;
+	unsigned char mac_address[6];
+        imx_get_mac_from_fuse(0,mac_address);
+	printf("ethaddr: %pM\n", mac_address);
+
+	if (is_cpu_type(MXC_CPU_MX6Q)) {
+#if 1
+		regs = mx6q_1g;
+		num_regs = ARRAY_SIZE(mx6q_1g);
+#else
+		regs = mx6q_2g;
+		num_regs = ARRAY_SIZE(mx6q_2g);
+#endif
+	} else {
+#if CONFIG_DDR_MB == 512
+		regs = mx6dl_512m;
+		num_regs = ARRAY_SIZE(mx6dl_512m);
+printf("Configuring for 512MiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 1024
+		regs = mx6dl_1gn;
+		num_regs = ARRAY_SIZE(mx6dl_1gn);
+printf("Configuring for 1GiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 2048
+		regs = mx6dl_2g;
+		num_regs = ARRAY_SIZE(mx6dl_2g);
+printf("Configuring for 2GiB wide memory bus\n");
+#endif
+	}
+	for (i=0; i < num_regs; i+=2) {
+		writel(regs[i+1],regs[i]);
+	}
+        dram_init();
+#endif
+	printf("%s\n", __func__);
+}
+
+u32 spl_boot_device(void)
+{
+	printf("%s\n", __func__);
+#if 0
+	unsigned reg;
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	printf("%s: sbmr1 == 0x%08x\n", __func__, psrc->sbmr1);
+	printf("%s: gpr9  == 0x%08x\n", __func__, psrc->gpr9);
+	printf("%s: gpr10 == 0x%08x\n", __func__, psrc->gpr10);
+	return BOOT_DEVICE_USB;
+#endif
+#if 1
+	return BOOT_DEVICE_SPI;
+#endif
+}
+
+#if 0
+void spl_usb_load_image(void)
+{
+	boot_mode_apply(MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00));
+	reset_cpu(0);
+}
+
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_scm/Kconfig u-boot-imx6/board/boundary/nitrogen6_scm/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6_scm/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_scm/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,20 @@
+if TARGET_NITROGEN6_SCM
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen6_scm"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nitrogen6_scm"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_scm/MAINTAINERS u-boot-imx6/board/boundary/nitrogen6_scm/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen6_scm/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_scm/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+NITROGEN6_SCM BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen6_scm/
+F:	include/configs/nitrogen6_scm.h
+F:	configs/nitrogen6_scm_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_scm/Makefile u-boot-imx6/board/boundary/nitrogen6_scm/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6_scm/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_scm/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen6_scm.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_scm/nitrogen6_scm.c u-boot-imx6/board/boundary/nitrogen6_scm/nitrogen6_scm.c
--- u-boot-2017.07/board/boundary/nitrogen6_scm/nitrogen6_scm.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_scm/nitrogen6_scm.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,443 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define CSI_PAD_CTL	PAD_CTL_DSE_120ohm
+
+#define ESAI_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_ODE)
+
+#define LCDIF_PAD_CTL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC1_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC1_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(KEY_ROW3__GPIO2_IO_18, WEAK_PULLDN),
+
+	/* CSI */
+	IOMUX_PAD_CTRL(CSI_MCLK__CSI1_MCLK, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_PIXCLK__CSI1_PIXCLK, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_VSYNC__CSI1_VSYNC, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_HSYNC__CSI1_HSYNC, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA00__CSI1_DATA_2, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA01__CSI1_DATA_3, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA02__CSI1_DATA_4, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA03__CSI1_DATA_5, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA04__CSI1_DATA_6, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA05__CSI1_DATA_7, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA06__CSI1_DATA_8, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA07__CSI1_DATA_9, CSI_PAD_CTL),
+
+#define GP_OV5642_RESET		IMX_GPIO_NR(7, 4)
+	IOMUX_PAD_CTRL(SD3_DATA2__GPIO7_IO_4, WEAK_PULLDN),
+#define GP_OV5642_PWRDN		IMX_GPIO_NR(7, 5)
+	IOMUX_PAD_CTRL(SD3_DATA3__GPIO7_IO_5, WEAK_PULLUP),
+
+	/* ECSPI1 (serial nor eeprom) */
+	IOMUX_PAD_CTRL(KEY_COL1__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_COL0__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO2_IO_16, WEAK_PULLUP),
+
+	/* ESAI */
+	IOMUX_PAD_CTRL(NAND_WE_B__ESAI_TX5_RX0, ESAI_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_CE0_B__ESAI_TX_CLK, ESAI_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_READY_B__ESAI_TX1, ESAI_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_RE_B__ESAI_TX_FS, ESAI_PAD_CTRL),
+
+	/* gpio - keys */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(QSPI1B_DATA3__GPIO4_IO_27, WEAK_PULLUP),
+
+	/* gpio - output */
+#define GP_POWER_OFF		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(QSPI1B_DATA2__GPIO4_IO_26, WEAK_PULLDN),
+
+	/* hogs - Test points */
+#define GP_TP16		IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DATA4__GPIO7_IO_6, WEAK_PULLUP),
+#define GP_TP17		IMX_GPIO_NR(7, 7)
+	IOMUX_PAD_CTRL(SD3_DATA5__GPIO7_IO_7, WEAK_PULLUP),
+#define GP_TP18		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(SD4_DATA0__GPIO6_IO_14, WEAK_PULLUP),
+#define GP_TP19		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(SD4_DATA1__GPIO6_IO_15, WEAK_PULLUP),
+
+#define GP_I2C3_J4_RESET	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO1_IO08__GPIO1_IO_8, WEAK_PULLUP),
+#define GPIRQ_I2C3_J4	IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO1_IO09__GPIO1_IO_9, WEAK_PULLUP),
+
+	/* i2c4a - max77818 */
+#define GPIRQ_MAX77818_INTB		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_CLK__GPIO7_IO_0, WEAK_PULLUP),
+#define GPIRQ_MAX77818_WCINOKB		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_DATA6__GPIO7_IO_8, WEAK_PULLUP),
+#define GPIRQ_MAX77818_INOKB	IMX_GPIO_NR(7, 9)
+	IOMUX_PAD_CTRL(SD3_DATA7__GPIO7_IO_9, WEAK_PULLUP),
+
+	/* PWM1 for rgb panel */
+#define GP_BACKLIGHT_RGB 	IMX_GPIO_NR(1, 10)
+	IOMUX_PAD_CTRL(GPIO1_IO10__GPIO1_IO_10, WEAK_PULLDN_OUTPUT),
+
+	/* reg_5v_en */
+#define GP_5V_BST_EN	IMX_GPIO_NR(6, 12)
+	IOMUX_PAD_CTRL(SD4_CLK__GPIO6_IO_12, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(2, 13)
+	IOMUX_PAD_CTRL(KEY_COL3__GPIO2_IO_13, WEAK_PULLDN),
+	/* 32K clock, off for now */
+#define GP_WLAN_LF_CLK		IMX_GPIO_NR(1, 11)
+	IOMUX_PAD_CTRL(GPIO1_IO11__GPIO1_IO_11, WEAK_PULLDN_OUTPUT),
+
+	/* uart1 */
+	IOMUX_PAD_CTRL(GPIO1_IO04__UART1_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO05__UART1_RX, UART_PAD_CTRL),
+
+	/* uart2 */
+	IOMUX_PAD_CTRL(GPIO1_IO06__UART2_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO07__UART2_RX, UART_PAD_CTRL),
+
+	/* uart3 - wifi */
+	IOMUX_PAD_CTRL(NAND_DATA07__UART3_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_DATA06__UART3_RX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_DATA05__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_DATA04__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* uart5 */
+	IOMUX_PAD_CTRL(SD4_DATA5__UART5_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA4__UART5_RX, UART_PAD_CTRL),
+
+	/* USB OTG */
+#define GP_USB_OTG1_OC		IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(QSPI1B_SCLK__GPIO4_IO_29, WEAK_PULLUP),
+#define GP_USB_OTG1_ID		IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(QSPI1B_DQS__GPIO4_IO_28, WEAK_PULLUP),
+#define GP_USB_OTG1_PWR		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(QSPI1B_DATA0__GPIO4_IO_24, WEAK_PULLDN_OUTPUT),
+
+	/* USB OTG2 */
+#define GP_USB_OTG2_OC		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(QSPI1B_SS1_B__GPIO4_IO_31, WEAK_PULLDN_OUTPUT),
+#define GP_USB_OTG2_PWR		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(QSPI1B_DATA1__GPIO4_IO_25, WEAK_PULLDN_OUTPUT),
+
+	/* usdhc1 - microSD */
+	IOMUX_PAD_CTRL(SD1_CLK__USDHC1_CLK, USDHC1_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__USDHC1_CMD, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA0__USDHC1_DATA0, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA1__USDHC1_DATA1, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA2__USDHC1_DATA2, USDHC1_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA3__USDHC1_DATA3, USDHC1_PAD_CTRL),
+#define GP_USDHC1_CD	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(QSPI1B_SS0_B__GPIO4_IO_30, WEAK_PULLUP),
+
+	/* usdhc2 - wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__USDHC2_CLK, USDHC2_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__USDHC2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__USDHC2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__USDHC2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__USDHC2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__USDHC2_DATA3, USDHC2_PAD_CTRL),
+
+	/* WLAN wifi silex */
+#define GPIRQ_WLAN		IMX_GPIO_NR(2, 14)
+	IOMUX_PAD_CTRL(KEY_COL4__GPIO2_IO_14, WEAK_PULLDN),
+#define GP_WLAN_CLK_REQ		IMX_GPIO_NR(2, 12)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO2_IO_12, WEAK_PULLDN),
+#define GP_WLAN_QOW		IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO2_IO_17, WEAK_PULLDN),
+#define GP_BT_HOST_WAKE 	IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(GPIO1_IO13__GPIO1_IO_13, WEAK_PULLDN),
+};
+
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	/* LCDIF1 */
+	IOMUX_PAD_CTRL(LCD1_CLK__LCDIF1_CLK, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_ENABLE__LCDIF1_ENABLE, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_HSYNC__LCDIF1_HSYNC, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_VSYNC__LCDIF1_VSYNC, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_RESET__LCDIF1_RESET, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA00__LCDIF1_DATA_0, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA01__LCDIF1_DATA_1, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA02__LCDIF1_DATA_2, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA03__LCDIF1_DATA_3, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA04__LCDIF1_DATA_4, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA05__LCDIF1_DATA_5, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA06__LCDIF1_DATA_6, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA07__LCDIF1_DATA_7, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA08__LCDIF1_DATA_8, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA09__LCDIF1_DATA_9, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA10__LCDIF1_DATA_10, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA11__LCDIF1_DATA_11, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA12__LCDIF1_DATA_12, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA13__LCDIF1_DATA_13, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA14__LCDIF1_DATA_14, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA15__LCDIF1_DATA_15, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA16__LCDIF1_DATA_16, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA17__LCDIF1_DATA_17, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA18__LCDIF1_DATA_18, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA19__LCDIF1_DATA_19, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA20__LCDIF1_DATA_20, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA21__LCDIF1_DATA_21, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA22__LCDIF1_DATA_22, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA23__LCDIF1_DATA_23, LCDIF_PAD_CTL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	/* LCDIF1 */
+	IOMUX_PAD_CTRL(LCD1_CLK__GPIO3_IO_0, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_ENABLE__GPIO3_IO_25, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_HSYNC__GPIO3_IO_26, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_VSYNC__GPIO3_IO_28, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_RESET__GPIO3_IO_27, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA00__GPIO3_IO_1, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA01__GPIO3_IO_2, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA02__GPIO3_IO_3, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA03__GPIO3_IO_4, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA04__GPIO3_IO_5, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA05__GPIO3_IO_6, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA06__GPIO3_IO_7, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA07__GPIO3_IO_8, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA08__GPIO3_IO_9, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA09__GPIO3_IO_10, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA10__GPIO3_IO_11, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA11__GPIO3_IO_12, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA12__GPIO3_IO_13, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA13__GPIO3_IO_14, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA14__GPIO3_IO_15, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA15__GPIO3_IO_16, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA16__GPIO3_IO_17, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA17__GPIO3_IO_18, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA18__GPIO3_IO_19, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA19__GPIO3_IO_20, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA20__GPIO3_IO_21, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA21__GPIO3_IO_22, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA22__GPIO3_IO_23, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA23__GPIO3_IO_24, LCDIF_PAD_CTL),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	I2C_PADS_INFO_ENTRY(I2C2, GPIO1_IO02, 1, 2, GPIO1_IO03, 1, 3, I2C_PAD_CTRL),	/* PMIC */
+	I2C_PADS_INFO_ENTRY(I2C3, ENET2_RX_CLK, 2, 8, ENET2_TX_CLK, 2, 9, I2C_PAD_CTRL), /* J4 touch */
+	I2C_PADS_INFO_ENTRY(I2C4, SD3_DATA0, 7, 2, SD3_DATA1, 7, 3, I2C_PAD_CTRL),	/* PCA9540B switch, charger/ov5642 */
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : (cs >> 8) ? (cs >> 8) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+			port * 4);
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	gpio_set_value(port ? GP_USB_OTG2_PWR: GP_USB_OTG1_PWR, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC1_CD},
+};
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* tsc2004 */
+	VDF_DC050WX(LCD, "DC050WX", RGB24, 0, NULL, 2, 0x48),
+	VDF_CLAA_WVGA(LCD, "CLAA-WVGA", RGB666, 0, fbp_detect_i2c, 2, 0x48),
+	VDF_SHARP_WVGA(LCD, "sharp-wvga", RGB24, 0, NULL, 2, 0x48),
+	VDF_QVGA(LCD, "qvga", RGB24, 0, NULL, 2, 0x48),
+	VDF_AT035GT_07ET3(LCD, "AT035GT-07ET3", RGB24, 0, NULL, 2, 0x48),
+
+	VDF_1280_720M_60(LCD, "1280x720M@60", RGB24, 0, fbp_detect_i2c, 2, 0x50),
+	VDF_1920_1080M_60(LCD, "1920x1080M@60", RGB24, 0, NULL, 2, 0x50),
+	VDF_1024_768M_60(LCD, "1024x768M@60", RGB24, 0, NULL, 2, 0x50),
+
+	/* fusion7 specific touchscreen */
+	VDF_FUSION7(LCD, "fusion7", RGB666, 0, fbp_detect_i2c, 2, 0x10),
+
+	VDF_LSA40AT9001(LCD, "LSA40AT9001", RGB24, 0, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_POWER_OFF,		/* 0 - on */
+	GP_5V_BST_EN,		/* 0 - off */
+	GP_USB_OTG1_PWR,	/* 0 - off */
+	GP_USB_OTG2_PWR,	/* 0 - off */
+	GP_OV5642_RESET,
+	GP_I2C3_J4_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_WLAN_LF_CLK,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_OV5642_PWRDN,
+	GP_ECSPI1_NOR_CS,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_TP16,
+	GP_TP17,
+	GP_TP18,
+	GP_TP19,
+	GP_GPIOKEY_POWER,
+	GPIRQ_MAX77818_INTB,
+	GPIRQ_MAX77818_WCINOKB,
+	GPIRQ_MAX77818_INOKB,
+	GPIRQ_I2C3_J4,
+	GP_USB_OTG1_OC,
+	GP_USB_OTG1_ID,
+	GP_USB_OTG2_OC,
+	GP_USDHC1_CD,
+	GPIRQ_WLAN,
+	GP_WLAN_CLK_REQ,
+	GP_WLAN_QOW,
+	GP_BT_HOST_WAKE,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	gpio_set_value(GP_POWER_OFF, 1);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0, displays, display_cnt, 0);
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",        MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"mmc1",        MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,          0},
+};
+#endif
+
+const struct button_key board_buttons[] = {
+	{"Power",	GP_GPIOKEY_POWER,	'P', 1},
+	{NULL, 0, 0, 0},
+};
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
+
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_scm/nitrogen6_scm.cfg u-boot-imx6/board/boundary/nitrogen6_scm/nitrogen6_scm.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_scm/nitrogen6_scm.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_scm/nitrogen6_scm.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* enable cko1 as 32k for slow clock */
+/* DATA 4 0x020c4060 0x0000008e */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX - DDR IO Type */
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+
+/* Clock */
+DATA 4 0x020e032c 0x00000030
+
+/* Address */
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+
+/* Control */
+DATA 4 0x020e0340 0x00000028
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+/* Data Strobe */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+
+/* Data */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* */
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x4244464a	/* MPRDDLCTL */
+DATA 4 0x021b0850 0x36343a34	/* MPWRDLCTL */
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+DATA 4 0x021b0000 0x83110000
+
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006 
+DATA 4 0x021b001c 0x00000000
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/Kconfig u-boot-imx6/board/boundary/nitrogen6_som2/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6_som2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,21 @@
+if TARGET_NITROGEN6_SOM2
+
+config SYS_BOARD
+	default "nitrogen6_som2"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nitrogen6_som2"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/MAINTAINERS u-boot-imx6/board/boundary/nitrogen6_som2/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen6_som2/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,8 @@
+NITROGEN6_SOM2 BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen6_som2/
+F:	include/configs/nitrogen6_som2.h
+F:	configs/nitrogen6q_som2_1g_defconfig
+F:	configs/nitrogen6q_som2_2g_defconfig
+F:	configs/nitrogen6q_som2_4g_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/Makefile u-boot-imx6/board/boundary/nitrogen6_som2/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6_som2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen6_som2.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2.c u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2.c
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,572 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* Carrier doesn't use */
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+
+	/* i2c1, rv4162 */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+#define GP_SGTL5000_HP_MUTE	IMX_GPIO_NR(3, 29)		/* Low is muted */
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLDN),
+#define GP_SGTL5000_HP_DET	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_SGTL5000_MIC_DET	IMX_GPIO_NR(1, 24)
+	IOMUX_PAD_CTRL(ENET_RX_ER__GPIO1_IO24, WEAK_PULLUP),
+
+	/* i2c2 ov5640 mipi Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+
+	/* i2c2 TC358743 interrupt */
+#define GPIRQ_TC3587		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* i2c2, ov5642 Camera controls, J5 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__IPU1_CSI0_DATA08, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__IPU1_CSI0_DATA09, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT10__IPU1_CSI0_DATA10, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT11__IPU1_CSI0_DATA11, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),	/* Hsync */
+	IOMUX_PAD_CTRL(CSI0_VSYNC__GPIO5_IO21, WEAK_PULLUP),	/* Vsync */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GP_OV5642_RESET		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+
+	/* i2c3, J7 - touch */
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* i2c3, J28 - touch */
+#define GPIRQ_I2C3_TSC2004	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+	/* LVDS0 - J6 */
+#define GP_LVDS0_EN1		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLDN),
+
+	/* LVDS1 - J29 */
+#define GP_LVDS1_EN1		IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLDN),
+#define GP_LVDS1_EN2		IMX_GPIO_NR(2, 31)
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLDN),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM3 - ov5640 mipi mclk */
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS0	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC2_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_NOR_CS;
+	if (cs >> 8)
+		return (cs >> 8);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS0, enable);
+	gpio_direction_output(GP_LVDS0_EN1, enable);
+}
+
+void board_enable_lvds2(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS1_EN1, enable);
+	gpio_direction_output(GP_LVDS1_EN2, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			enable_spi_rgb(di);
+#endif
+		mdelay(100); /* let panel sync up before enabling backlight */
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+	VD_640_480M_60(HDMI, NULL, 1, 0x50),
+	VD_720_480M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+
+	/* uses both lvds connectors */
+	VD_1080P60(LVDS, NULL, 0, 0x00),
+
+	VD_HANNSTAR7(LVDS2, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS2, NULL, 2, 0x38),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_SGTL5000_HP_MUTE,
+	GP_OV5642_RESET,
+	GP_LVDS0_EN1,
+	GP_LVDS1_EN1,
+	GP_LVDS1_EN2,
+	GP_PCIE_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_BACKLIGHT_LVDS0,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+	GP_USB_HUB_RESET,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_FLEXCAN_STANDBY,
+	GP_OV5640_MIPI_POWER_DOWN,
+	GP_OV5642_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GPIRQ_RTC_RV4162,
+	GP_SGTL5000_HP_DET,
+	GP_SGTL5000_MIC_DET,
+	GPIRQ_I2C3_J7,
+	GPIRQ_I2C3_TSC2004,
+	GP_PCIE_DISABLE,
+	GPIRQ_TC3587,
+	GP_USDHC3_CD,
+	GPIRQ_WL1271_WL,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_dl1g.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_dl1g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_dl1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_dl1g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 10 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x423e023f
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x022c022a
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x421f0227
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02140216
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45474a4e
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x49474944
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37362b2b
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3231332e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00460050
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x003d0042
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00270028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x002a003c
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q1g.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q1g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q1g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 4 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43110320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03080304
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43160324
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x030d0252
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x3d343943
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3c3b3541
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x39394134
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4332453e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x000e001a
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001b0012
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000b001c
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000b0017
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q2g.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q2g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q2g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#ifdef CONFIG_MX6QP
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x4327033b
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x0324031a
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x43240337
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03210269
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x483c3e4a
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x423a3848
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x33363a2c
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3e314137
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x00200026
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00260021
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00180028
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f001e
+#define WALAT	1
+
+#else
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43200336
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03200315
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x432a033d
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x032a026e
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42363c48
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403b3446
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3d3f4737
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4436493d
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x000c0013
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00160012
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000c0017
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00060015
+#define WALAT	1	/* 0 should be fine */
+
+#endif
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 1
+#define BUS_WIDTH 64
+/* H5TC8G63AMR-PBA */
+#include "../common/mx6/1066mhz_256mx16-hynix.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_s1g.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_s1g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_s1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_s1g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42420244
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x022c022e
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45464850
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x39362f2d
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0046004d
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x003a0042
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_s512m.cfg u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_s512m.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_som2/nitrogen6_som2_s512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_som2/nitrogen6_som2_s512m.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 2 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42400242
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x022a0228
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x3f43484c
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x36372d2c
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0042004c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x003a0040
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6sx/imximage.cfg u-boot-imx6/board/boundary/nitrogen6sx/imximage.cfg
--- u-boot-2017.07/board/boundary/nitrogen6sx/imximage.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6sx/imximage.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* enable cko1 as 32k for slow clock */
+DATA 4 0x020c4060 0x0000008e
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX - DDR IO Type */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* Clock */
+DATA 4 0x020e032c 0x00000030
+
+/* Address */
+DATA 4 0x020e0300 0x00000020
+DATA 4 0x020e02fc 0x00000020
+DATA 4 0x020e05f4 0x00000020
+
+/* Control */
+DATA 4 0x020e0340 0x00000020
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000020
+DATA 4 0x020e0314 0x00000020
+DATA 4 0x020e0614 0x00000020
+
+/* Data Strobe */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000028
+DATA 4 0x020e0334 0x00000028
+DATA 4 0x020e0338 0x00000028
+DATA 4 0x020e033c 0x00000028
+
+/* Data */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* Calibrations - ZQ */
+DATA 4 0x021b0800 0xa1390003
+
+/* Write leveling */
+DATA 4 0x021b080c 0x001D001E	/* MPWLDECTRL0 */
+DATA 4 0x021b0810 0x001A0013	/* MPWLDECTRL1 */
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x41380128	/* MPDGCTRL0 */
+DATA 4 0x021b0840 0x0124011C	/* MPDGCTRL1 */
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x3E3E4246	/* MPRDDLCTL */
+DATA 4 0x021b0850 0x34363838	/* MPWRDLCTL */
+
+/* Read data bit delay */
+DATA 4 0x021b081c 0x33333333	/* MPRDDQBY0DL */
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurement */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init - DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+
+/* Initialize MT41K256M16HA-125 - MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00048031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* Final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
diff -Nru u-boot-2017.07/board/boundary/nitrogen6sx/Kconfig u-boot-imx6/board/boundary/nitrogen6sx/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6sx/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6sx/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,20 @@
+if TARGET_NITROGEN6SX
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen6sx"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nitrogen6sx"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6sx/MAINTAINERS u-boot-imx6/board/boundary/nitrogen6sx/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen6sx/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6sx/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+NITROGEN6SX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen6sx/
+F:	include/configs/nitrogen6sx.h
+F:	configs/nitrogen6sx_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen6sx/Makefile u-boot-imx6/board/boundary/nitrogen6sx/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6sx/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6sx/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen6sx.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen6sx/nitrogen6sx.c u-boot-imx6/board/boundary/nitrogen6sx/nitrogen6sx.c
--- u-boot-2017.07/board/boundary/nitrogen6sx/nitrogen6sx.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6sx/nitrogen6sx.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,545 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTL	PAD_CTL_DSE_120ohm
+
+
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_ODE)
+
+#define LCDIF_PAD_CTL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Audmux */
+	IOMUX_PAD_CTRL(SD1_DATA0__AUDMUX_AUD5_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA1__AUDMUX_AUD5_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA2__AUDMUX_AUD5_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA3__AUDMUX_AUD5_TXD, AUD_PAD_CTRL),
+
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO2_IO_17, WEAK_PULLDN_OUTPUT),
+
+	/* CSI */
+	IOMUX_PAD_CTRL(CSI_MCLK__CSI1_MCLK, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_PIXCLK__CSI1_PIXCLK, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_HSYNC__CSI1_HSYNC, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_VSYNC__CSI1_VSYNC, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA00__CSI1_DATA_2, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA01__CSI1_DATA_3, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA02__CSI1_DATA_4, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA03__CSI1_DATA_5, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA04__CSI1_DATA_6, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA05__CSI1_DATA_7, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA06__CSI1_DATA_8, CSI_PAD_CTL),
+	IOMUX_PAD_CTRL(CSI_DATA07__CSI1_DATA_9, CSI_PAD_CTL),
+#define GP_OV5642_RESET		IMX_GPIO_NR(4, 2)
+	IOMUX_PAD_CTRL(NAND_CE1_B__GPIO4_IO_2, WEAK_PULLDN_OUTPUT),
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(4, 0)
+	IOMUX_PAD_CTRL(NAND_ALE__GPIO4_IO_0, WEAK_PULLUP_OUTPUT),
+
+	/* ECSPI1 (serial nor eeprom) */
+	IOMUX_PAD_CTRL(KEY_COL1__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_COL0__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO2_IO_16, WEAK_PULLUP),
+
+	/* enet phy */
+	IOMUX_PAD_CTRL(ENET1_MDC__ENET1_MDC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_MDIO__ENET1_MDIO, WEAK_PULLUP),
+
+	/* fec1 */
+	IOMUX_PAD_CTRL(RGMII1_TD0__ENET1_TX_DATA_0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD1__ENET1_TX_DATA_1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD2__ENET1_TX_DATA_2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD3__ENET1_TX_DATA_3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TXC__ENET1_RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TX_CTL__ENET1_TX_EN, PAD_CTRL_ENET_TX),
+	/* AR8035 PHY Reset */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(ENET2_CRS__GPIO2_IO_7, WEAK_PULLUP),
+#define GP_RGMII_PHY_INT	IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(ENET1_RX_CLK__GPIO2_IO_4, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_TX_CLK__GPIO2_IO_5, WEAK_PULLUP),
+
+	/* fec2 */
+	IOMUX_PAD_CTRL(RGMII2_TD0__ENET2_TX_DATA_0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD1__ENET2_TX_DATA_1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD2__ENET2_TX_DATA_2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD3__ENET2_TX_DATA_3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TXC__ENET2_RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TX_CTL__ENET2_TX_EN, PAD_CTRL_ENET_TX),
+	/* AR8035 PHY Reset */
+#define GP_RGMII2_PHY_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(ENET2_COL__GPIO2_IO_6, WEAK_PULLUP),
+#define GP_RGMII2_PHY_INT	IMX_GPIO_NR(2, 8)
+	IOMUX_PAD_CTRL(ENET2_RX_CLK__GPIO2_IO_8, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET2_TX_CLK__GPIO2_IO_9, WEAK_PULLUP),
+
+	/* flexcan1 */
+	IOMUX_PAD_CTRL(QSPI1B_DQS__CAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1A_SS1_B__CAN1_RX, WEAK_PULLUP),
+#define GP_CAN1_STANDBY		IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(QSPI1B_DATA3__GPIO4_IO_27, WEAK_PULLUP),
+
+	/* flexcan2 */
+	IOMUX_PAD_CTRL(QSPI1A_DQS__CAN2_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1B_SS1_B__CAN2_RX, WEAK_PULLUP),
+#define GP_CAN2_STANDBY		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(QSPI1B_DATA0__GPIO4_IO_24, WEAK_PULLUP),
+
+	/* hogs - expanders */
+	IOMUX_PAD_CTRL(NAND_CE0_B__GPIO4_IO_1, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NAND_WE_B__GPIO4_IO_14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NAND_WP_B__GPIO4_IO_15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NAND_READY_B__GPIO4_IO_13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1A_DATA0__GPIO4_IO_16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1A_DATA1__GPIO4_IO_17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1A_DATA2__GPIO4_IO_18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(QSPI1A_DATA3__GPIO4_IO_19, WEAK_PULLUP),
+#define GP_WIFI_PASS	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(NAND_DATA02__GPIO4_IO_6, WEAK_PULLDN_OUTPUT),
+#define GP_WIFI_FAIL	IMX_GPIO_NR(4, 4)
+	IOMUX_PAD_CTRL(NAND_DATA00__GPIO4_IO_4, WEAK_PULLDN_OUTPUT),
+#define GP_WIFI_TEST	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(NAND_DATA03__GPIO4_IO_7, WEAK_PULLUP),
+
+	/* hogs - Test points */
+	IOMUX_PAD_CTRL(NAND_DATA04__GPIO4_IO_8, WEAK_PULLUP),
+
+	/* I2C2 */
+#define GPIRQ_I2C2_TFP410	IMX_GPIO_NR(4, 3)
+	IOMUX_PAD_CTRL(NAND_CLE__GPIO4_IO_3, WEAK_PULLUP),
+#define GP_I2C2_TFP410_I2C_SEL	IMX_GPIO_NR(4, 12)
+	IOMUX_PAD_CTRL(NAND_RE_B__GPIO4_IO_12, WEAK_PULLUP),
+
+	/* I2C3 */
+#define GPIRQ_I2C3_J18	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(QSPI1B_DATA1__GPIO4_IO_25, WEAK_PULLUP),
+
+	/* LVDS */
+#define GP_LVDS_ENABLE	IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(QSPI1A_SCLK__GPIO4_IO_21, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_WAKE	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(NAND_DATA05__GPIO4_IO_9, WEAK_PULLUP),
+#define GP_PCIE_RESET	IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(NAND_DATA06__GPIO4_IO_10, WEAK_PULLUP),
+#define GP_PCIE_DISABLE	IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(NAND_DATA07__GPIO4_IO_11, WEAK_PULLUP),
+
+	/* PWM4 - for LVDS panel */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(GPIO1_IO13__GPIO1_IO_13, WEAK_PULLDN_OUTPUT),
+
+	/* reg_wlan */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(7, 6)
+	IOMUX_PAD_CTRL(SD3_DATA4__GPIO7_IO_6, WEAK_PULLDN_OUTPUT),
+	IOMUX_PAD_CTRL(GPIO1_IO11__CCM_CLKO1, OUTPUT_40OHM),
+
+#define GP_REG_WIFI_1P8V_EN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(NAND_DATA01__GPIO4_IO_5, WEAK_PULLDN_OUTPUT),
+
+#define GP_REG_WIFI_3P3V_EN	IMX_GPIO_NR(6, 1)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO6_IO_1, WEAK_PULLDN_OUTPUT),
+
+	/* sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO1_IO12__CCM_CLKO2, OUTPUT_40OHM),
+#define GP_SGTL5000_HP_DETECT	IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(ENET1_COL__GPIO2_IO_0, WEAK_PULLUP),
+#define GP_SGTL5000_MIC_DETECT	IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(ENET1_CRS__GPIO2_IO_1, WEAK_PULLUP),
+#define GP_SGTL5000_MUTE		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(QSPI1A_SS0_B__GPIO4_IO_22, WEAK_PULLDN_OUTPUT),
+
+	/* uart1 */
+	IOMUX_PAD_CTRL(GPIO1_IO04__UART1_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO05__UART1_RX, UART_PAD_CTRL),
+
+	/* uart2 */
+	IOMUX_PAD_CTRL(GPIO1_IO06__UART2_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO07__UART2_RX, UART_PAD_CTRL),
+
+	/* uart3 */
+	IOMUX_PAD_CTRL(QSPI1B_SS0_B__UART3_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(QSPI1B_SCLK__UART3_RX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA7__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA6__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* uart5 */
+	IOMUX_PAD_CTRL(KEY_COL3__UART5_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW3__UART5_RX, UART_PAD_CTRL),
+
+	/* USB OTG1 */
+	IOMUX_PAD_CTRL(GPIO1_IO08__USB_OTG1_OC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO1_IO10__ANATOP_OTG1_ID, WEAK_PULLUP),
+
+	/* USB OTG1 vbus */
+#define GP_USB_OTG1_PWR		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO1_IO09__GPIO1_IO_9, WEAK_PULLDN_OUTPUT),
+
+	/* USB OTG2 */
+	/* USB Hub Reset for USB2513 3 port hub */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(QSPI1B_DATA2__GPIO4_IO_26, OUTPUT_40OHM),
+
+	/* usdhc2 - micro SD */
+	IOMUX_PAD_CTRL(SD2_CLK__USDHC2_CLK, USDHC2_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__USDHC2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__USDHC2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__USDHC2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__USDHC2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__USDHC2_DATA3, USDHC2_PAD_CTRL),
+#define GP_USDHC2_CD	IMX_GPIO_NR(2, 12)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO2_IO_12, WEAK_PULLUP),
+
+	/* usdhc3 - wifi */
+	IOMUX_PAD_CTRL(SD3_CLK__USDHC3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__USDHC3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA0__USDHC3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA1__USDHC3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA2__USDHC3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA3__USDHC3_DATA3, USDHC_PAD_CTRL),
+
+	/* usdhc4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__USDHC4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__USDHC4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_RESET_B__USDHC4_RESET_B, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA0__USDHC4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA1__USDHC4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA2__USDHC4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA3__USDHC4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA4__USDHC4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA5__USDHC4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA6__USDHC4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA7__USDHC4_DATA7, USDHC_PAD_CTRL),
+
+#define GPIRQ_WLAN	IMX_GPIO_NR(7, 7)
+	IOMUX_PAD_CTRL(SD3_DATA5__GPIO7_IO_7, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	/* LCDIF1 */
+	IOMUX_PAD_CTRL(LCD1_CLK__LCDIF1_CLK, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_ENABLE__LCDIF1_ENABLE, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_HSYNC__LCDIF1_HSYNC, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_VSYNC__LCDIF1_VSYNC, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_RESET__LCDIF1_RESET, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA00__LCDIF1_DATA_0, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA01__LCDIF1_DATA_1, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA02__LCDIF1_DATA_2, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA03__LCDIF1_DATA_3, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA04__LCDIF1_DATA_4, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA05__LCDIF1_DATA_5, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA06__LCDIF1_DATA_6, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA07__LCDIF1_DATA_7, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA08__LCDIF1_DATA_8, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA09__LCDIF1_DATA_9, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA10__LCDIF1_DATA_10, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA11__LCDIF1_DATA_11, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA12__LCDIF1_DATA_12, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA13__LCDIF1_DATA_13, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA14__LCDIF1_DATA_14, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA15__LCDIF1_DATA_15, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA16__LCDIF1_DATA_16, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA17__LCDIF1_DATA_17, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA18__LCDIF1_DATA_18, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA19__LCDIF1_DATA_19, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA20__LCDIF1_DATA_20, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA21__LCDIF1_DATA_21, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA22__LCDIF1_DATA_22, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA23__LCDIF1_DATA_23, LCDIF_PAD_CTL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	/* LCDIF1 */
+	IOMUX_PAD_CTRL(LCD1_CLK__GPIO3_IO_0, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_ENABLE__GPIO3_IO_25, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_HSYNC__GPIO3_IO_26, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_VSYNC__GPIO3_IO_28, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_RESET__GPIO3_IO_27, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA00__GPIO3_IO_1, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA01__GPIO3_IO_2, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA02__GPIO3_IO_3, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA03__GPIO3_IO_4, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA04__GPIO3_IO_5, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA05__GPIO3_IO_6, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA06__GPIO3_IO_7, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA07__GPIO3_IO_8, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA08__GPIO3_IO_9, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA09__GPIO3_IO_10, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA10__GPIO3_IO_11, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA11__GPIO3_IO_12, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA12__GPIO3_IO_13, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA13__GPIO3_IO_14, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA14__GPIO3_IO_15, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA15__GPIO3_IO_16, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA16__GPIO3_IO_17, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA17__GPIO3_IO_18, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA18__GPIO3_IO_19, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA19__GPIO3_IO_20, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA20__GPIO3_IO_21, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA21__GPIO3_IO_22, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA22__GPIO3_IO_23, LCDIF_PAD_CTL),
+	IOMUX_PAD_CTRL(LCD1_DATA23__GPIO3_IO_24, LCDIF_PAD_CTL),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, GPIO1_IO00, 1, 0, GPIO1_IO01, 1, 1, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, GPIO1_IO02, 1, 2, GPIO1_IO03, 1, 3, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, KEY_COL4, 2, 14, KEY_ROW4, 2, 19, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : (cs >> 8) ? (cs >> 8) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+			port * 4);
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	/* Reset USB hub */
+	gpio_direction_output(GP_USB_HUB_RESET, 0);
+	mdelay(2);
+	gpio_set_value(GP_USB_HUB_RESET, 1);
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG1_PWR, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC2_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,},
+};
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+	gpio_direction_output(GP_LVDS_ENABLE, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	unsigned tfp410_i2c_addr = 0x38;
+	unsigned gp = GP_I2C2_TFP410_I2C_SEL;
+	int ret;
+	u8 orig_i2c_bus;
+	u8 val8;
+
+	orig_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(1);
+	if (enable) {
+		//tfp410 low to high of sel is reset, then i2c_mode
+		gpio_set_value(gp, 0);
+		udelay(5);
+		gpio_set_value(gp, 1);
+		SETUP_IOMUX_PADS(rgb_pads);
+
+		val8 = 0xbd;	/* ON */
+		ret = i2c_write(tfp410_i2c_addr, 0x8, 1, &val8, 1);
+		if (ret) {
+			/* On i2c failure, put back into non-i2c mode */
+			gpio_set_value(gp, 0);
+		}
+	} else {
+		val8 = 0xbc;	/* OFF */
+		i2c_write(tfp410_i2c_addr, 0x8, 1, &val8, 1);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	}
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi/lcd via tfp410 */
+	VDF_1280_720M_60(LCD, "1280x720M@60", RGB24, 0, fbp_detect_i2c, 2, 0x50),
+	VDF_1920_1080M_60(LCD, "1920x1080M@60", RGB24, 0, NULL, 2, 0x50),
+	VDF_1024_768M_60(LCD, "1024x768M@60", RGB24, 0, NULL, 2, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VDF_FUSION7(LCD, "fusion7", RGB666, 0, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VDF_CLAA_WVGA(LCD, "CLAA-WVGA", RGB666, 0, fbp_detect_i2c, 2, 0x48),
+	VDF_SHARP_WVGA(LCD, "sharp-wvga", RGB24, 0, NULL, 2, 0x48),
+	VDF_DC050WX(LCD, "DC050WX", RGB24, 0, NULL, 2, 0x48),
+	VDF_QVGA(LCD, "qvga", RGB24, 0, NULL, 2, 0x48),
+	VDF_AT035GT_07ET3(LCD, "AT035GT-07ET3", RGB24, 0, NULL, 2, 0x48),
+
+	VDF_LSA40AT9001(LCD, "LSA40AT9001", RGB24, 0, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_REG_WIFI_1P8V_EN,
+	GP_REG_WIFI_3P3V_EN,
+	GP_WIFI_PASS,
+	GP_WIFI_FAIL,
+	GP_RGMII_PHY_RESET,
+	GP_RGMII2_PHY_RESET,
+	GP_BACKLIGHT_LVDS,
+	GP_USB_HUB_RESET,
+	GP_USB_OTG1_PWR,
+	GP_LVDS_ENABLE,
+	GP_PCIE_RESET,
+	GP_SGTL5000_MUTE,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_I2C2_TFP410_I2C_SEL,
+	GP_CAN1_STANDBY,
+	GP_CAN2_STANDBY,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_WIFI_TEST,
+	GP_RGMII_PHY_INT,
+	GP_RGMII2_PHY_INT,
+	GP_USDHC2_CD,
+	GP_PCIE_WAKE,
+	GP_PCIE_DISABLE,
+	GP_SGTL5000_HP_DETECT,
+	GP_SGTL5000_MIC_DETECT,
+	GPIRQ_WLAN,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0, displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",        MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"mmc1",        MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,          0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/6x_bootscript.txt u-boot-imx6/board/boundary/nitrogen6_vm/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/nitrogen6_vm/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/6x_bootscript.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,108 @@
+setenv bootargs enable_wait_mode=off fec.disable_giga=1;
+setenv nextcon 0;
+setenv lvds 0;
+
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 1024x600 display";
+fi
+
+if i2c probe 0x41 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no ILI210x touch controller";
+fi
+
+if test "0" -eq $lvds; then
+	echo "Default to wqvga (480x272) display";
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,okaya_480x272,if=RGB24
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "usb" = "${dtype}" ; then
+        setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+elif itest.s "x" == "x$sdphys" ; then
+        setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+elif itest 0 -eq ${disk}; then
+        setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+else
+        setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+dtbname="imx6dl-nitrogen6_vm.dtb";
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/6x_bootscript-yocto.txt u-boot-imx6/board/boundary/nitrogen6_vm/6x_bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/nitrogen6_vm/6x_bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/6x_bootscript-yocto.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,112 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+setenv bootargs enable_wait_mode=off fec.disable_giga=1;
+setenv nextcon 0;
+setenv lvds 0;
+
+if test -n "$tempfuse" ; then
+	setenv bootargs $bootargs thermal.fusedata=$tempfuse
+fi
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 1024x600 display";
+fi
+
+if i2c probe 0x41 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no ILI210x touch controller";
+fi
+
+if test "0" -eq $lvds; then
+	echo "Default to wqvga (480x272) display";
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,okaya_480x272,if=RGB24
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "usb" = "${dtype}" ; then
+        setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+elif itest.s "x" == "x$sdphys" ; then
+        setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+elif itest 0 -eq ${disk}; then
+        setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+else
+        setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+dtbname="imx6dl-nitrogen6_vm.dtb";
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/Kconfig u-boot-imx6/board/boundary/nitrogen6_vm/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6_vm/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,20 @@
+if TARGET_NITROGEN6_VM
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nitrogen6_vm"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nitrogen6_vm"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/MAINTAINERS u-boot-imx6/board/boundary/nitrogen6_vm/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen6_vm/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+NITROGEN6_VM BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen6_vm/
+F:	include/configs/nitrogen6_vm.h
+F:	configs/nitrogen6_vm_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/Makefile u-boot-imx6/board/boundary/nitrogen6_vm/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6_vm/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen6_vm.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm.c u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm.c
--- u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,442 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+
+/* Special MXCFB sync flags are here. */
+#include "../drivers/video/mxcfb.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define HIGH_Z_SLOW	(PAD_CTL_HYS|PAD_CTL_SPEED_LOW | PAD_CTL_DSE_DISABLE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/* 3.3 V */
+#define USDHC3_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL	(USDHC3_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/* 1.8 V */
+#define USDHC4_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC4_PAD_CTRL	(USDHC4_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_CS1	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP), /* SS1 */
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),
+#define GP_ENET_PHY_INT		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),	/* Micrel RGMII Phy Interrupt */
+
+	/* GPIO_KEYS */
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+
+	/* i2c1 SGTL5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_SGTL5000_MUTE	IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLDN_OUTPUT),
+
+	/* i2c2 - rtc */
+#define GPIRQ_RTC		IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+
+	/* I2C3 */
+#define GPIRQ_TOUCH		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+#define GP_AR1021_5_WIRE_SEL	IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, HIGH_Z_SLOW),
+#define GP_PCAP_NRESET		IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP_OUTPUT),
+
+	/* LVDS */
+#define GP_LVDS_EN		IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),		/* J39 - pin 19, DISP0_CONTRAST */
+
+	/* LEDS */
+#define GP_VM_GPIO_1		IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+#define GP_VM_GPIO_2		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_VM_GPIO_3		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),
+#define GP_VM_GPIO_4		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),
+#define GP_VM_GPIO_5		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+#define GP_VM_GPIO_6		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLUP),
+#define GP_VM_GPIO_7		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+#define GP_VM_GPIO_8		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* PWM3 */
+#define GP_RGB_BACKLIGHT	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN_OUTPUT),
+
+	/* PWM4 */
+#define GP_LVDS_BACKLIGHT	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN_OUTPUT),
+
+	/* UART1  */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 for debug */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+	/* UART3 - Broadcom Bluetooth*/
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+
+	/* USBOTG - J3 */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* USDHC3 - FULL sd */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+#define GP_USDHC3_CD	IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#define GP_USDHC3_WP	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC4_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, OUTPUT_40OHM),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 - hdmi */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, Charger, PCIe */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_CS1 : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS_BACKLIGHT, enable);
+	gpio_direction_output(GP_LVDS_EN, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_RGB_BACKLIGHT, enable);
+}
+
+static const struct display_info_t displays[] = {
+#ifdef CONFIG_DEFAULT_HITACHI_HVGA
+	/* ft5x06 */
+	VD_HITACHI_HVGA(LCD, NULL, 2, 0x38),
+#endif
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+#ifndef CONFIG_DEFAULT_HITACHI_HVGA
+	VD_HITACHI_HVGA(LCD, fbp_detect_i2c, 2, 0x38),
+#endif
+	VD_HANNSTAR7(LVDS, NULL, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_LVDS_EN,
+	GP_RGB_BACKLIGHT,
+	GP_LVDS_BACKLIGHT,
+	GP_SGTL5000_MUTE,
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_CS1,		/* SS1 of spi nor */
+	GP_PCAP_NRESET,		/* PCAP reset on J40 */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ENET_PHY_INT,
+	GP_AR1021_5_WIRE_SEL,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_BACK,
+	GPIRQ_TOUCH,
+	GPIRQ_RTC,
+	GP_USDHC3_CD,
+	GP_USDHC3_WP,
+	GP_VM_GPIO_1,
+	GP_VM_GPIO_2,
+	GP_VM_GPIO_3,
+	GP_VM_GPIO_4,
+	GP_VM_GPIO_5,
+	GP_VM_GPIO_6,
+	GP_VM_GPIO_7,
+	GP_VM_GPIO_8,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm.cfg u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm.cfg
--- u-boot-2017.07/board/boundary/nitrogen6_vm/nitrogen6_vm.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6_vm/nitrogen6_vm.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/1066mhz_4x128mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/1066mhz_4x128mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/1066mhz_4x128mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/1066mhz_4x128mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x555A7974
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x005A1023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
-DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
-DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42720306
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026F0266
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x4273030A
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02740240
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45393B3E
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x403A3747
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40434541
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x473E4A3B
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0011000E
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x000E001B
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00190015
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00070018
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/1066mhz_4x256mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/1066mhz_4x256mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/1066mhz_4x256mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/1066mhz_4x256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E7974
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
-DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
-DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42740304
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026e0265
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x02750306
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02720244
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x463d4041
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x42413c47
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x37414441
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x4633473b
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0025001f
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x00290027
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001f002b
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x000f0029
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript_android.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript_android.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript_android.txt	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript_android.txt	2018-08-27 21:35:36.950804999 +0300
@@ -9,9 +9,9 @@
 if i2c probe 0x04 ; then
 	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
 	if test "0" -eq $nextcon; then
-		setenv fbcon "fbcon=10M";
+		setenv fbmem "fbmem=10M";
 	else
-		setenv fbcon ${fbcon},10M
+		setenv fbmem ${fbmem},10M
 	fi
 	setexpr nextcon $nextcon + 1
 else
@@ -21,9 +21,9 @@
 if i2c probe 0x38 ; then
 	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
 	if test "0" -eq $nextcon; then
-		setenv fbcon "fbcon=10M";
+		setenv fbmem "fbmem=10M";
 	else
-		setenv fbcon ${fbcon},10M
+		setenv fbmem ${fbmem},10M
 	fi
 	setexpr nextcon $nextcon + 1
 else
@@ -33,9 +33,9 @@
 if i2c probe 0x48 ; then
 	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,CLAA-WVGA,if=RGB666 tsdev=tsc2004 calibration
 	if test "0" -eq $nextcon; then
-		setenv fbcon "fbcon=10M";
+		setenv fbmem "fbmem=10M";
 	else
-		setenv fbcon ${fbcon},10M
+		setenv fbmem ${fbmem},10M
 	fi
 	setexpr nextcon $nextcon + 1
 else
@@ -45,9 +45,9 @@
 if hdmidet ; then
 	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
 	if test "0" -eq $nextcon; then
-		setenv fbcon "fbcon=28M";
+		setenv fbmem "fbmem=28M";
 	else
-		setenv fbcon ${fbcon},28M
+		setenv fbmem ${fbmem},28M
 	fi
 	setexpr nextcon $nextcon + 1
 else
@@ -59,6 +59,6 @@
 	setexpr nextcon $nextcon + 1 ;
 done
 
-setenv bootargs $bootargs fbcon=$fbcon
+setenv bootargs $bootargs $fbmem
 ${fs}load ${dtype} ${disk}:1 10800000 uImage && ${fs}load ${dtype} ${disk}:1 12800000 uramdisk.img && bootm 10800000 12800000
 echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-mainline.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-mainline.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-mainline.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-mainline.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,153 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+a_base=0x10000000
+if itest.s x51 == "x${cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${cpu}" || itest.s x7D == "x${cpu}"; then
+	a_base=0x80000000
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${dtbname}" ; then
+	if itest.s x6SOLO == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${cpu}" ; then
+		dtbname=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${cpu}" ; then
+		dtbname=imx6sx-${board}.dtb;
+	elif itest.s x7D == "x${cpu}" ; then
+		dtbname=imx7d-${board}.dtb;
+	elif itest.s x51 == "x${cpu}" ; then
+		dtbname=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${cpu}" ; then
+		dtbname=imx53-${board}${m4}.dtb;
+	else
+		dtbname=imx6q-${board}.dtb;
+	fi
+fi
+
+if load ${dtype} ${disk}:1 ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/
+fi
+
+if itest.s x${bootpart} == x ; then
+	bootpart=1
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_fdt} ${bootdir}${dtbname} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}${dtbname}";
+	exit;
+fi
+
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+fi
+
+## HDMI ##
+if itest.s "xoff" == "x$fb_hdmi" ; then
+	setenv bootargs $bootargs video=HDMI-A-1:d
+else
+	if itest.s "x" != "x$force_edid" ; then
+		echo "------ forcing EDID to /lib/firmware/$force_edid"
+		setenv bootargs $bootargs drm_kms_helper.edid_firmware=$force_edid
+	fi
+fi
+
+## LVDS ##
+if itest.s "xoff" == "x$fb_lvds" ; then
+	setenv bootargs $bootargs video=LVDS-1:d
+elif itest.s "xhannstar7" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "hannstar,hsd070pww1"
+elif itest.s "xtm070jdhg30" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "tianma,tm070jdhg30"
+elif itest.s "xdt070btft" == "x$fb_lvds" ; then
+	fdt set /panel-lvds0 compatible "innolux,zj070na-01p"
+fi
+
+if itest.s "xoff" == "x$fb_lvds2" ; then
+	setenv bootargs $bootargs video=LVDS-2:d
+elif itest.s "xhannstar7" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "hannstar,hsd070pww1"
+elif itest.s "xtm070jdhg30" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "tianma,tm070jdhg30"
+elif itest.s "xdt070btft" == "x$fb_lvds2" ; then
+	fdt set /panel-lvds1 compatible "innolux,zj070na-01p"
+fi
+
+## LCD ##
+if itest.s "xoff" == "x$fb_lcd" ; then
+	setenv bootargs $bootargs video=VGA-1:d
+fi
+
+if itest.s x${rfspart} == x ; then
+	rfspart=2
+fi
+
+if itest.s "x" == "x${root}"; then
+	part uuid ${dtype} ${disk}:${rfspart} uuid
+	if itest.s "x" != "x${uuid}"; then
+		root=PARTUUID=${uuid}
+	elif test "sata" = "${dtype}" || test "usb" = "${dtype}" ; then
+		root=/dev/sda${rfspart}
+	else
+		root=/dev/mmcblk${disk}p${rfspart}
+	fi
+fi
+
+if itest.s "x" == "x$cma" ; then
+	cma=256M
+fi
+
+if itest.s "x" == "x$vmalloc" ; then
+	vmalloc=400M
+fi
+
+if itest.s "x" != "x$show_fdt" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x$show_env" ; then
+	printenv
+fi
+
+setenv bootargs "$bootargs console=${console},115200 vmalloc=${vmalloc}"
+setenv bootargs "$bootargs cma=${cma} consoleblank=0 root=${root} rootwait"
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_zImage} ${bootdir}zImage ; then
+	bootz ${a_zImage} - ${a_fdt}
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript.txt	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript.txt	2018-08-27 21:35:36.950804999 +0300
@@ -1,7 +1,13 @@
-setenv bootargs enable_wait_mode=off
+if ${fs}load ${dtype} ${disk}:1 10800000 uEnv.txt ; then
+    env import -t 10800000 $filesize
+else
+    setenv bootargs enable_wait_mode=off
+fi
+
 setenv nextcon 0;
 
-if hdmidet ; then
+i2c dev 1 ;
+if i2c probe 0x50 ; then
 	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
 	setenv fbmem "fbmem=28M";
 	setexpr nextcon $nextcon + 1
@@ -23,7 +29,29 @@
 fi
 
 if i2c probe 0x38 ; then
-	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if itest.s "xLDB-WXGA" == "x$panel"; then
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1280x800MR@60,if=RGB666
+		screenres=1280,800
+	else
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+		screenres=1024,600
+	fi
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+	setenv bootargs $bootargs ft5x06_ts.screenres=$screenres
+	if itest.s "x" -ne "x$calibration" ; then
+		setenv bootargs $bootargs ft5x06_ts.calibration=$calibration
+	fi
+else
+	echo "------ no ft5x06 touch controller";
+fi
+
+if i2c probe 0x41 ; then
+        setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
 	if test "0" -eq $nextcon; then
 		setenv fbmem "fbmem=10M";
 	else
@@ -31,11 +59,16 @@
 	fi
 	setexpr nextcon $nextcon + 1
 else
-	echo "------ no 1024x600 display";
+	echo "------ no ILI210x touch controller";
 fi
 
 if i2c probe 0x48 ; then
-	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,CLAA-WVGA,if=RGB666
+	if itest.s "xqvga" == "x$panel" ; then
+		display="320x240MR@60,if=RGB24";
+	else
+		display="CLAA-WVGA,if=RGB666";
+	fi
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,$display
 	if test "0" -eq $nextcon; then
 		setenv fbmem "fbmem=10M";
 	else
@@ -46,7 +79,7 @@
 	echo "------ no 800x480 display";
 fi
 
-while test "3" -ne $nextcon ; do
+while test "4" -ne $nextcon ; do
 	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
 	setexpr nextcon $nextcon + 1 ;
 done
@@ -54,10 +87,71 @@
 setenv bootargs $bootargs $fbmem
 setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
 
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
 if test "sata" = "${dtype}" ; then
-	setenv bootargs "$bootargs root=/dev/sda1" ;
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+        if test "usb" = "${dtype}" ; then
+                setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+        elif itest.s "x" == "x$sdphys" ; then
+                setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+        elif itest 0 -eq ${disk}; then
+                setenv bootargs "$bootargs root=/dev/mmcblk2p$bootpart" ;
+        else
+                setenv bootargs "$bootargs root=/dev/mmcblk3p$bootpart" ;
+        fi
+fi
+
+dtbname="imx6";
+if itest.s x6SOLO == "x$cpu" ; then
+	dtbname=${dtbname}dl-;
+elif itest.s x6DL == "x$cpu" ; then
+	dtbname=${dtbname}dl-;
+else
+	dtbname=${dtbname}q-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
 else
-	setenv "bootargs $bootargs root=/dev/mmcblk0p1" ;
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if itest.s "x" != "x$disable_giga" ; then
+        setenv bootargs $bootargs fec.disable_giga=1
+fi
+
+if itest.s "x" != "x$wlmac" ; then
+        setenv bootargs $bootargs wlcore.mac=$wlmac
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
 fi
-${fs}load ${dtype} ${disk}:1 10800000 /boot/uImage && bootm 10800000 ;
 echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.17.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.17.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.17.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.17.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,240 @@
+if ${fs}load ${dtype} ${disk}:1 10800000 uEnv.txt ; then
+    env import -t 10800000 $filesize
+else
+    setenv bootargs enable_wait_mode=off
+fi
+
+setenv nextcon 0;
+
+if itest.s x == x${hdmires} ; then
+	setenv hdmires 1280x720M@60,if=RGB24,bpp=32
+	setenv only_cea 1
+fi
+
+# if hdmidet ; then
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,${hdmires}
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	if itest.s "xLDB-WXGA" == "x$panel"; then
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1280x800MR@60,if=RGB666
+		screenres=1280,800
+	else
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+		screenres=1024,600
+	fi
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+	setenv bootargs $bootargs ft5x06_ts.screenres=$screenres
+	if itest.s "x" -ne "x$calibration" ; then
+		setenv bootargs $bootargs ft5x06_ts.calibration=$calibration
+	fi
+else
+	echo "------ no ft5x06 touch controller";
+fi
+
+if i2c probe 0x41 ; then
+        setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no ILI210x touch controller";
+fi
+
+if i2c probe 0x48 ; then
+	if itest.s "xqvga" == "x$panel" ; then
+		display="320x240MR@60,if=RGB24";
+	else
+		display="CLAA-WVGA,if=RGB666";
+	fi
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,$display
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 800x480 display";
+fi
+
+if itest.s "x1080P" == "x$panel" ; then
+	setenv bootargs $bootargs ldb=spl0 video=mxcfb${nextcon}:dev=ldb,1920x1080MR@60,if=RGB24
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=48M";
+	else
+		setenv fbmem ${fbmem},48M
+	fi
+	setexpr nextcon $nextcon + 1
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait fixrtc"
+
+if itest.s "x" != "x$wlmac" ; then
+	setenv bootargs $bootargs wlcore.mac=$wlmac
+fi
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+setenv bpart "$bootpart"
+
+if   itest.s "$bpart" == a ; then
+	setenv bpart 10
+elif itest.s "$bpart" == b ; then
+	setenv bpart 11
+elif itest.s "$bpart" == c ; then
+	setenv bpart 12
+elif itest.s "$bpart" == d ; then
+	setenv bpart 13
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bpart" ;
+else
+	if test "usb" = "${dtype}" ; then
+		setenv bootargs "$bootargs root=/dev/sda$bpart" ;
+	elif itest 0 -eq ${disk}; then
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-2198000.usdhc-part1" ;
+	else
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-219c000.usdhc-part1" ;
+	fi
+fi
+
+
+
+if itest.s x == "x$dtbname" ; then
+        dtbname="imx6";
+        if itest.s x6SOLO == "x$cpu" ; then
+        	dtbname=${dtbname}dl-;
+        elif itest.s x6DL == "x$cpu" ; then
+        	dtbname=${dtbname}dl-;
+        else
+        	dtbname=${dtbname}q-;
+        fi
+        
+        if itest.s x == "x$board" ; then
+        	board=sabrelite
+        fi
+        
+        dtbname=${dtbname}${board}.dtb;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot
+fi
+
+if itest.s x == x${only_cea} ; then
+	if itest.s x == x$allow_noncea ; then
+		setenv only_cea 1
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv only_cea 0
+		echo "non-CEA modes allowed on HDMI port, audio may be affected";
+	fi
+fi
+
+setenv bootargs $bootargs mxc_hdmi.only_cea=${only_cea}
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs $bootargs fec.disable_giga=1
+fi
+
+if itest.s "x" != "x$gpumem" ; then
+	setenv bootargs $bootargs galcore.contiguousSize=$gpumem
+fi
+
+if itest.s "no" != "$dosplash" ; then
+	setenv bootargs $bootargs splash quiet plymouth.ignore-serial-consoles
+fi
+
+if itest.s "x" != "x$overlayfs" ; then
+	setenv bootargs $bootargs overlayfs=${overlayfs}
+	if itest.s "x" != "x${ofs-size}" ; then
+		setenv bootargs $bootargs ofs-size=${ofs-size}
+	fi
+fi
+
+if kbd ; then
+        if itest.s "xv" == "x$keybd" ; then
+                ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 ${bootdir}/uImage-recovery &&
+                ${fs}load ${dtype} ${disk}:${bootpart} 0x12800000 ${bootdir}/uramdisk-recovery.img &&
+                bootm 10800000 12800000;
+                echo "--- error launching recovery!"
+                exit;
+        fi
+fi
+
+setenv fdt_high 0xffffffff
+setenv initrd_high 0xffffffff
+
+setenv initrd_addr 0x12a00000
+setenv fdt_addr    0x13000000
+
+echo "----------- trying to load /initrd.img";
+if ${fs}load ${dtype} ${disk}:${bootpart} ${initrd_addr} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+echo "----------- trying to load ${bootdir}/$dtbname";
+if ${fs}load ${dtype} ${disk}:${bootpart} ${fdt_addr} ${bootdir}/$dtbname ; then
+	havedtb=1;
+else
+	havedtb=
+fi
+
+if itest.s x$haverd == x ; then
+	if ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 /vmlinuz ; then
+		if itest.s x$havedtb == x ; then
+			bootz 0x10800000 ;
+		else
+			bootz 0x10800000 - ${fdt_addr}
+		fi
+	fi
+else
+	if ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 /vmlinuz ; then
+		if itest.s x$havedtb == x ; then
+			bootz 0x10800000 ${initrd_addr}:${initrd_size} ;
+		else
+			bootz 0x10800000 ${initrd_addr}:${initrd_size} ${fdt_addr} ;
+		fi
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.53.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.53.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.53.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.10.53.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,235 @@
+setenv bootargs ''
+
+if ${fs}load ${dtype} ${disk}:1 10800000 uEnv.txt ; then
+    env import -t 10800000 $filesize
+fi
+
+if itest.s "x" == "x$dtbname" ; then
+	dtbname="imx6";
+	if itest.s x6SOLO == "x$cpu" ; then
+		dtbname=${dtbname}dl-;
+	elif itest.s x6DL == "x$cpu" ; then
+		dtbname=${dtbname}dl-;
+	else
+		dtbname=${dtbname}q-;
+	fi
+	if itest.s x == "x$board" ; then
+		board=sabrelite
+	fi
+	dtbname=${dtbname}${board}.dtb;
+fi
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+setenv fdt_addr 0x12000000
+if ${fs}load ${dtype} ${disk}:${bootpart} $fdt_addr ${bootdir}$dtbname ; then
+	fdt addr $fdt_addr
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}$dtbname";
+	exit;
+fi
+
+# ------------------- HDMI detection
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	echo "------ have HDMI monitor";
+	if itest.s x == x$allow_noncea ; then
+		setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+else
+	fdt rm hdmi_display
+	echo "------ no HDMI monitor";
+fi
+
+# ------------------- LVDS detection
+if itest.s "x" != "x$lvds_1080p" ; then
+	echo "----- 1080P dual channel LVDS";
+	fdt rm okaya1024x600
+	fdt rm lg1280x800
+	fdt rm hannstar;
+	fdt set ldb split-mode 1
+	fdt set lvds_display interface_pix_fmt "RGB24"
+	fdt set ldb/lvds-channel@0 fsl,data-width <24>
+else
+	fdt rm ldb split-mode
+	fdt rm lvds1080p
+
+	# -------- LVDS0 (bottom on Nitrogen6_Max)
+	setenv have_lvds
+	i2c dev 2
+	if i2c probe 0x04 ; then
+		echo "------ have Freescale display";
+		setenv have_lvds 1
+	else
+		echo "------ no Freescale display";
+		fdt rm hannstar;
+	fi
+
+	if i2c probe 0x38 ; then
+		if itest.s "xLDB-WXGA" == "x$panel"; then
+			screenres=1280,800
+			fdt rm okaya1024x600
+		else
+			screenres=1024,600
+			fdt rm lg1280x800
+		fi
+		setenv have_lvds 1
+		setenv bootargs $bootargs ft5x06_ts.screenres=$screenres
+		if itest.s "x" -ne "x$calibration" ; then
+			setenv bootargs $bootargs ft5x06_ts.calibration=$calibration
+		fi
+	else
+		echo "------ no ft5x06 touch controller";
+		fdt rm okaya1024x600
+		fdt rm lg1280x800
+	fi
+
+	if itest.s "x" == "x$have_lvds"; then
+		fdt rm lvds_display;
+	fi
+
+	# -------- LVDS1 (top on Nitrogen6_Max)
+	if itest.s "xhannstar" == "x$lvds1_panel" ; then
+		echo "configure LVDS1 for Hannstar panel"
+		fdt rm okaya1024x600_2;
+		fdt rm lg1280x800_2;
+		fdt set lvds_display_2 status okay
+	elif itest.s "xokaya1024x600" == "x$lvds1_panel" ; then
+		echo "configure LVDS1 for 1024x600 panel"
+		fdt rm hannstar_2;
+		fdt rm lg1280x800_2;
+		fdt set lvds_display_2 status okay
+	elif itest.s "xlg1280x800" == "x$lvds1_panel" ; then
+		echo "configure LVDS1 for 1280x800 panel"
+		fdt rm hannstar_2;
+		fdt rm okaya1024x600_2;
+		fdt set lvds_display_2 status okay
+	else
+		fdt rm lvds_display_2 ; # ignore errors on boards != 6_max
+	fi
+fi
+
+# ------------------- LCD detection
+setenv have_lcd '';
+if i2c probe 0x48 ; then
+	setenv have_lcd 1;
+	echo "------- found TSC2004 touch controller";
+	if itest.s "x" -eq "x$tsc_calibration" ; then
+		setenv bootargs $bootargs tsc2004.calibration=-67247,-764,272499173,324,69283,-8653010,65536
+	else
+		setenv bootargs $bootargs tsc2004.calibration=$tsc_calibration
+	fi
+elif i2c probe 0x4d ; then
+	setenv have_lcd 1;
+	echo "------- found AR1020 touch controller";
+fi
+
+if itest.s "x" != "x$ignore_lcd" ; then
+	echo "------ ignoring LCD display";
+	setenv have_lcd '';
+fi
+
+if itest.s "x" != "x$have_lcd" ; then
+	echo "----- found LCD display";
+else
+	fdt rm lcd_display;
+fi
+
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait fixrtc"
+
+setenv bpart "$bootpart"
+
+if   itest.s "$bpart" == a ; then
+	setenv bpart 10
+elif itest.s "$bpart" == b ; then
+	setenv bpart 11
+elif itest.s "$bpart" == c ; then
+	setenv bpart 12
+elif itest.s "$bpart" == d ; then
+	setenv bpart 13
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bpart" ;
+else
+	if test "usb" = "${dtype}" ; then
+		setenv bootargs "$bootargs root=/dev/sda$bpart" ;
+	elif itest 0 -eq ${disk}; then
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-2198000.usdhc-part1" ;
+	else
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-219c000.usdhc-part1" ;
+	fi
+fi
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs $bootargs fec.disable_giga=1
+fi
+
+if itest.s "x" != "x$wlmac" ; then
+	setenv bootargs $bootargs wlcore.mac=$wlmac
+fi
+
+if itest.s "x" != "x$gpumem" ; then
+	setenv bootargs $bootargs galcore.contiguousSize=$gpumem
+fi
+
+if itest.s "no" != "$dosplash" ; then
+	setenv bootargs $bootargs splash quiet plymouth.ignore-serial-consoles
+fi
+
+if itest.s "x" != "x$overlayfs" ; then
+	setenv bootargs $bootargs overlayfs=${overlayfs}
+	if itest.s "x" != "x${ofs-size}" ; then
+		setenv bootargs $bootargs ofs-size=${ofs-size}
+	fi
+fi
+
+if itest.s "x" != "x$show_fdt" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x$show_env" ; then
+	printenv
+fi
+
+if kbd ; then
+        if itest.s "xv" == "x$keybd" ; then
+                ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 ${bootdir}/uImage-recovery &&
+                ${fs}load ${dtype} ${disk}:${bootpart} 0x12800000 ${bootdir}/uramdisk-recovery.img &&
+                bootm 10800000 12800000;
+                echo "--- error launching recovery!"
+                exit;
+        fi
+fi
+
+setenv initrd_high 0xffffffff
+setenv initrd_addr 0x12a00000
+echo "----------- trying to load /initrd.img";
+if ${fs}load ${dtype} ${disk}:${bootpart} ${initrd_addr} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+if itest.s x$haverd == x ; then
+	if ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 /vmlinuz ; then
+		bootz 0x10800000 - ${fdt_addr}
+	fi
+else
+	if ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 /vmlinuz ; then
+		bootz 0x10800000 ${initrd_addr}:${initrd_size} ${fdt_addr} ;
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.14.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.14.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.14.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-ubuntu-3.14.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,212 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+m4=''
+a_base=0x10000000
+if itest.s x51 == "x${cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${cpu}" || itest.s x7D == "x${cpu}"; then
+	a_base=0x80000000
+	if itest.s "x1" == "x$m4enabled" ; then
+		run m4boot;
+		m4='-m4';
+	fi
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${dtbname}" ; then
+	if itest.s x6SOLO == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${cpu}" ; then
+		dtbname=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${cpu}" ; then
+		dtbname=imx6sx-${board}${m4}.dtb;
+	elif itest.s x7D == "x${cpu}" ; then
+		dtbname=imx7d-${board}${m4}.dtb;
+	elif itest.s x51 == "x${cpu}" ; then
+		dtbname=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${cpu}" ; then
+		dtbname=imx53-${board}${m4}.dtb;
+	else
+		dtbname=imx6q-${board}.dtb;
+	fi
+fi
+
+if itest.s x${bootpart} == x ; then
+	bootpart=1
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+setenv bootargs ${bootargs} console=${console},115200 vmalloc=400M consoleblank=0 rootwait fixrtc cpu=${cpu} board=${board}
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_fdt} ${bootdir}${dtbname} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}${dtbname}";
+	exit;
+fi
+
+cmd_xxx_present=
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" != "x${cmd_hdmi}" ; then
+	run cmd_hdmi
+	cmd_xxx_present=1;
+	if itest.s x == x${allow_noncea} ; then
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+fi
+
+if itest.s "x" != "x${cmd_lcd}" ; then
+	run cmd_lcd
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lcd2}" ; then
+	run cmd_lcd2
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds}" ; then
+	run cmd_lvds
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds2}" ; then
+	run cmd_lvds2
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" == "x${cmd_xxx_present}" ; then
+	echo "!!!!!!!!!!!!!!!!"
+	echo "warning: your u-boot may be outdated, please upgrade"
+	echo "!!!!!!!!!!!!!!!!"
+fi
+
+setexpr b0 ${bootpart} % 0x0a;
+setexpr b1 ${bootpart} / 0x0a;
+#this is to show a decimal number when really hex is output
+setexpr bpart ${b1} * 0x10
+setexpr bpart ${bpart} + ${b0};
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+elif test "usb" = "${dtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+else
+	setenv bootargs "${bootargs} root=/dev/mmcblk${disk}p${bpart}"
+fi
+
+if itest.s "x" != "x${disable_msi}" ; then
+	setenv bootargs ${bootargs} pci=nomsi
+fi;
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs ${bootargs} fec.disable_giga=1
+fi
+
+if itest.s "x" != "x${wlmac}" ; then
+	setenv bootargs ${bootargs} wlan.mac=${wlmac} wlcore.mac=${wlmac}
+fi
+
+if itest.s "x" != "x${bd_addr}" ; then
+	setenv bootargs ${bootargs} bd_addr=${bd_addr}
+fi
+
+if itest.s "x" != "x${gpumem}" ; then
+	setenv bootargs ${bootargs} galcore.contiguousSize=${gpumem}
+fi
+
+
+if itest.s "no" != "${dosplash}" ; then
+	if itest.s "x" == "x${loglevel}" ; then
+		loglevel=4
+	fi
+	setenv bootargs ${bootargs} splash plymouth.ignore-serial-consoles
+fi
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+
+if itest.s "x" != "x${overlayfs}" ; then
+	setenv bootargs ${bootargs} overlayfs=${overlayfs}
+	if itest.s "x" != "x${ofs-size}" ; then
+		setenv bootargs ${bootargs} ofs-size=${ofs-size}
+	fi
+fi
+
+if itest.s "x" != "x${cma}" ; then
+	setenv bootargs ${bootargs} cma=${cma}
+fi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if kbd ; then
+        if itest.s "xv" == "x${keybd}" ; then
+                load ${dtype} ${disk}:${bootpart} ${a_zImage} ${bootdir}/uImage-recovery &&
+                load ${dtype} ${disk}:${bootpart} ${a_ramdisk} ${bootdir}/uramdisk-recovery.img &&
+                bootm ${a_zImage} ${a_ramdisk};
+                echo "--- error launching recovery!"
+                exit;
+        fi
+fi
+
+echo "----------- trying to load /initrd.img";
+if load ${dtype} ${disk}:${bootpart} ${a_initrd} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+else
+	haverd=
+fi
+
+if itest.s x${haverd} == x ; then
+	if load ${dtype} ${disk}:${bootpart} ${a_zImage} /vmlinuz ; then
+		setenv bootargs ${bootargs} rw
+		bootz ${a_zImage} - ${a_fdt}
+	fi
+else
+	if load ${dtype} ${disk}:${bootpart} ${a_zImage} /vmlinuz ; then
+		bootz ${a_zImage} ${a_initrd}:${initrd_size} ${a_fdt} ;
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-yocto-3.14.txt u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-yocto-3.14.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_bootscript-yocto-3.14.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_bootscript-yocto-3.14.txt	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,168 @@
+setenv bootargs ''
+
+setenv initrd_high 0xffffffff
+m4=''
+a_base=0x10000000
+if itest.s x51 == "x${cpu}" ; then
+	a_base=0x90000000
+elif itest.s x53 == "x${cpu}"; then
+	a_base=0x70000000
+elif itest.s x6SX == "x${cpu}" || itest.s x7D == "x${cpu}"; then
+	a_base=0x80000000
+	if itest.s "x1" == "x$m4enabled" ; then
+		run m4boot;
+		m4='-m4';
+	fi
+fi
+
+setexpr a_script  ${a_base} + 0x00800000
+setexpr a_zImage  ${a_base} + 0x00800000
+setexpr a_fdt     ${a_base} + 0x03000000
+setexpr a_ramdisk ${a_base} + 0x03800000
+setexpr a_initrd  ${a_base} + 0x03a00000
+setexpr a_reset_cause_marker ${a_base} + 0x80
+setexpr a_reset_cause	     ${a_base} + 0x84
+
+if itest.s "x" == "x${board}" ; then
+	echo "!!!! Error: Your u-boot is outdated. Please upgrade.";
+	exit;
+fi
+
+if itest.s "x" == "x${dtbname}" ; then
+	if itest.s x6SOLO == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6DL == "x${cpu}" ; then
+		dtbname=imx6dl-${board}.dtb;
+	elif itest.s x6QP == "x${cpu}" ; then
+		dtbname=imx6qp-${board}.dtb;
+	elif itest.s x6SX == "x${cpu}" ; then
+		dtbname=imx6sx-${board}${m4}.dtb;
+	elif itest.s x7D == "x${cpu}" ; then
+		dtbname=imx7d-${board}${m4}.dtb;
+	elif itest.s x51 == "x${cpu}" ; then
+		dtbname=imx51-${board}${m4}.dtb;
+	elif itest.s x53 == "x${cpu}" ; then
+		dtbname=imx53-${board}${m4}.dtb;
+	else
+		dtbname=imx6q-${board}.dtb;
+	fi
+fi
+
+if itest.s x${bootpart} == x ; then
+	bootpart=1
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_script} uEnv.txt ; then
+    env import -t ${a_script} ${filesize}
+fi
+setenv bootargs ${bootargs} console=${console},115200 vmalloc=400M consoleblank=0 rootwait fixrtc cpu=${cpu} board=${board}
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_fdt} ${bootdir}${dtbname} ; then
+	fdt addr ${a_fdt}
+	setenv fdt_high 0xffffffff
+else
+	echo "!!!! Error loading ${bootdir}${dtbname}";
+	exit;
+fi
+
+cmd_xxx_present=
+fdt resize
+if itest.s "x" != "x${cmd_custom}" ; then
+	run cmd_custom
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" != "x${cmd_hdmi}" ; then
+	run cmd_hdmi
+	cmd_xxx_present=1;
+	if itest.s x == x${allow_noncea} ; then
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=1;
+		echo "only CEA modes allowed on HDMI port";
+	else
+		setenv bootargs ${bootargs} mxc_hdmi.only_cea=0;
+		echo "non-CEA modes allowed on HDMI, audio may be affected";
+	fi
+fi
+
+if itest.s "x" != "x${cmd_lcd}" ; then
+	run cmd_lcd
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lcd2}" ; then
+	run cmd_lcd2
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds}" ; then
+	run cmd_lvds
+	cmd_xxx_present=1;
+fi
+if itest.s "x" != "x${cmd_lvds2}" ; then
+	run cmd_lvds2
+	cmd_xxx_present=1;
+fi
+
+if itest.s "x" == "x${cmd_xxx_present}" ; then
+	echo "!!!!!!!!!!!!!!!!"
+	echo "warning: your u-boot may be outdated, please upgrade"
+	echo "!!!!!!!!!!!!!!!!"
+fi
+
+bpart=2
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+elif test "usb" = "${dtype}" ; then
+	setenv bootargs "${bootargs} root=/dev/sda${bpart}" ;
+else
+	setenv bootargs "${bootargs} root=/dev/mmcblk${disk}p${bpart}"
+fi
+
+if itest.s "x" != "x${disable_msi}" ; then
+	setenv bootargs ${bootargs} pci=nomsi
+fi;
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs ${bootargs} fec.disable_giga=1
+fi
+
+if itest.s "x" != "x${wlmac}" ; then
+	setenv bootargs ${bootargs} wlan.mac=${wlmac} wlcore.mac=${wlmac}
+fi
+
+if itest.s "x" != "x${bd_addr}" ; then
+	setenv bootargs ${bootargs} bd_addr=${bd_addr}
+fi
+
+if itest.s "x" != "x${gpumem}" ; then
+	setenv bootargs ${bootargs} galcore.contiguousSize=${gpumem}
+fi
+
+if itest.s "x" != "x${cma}" ; then
+	setenv bootargs ${bootargs} cma=${cma}
+fi
+
+if itest.s "x" != "x${loglevel}" ; then
+	setenv bootargs ${bootargs} loglevel=${loglevel}
+fi
+
+if itest *${a_reset_cause_marker} == 12345678 ; then
+	setexpr.l reset_cause *${a_reset_cause}
+	setenv bootargs $bootargs reset_cause=0x${reset_cause}
+fi
+
+if itest.s "x" != "x${show_fdt}" ; then
+	fdt print /
+fi
+
+if itest.s "x" != "x${show_env}" ; then
+	printenv
+fi
+
+if load ${dtype} ${disk}:${bootpart} ${a_zImage} /zImage ; then
+	bootz ${a_zImage} - ${a_fdt}
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/6x_upgrade.txt u-boot-imx6/board/boundary/nitrogen6x/6x_upgrade.txt
--- u-boot-2017.07/board/boundary/nitrogen6x/6x_upgrade.txt	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/6x_upgrade.txt	2018-08-27 21:35:36.950804999 +0300
@@ -1,45 +1,154 @@
+if itest.s a$uboot_defconfig == a; then
+        echo "Please set uboot_defconfig to the appropriate value"
+        exit
+fi
+
+offset=0x400
+erase_size=0xC0000
+qspi_offset=0x0
+a_base=0x12000000
+
+if itest.s x51 == "x${cpu}"; then
+	a_base=0x92000000
+elif itest.s x53 == "x${cpu}"; then
+	a_base=0x72000000
+elif itest.s x6SX == "x${cpu}" || itest.s x7D == "x${cpu}"; then
+	a_base=0x82000000
+fi
+
+qspi_match=1
+setexpr a_qspi1 ${a_base}
+setexpr a_qspi2 ${a_qspi1} + 0x400000
+setexpr a_uImage1 ${a_qspi1} + 0x400
+setexpr a_uImage2 ${a_qspi2} + 0x400
+setexpr a_script ${a_base}
+
 setenv stdout serial,vga
+
+if sf probe || sf probe || sf probe 1 27000000 || sf probe 1 27000000 ; then
+	echo "probed SPI ROM" ;
+else
+	echo "Error initializing EEPROM"
+	exit
+fi
+
+if itest.s x7D == "x${cpu}"; then
+	echo "check qspi parameter block" ;
+	if ${fs}load ${dtype} ${disk}:1 ${a_qspi1} qspi-${sfname}.${uboot_defconfig} ; then
+	else
+		echo "parameter file qspi-${sfname}.${uboot_defconfig} not found on SD card"
+		exit
+	fi
+	if itest ${filesize} != 0x200 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} 0x${filesize} != 0x200 bytes" ;
+		exit
+	fi
+	setexpr a_marker ${a_qspi1} + 0x1fc
+	if itest *${a_marker} != c0ffee01 ; then
+		echo "------- qspi-${sfname}.${uboot_defconfig} c0ffee01 marker missing" ;
+		exit
+	fi
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error reading qspi parameter from EEPROM"
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+		echo "------- qspi parameters match"
+	else
+		echo "------- qspi parameters mismatch"
+		qspi_match=0
+	fi
+fi
+
 echo "check U-Boot" ;
-setenv offset 0x400
-if ${fs}load ${dtype} ${disk}:1 12000000 u-boot.imx || ${fs}load ${dtype} ${disk}:1 12000000 u-boot.nopadding ; then
-      echo "read $filesize bytes from SD card" ;
-      if sf probe || sf probe || \
-	 sf probe 1 27000000 || sf probe 1 27000000 ; then
-	   echo "probed SPI ROM" ;
-	   if sf read 0x12400000 $offset $filesize ; then
-	       if cmp.b 0x12000000 0x12400000 $filesize ; then
-		   echo "------- U-Boot versions match" ;
-	       else
-		   echo "Need U-Boot upgrade" ;
-		   echo "Program in 5 seconds" ;
-		   for n in 5 4 3 2 1 ; do
-			echo $n ;
-			sleep 1 ;
-		   done
-		   echo "erasing" ;
-		   sf erase 0 0xC0000 ;
-		   # two steps to prevent bricking
-		   echo "programming" ;
-		   sf write 0x12000000 $offset $filesize ;
-		   echo "verifying" ;
-		   if sf read 0x12400000 $offset $filesize ; then
-		       if cmp.b 0x12000000 0x12400000 $filesize ; then
-			   while echo "---- U-Boot upgraded. reset" ; do
-				sleep 120
-			   done
-		       else
-			   echo "Read verification error" ;
-		       fi
-		   else
-			echo "Error re-reading EEPROM" ;
-		   fi
-	       fi
-	   else
-	       echo "Error reading boot loader from EEPROM" ;
-	   fi
-      else
-	   echo "Error initializing EEPROM" ;
-      fi ;
+
+if ${fs}load ${dtype} ${disk}:1 ${a_uImage1} u-boot.$uboot_defconfig ; then
+else
+	echo "File u-boot.$uboot_defconfig not found on SD card" ;
+	exit
+fi
+echo "read $filesize bytes from SD card" ;
+if sf read ${a_uImage2} $offset $filesize ; then
 else
-     echo "No U-Boot image found on SD card" ;
+	echo "Error reading boot loader from EEPROM" ;
+	exit
+fi
+
+if cmp.b ${a_uImage1} ${a_uImage2} $filesize ; then
+	echo "------- U-Boot versions match" ;
+	if itest.s "${qspi_match}" == "1" ; then
+		echo "------- upgrade not needed" ;
+		if itest.s "x" != "x${next}" ; then
+			if ${fs}load ${dtype} ${disk}:1 ${a_script} ${next} ; then
+				source ${a_script}
+			else
+				echo "${next} not found on SD card"
+			fi
+		fi
+		exit
+	fi
+	erase_size=0x1000
+	if itest.s xMX25L6405D == "x${sfname}"; then
+		erase_size=0x10000
+	fi
+	setexpr filesize ${erase_size} - ${offset}
+fi
+
+echo "Need U-Boot upgrade" ;
+echo "Program in 5 seconds" ;
+for n in 5 4 3 2 1 ; do
+	echo $n ;
+	sleep 1 ;
+done
+echo "erasing" ;
+sf erase 0 ${erase_size} ;
+
+# two steps to prevent bricking
+echo "programming" ;
+setexpr a1 ${a_uImage1} + 0x400
+setexpr o1 ${offset} + 0x400
+setexpr s1 ${filesize} - 0x400
+sf write ${a1} ${o1} ${s1} ;
+sf write ${a_uImage1} $offset 0x400 ;
+
+if itest.s x7D == "x${cpu}"; then
+	sf write ${a_qspi1} ${qspi_offset} 0x200
+fi
+
+echo "verifying" ;
+if sf read ${a_uImage2} $offset $filesize ; then
+else
+	echo "Error re-reading EEPROM" ;
+	exit
+fi
+if cmp.b ${a_uImage1} ${a_uImage2} $filesize ; then
+else
+	echo "Read verification error" ;
+	exit
+fi
+
+if itest.s x7D == "x${cpu}"; then
+	if sf read ${a_qspi2} ${qspi_offset} 0x200 ; then
+	else
+		echo "Error re-reading qspi" ;
+		exit
+	fi
+	if cmp.b ${a_qspi1} ${a_qspi2} 0x200 ; then
+	else
+		echo "qspi parameter block verification error" ;
+		exit
+	fi
+fi
+
+if itest.s "x" != "x${next}" ; then
+	if ${fs}load ${dtype} ${disk}:1 ${a_script} ${next} ; then
+		source ${a_script}
+	else
+		echo "${next} not found on ${dtype} ${disk}"
+	fi
 fi
+
+while echo "---- U-Boot upgraded. reset" ; do
+	sleep 120
+done
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/800mhz_2x128mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/800mhz_2x128mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/800mhz_2x128mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/800mhz_2x128mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000017
-DATA 4, MX6_MMDC_P0_MDCTL, 0x83190000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/800mhz_2x256mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/800mhz_2x256mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/800mhz_2x256mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/800mhz_2x256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
-DATA 4, MX6_MMDC_P0_MDCTL, 0x84190000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/800mhz_4x128mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/800mhz_4x128mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/800mhz_4x128mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/800mhz_4x128mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
-DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x420F020F
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x01760175
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x41640171
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x015E0160
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45464B4A
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x49484A46
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40402E32
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3A3A3231
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x003A003A
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0030002F
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x002F0038
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00270039
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/800mhz_4x256mx16.cfg u-boot-imx6/board/boundary/nitrogen6x/800mhz_4x256mx16.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/800mhz_4x256mx16.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/800mhz_4x256mx16.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
-DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
-DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
-DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
-DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
-DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
-DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
-DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
-DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
-DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
-DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
-DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
-DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
-DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
-DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
-DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
-DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
-DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
-DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
-DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
-DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
-DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
-DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/clocks.cfg u-boot-imx6/board/boundary/nitrogen6x/clocks.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/clocks.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/clocks.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *      Addr-type register length (1,2 or 4 bytes)
- *      Address   absolute address of the register
- *      value     value to be stored in the register
- */
-
-/* set the default clock gate to save power */
-DATA 4, CCM_CCGR0, 0x00C03F3F
-DATA 4, CCM_CCGR1, 0x0030FC03
-DATA 4, CCM_CCGR2, 0x0FFFC000
-DATA 4, CCM_CCGR3, 0x3FF00000
-DATA 4, CCM_CCGR4, 0x00FFF300
-DATA 4, CCM_CCGR5, 0x0F0000C3
-DATA 4, CCM_CCGR6, 0x000003FF
-
-/* enable AXI cache for VDOA/VPU/IPU */
-DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
-/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
-DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
-DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
-
-/*
- * Setup CCM_CCOSR register as follows:
- *
- * cko1_en  = 1	   --> CKO1 enabled
- * cko1_div = 111  --> divide by 8
- * cko1_sel = 1011 --> ahb_clk_root
- *
- * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
- */
-DATA 4, CCM_CCOSR, 0x000000fb
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/ddr-setup.cfg u-boot-imx6/board/boundary/nitrogen6x/ddr-setup.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/ddr-setup.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/ddr-setup.cfg	1970-01-01 03:00:00.000000000 +0300
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2013 Boundary Devices
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *      Addr-type register length (1,2 or 4 bytes)
- *      Address   absolute address of the register
- *      value     value to be stored in the register
- */
-
-/*
- * DDR3 settings
- * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
- *	   memory bus width: 64 bits	x16/x32/x64
- * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
- *	   memory bus width: 64 bits	x16/x32/x64
- * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
- *	   memory bus width: 32 bits	x16/x32
- */
-DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
-DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
-
-DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
-DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
-DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
-/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
-DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
-
-DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
-DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
-
-DATA 4, MX6_IOM_DRAM_CAS, 0x00020030
-DATA 4, MX6_IOM_DRAM_RAS, 0x00020030
-DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
-DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
-
-DATA 4, MX6_IOM_DRAM_RESET, 0x00020030
-DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
-DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
-
-DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
-DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
-
-/* (differential input) */
-DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
-/* (differential input) */
-DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
-/* disable ddr pullups */
-DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
-DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
-/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
-DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
-
-/* Read data DQ Byte0-3 delay */
-DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
-DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
-DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
-DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
-DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
-DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
-DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
-DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
-
-/*
- * MDMISC	mirroring	interleaved (row/bank/col)
- */
-DATA 4, MX6_MMDC_P0_MDMISC, 0x00081740
-
-/*
- * MDSCR	con_req
- */
-DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/Kconfig u-boot-imx6/board/boundary/nitrogen6x/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen6x/Kconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -9,4 +9,10 @@
 config SYS_CONFIG_NAME
 	default "nitrogen6x"
 
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
 endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/Makefile u-boot-imx6/board/boundary/nitrogen6x/Makefile
--- u-boot-2017.07/board/boundary/nitrogen6x/Makefile	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -7,3 +7,4 @@
 #
 
 obj-y  := nitrogen6x.o
+obj-$(CONFIG_MXC_SPI_DISPLAY) += spi_display.o
\      
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6dl2g.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6dl2g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6dl2g.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6dl2g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,24 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "800mhz_4x256mx16.cfg"
-#include "clocks.cfg"
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021a0218
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x021a0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4b4b4e49
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x4b4b4e49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3f3f3035
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3f3f3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003c
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003e
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x0040003c
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x0032003e
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6dl.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6dl.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6dl.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6dl.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,25 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "800mhz_4x128mx16.cfg"
-#include "clocks.cfg"
+/* unknow sample size */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x420F020F
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x01760175
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x41640171
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x015E0160
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45464B4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x49484A46
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40402E32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3A3A3231
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x003A003A
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0030002F
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x002F0038
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00270039
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6q2g.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6q2g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6q2g.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6q2g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,24 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "1066mhz_4x256mx16.cfg"
-#include "clocks.cfg"
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+/* D2516EC4BXGGBI-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6q.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6q.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6q.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6q.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,25 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "1066mhz_4x128mx16.cfg"
-#include "clocks.cfg"
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6s1g.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6s1g.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6s1g.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6s1g.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,18 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "800mhz_2x256mx16.cfg"
-#include "clocks.cfg"
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6s.cfg u-boot-imx6/board/boundary/nitrogen6x/nitrogen6s.cfg
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6s.cfg	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6s.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -27,6 +27,19 @@
 #include "asm/arch/iomux.h"
 #include "asm/arch/crm_regs.h"
 
-#include "ddr-setup.cfg"
-#include "800mhz_2x128mx16.cfg"
-#include "clocks.cfg"
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6x.c u-boot-imx6/board/boundary/nitrogen6x/nitrogen6x.c
--- u-boot-2017.07/board/boundary/nitrogen6x/nitrogen6x.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/nitrogen6x.c	2018-08-27 21:35:36.950804999 +0300
@@ -15,261 +15,283 @@
 #include <asm/arch/mx6-pins.h>
 #include <linux/errno.h>
 #include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
 #include <asm/imx-common/iomux-v3.h>
 #include <asm/imx-common/mxc_i2c.h>
 #include <asm/imx-common/sata.h>
 #include <asm/imx-common/spi.h>
-#include <asm/imx-common/boot_mode.h>
-#include <asm/imx-common/video.h>
 #include <mmc.h>
 #include <fsl_esdhc.h>
-#include <micrel.h>
-#include <miiphy.h>
-#include <netdev.h>
+#include <splash.h>
 #include <asm/arch/crm_regs.h>
 #include <asm/arch/mxc_hdmi.h>
 #include <i2c.h>
 #include <input.h>
-#include <netdev.h>
 #include <usb/ehci-ci.h>
+#include "spi_display.h"
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
 
 DECLARE_GLOBAL_DATA_PTR;
-#define GP_USB_OTG_PWR	IMX_GPIO_NR(3, 22)
-
-#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
-	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
-	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
-	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
-	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
-
-#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
-	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
-
-#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
-	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
 
-#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
 #define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
 	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
 
-#define WEAK_PULLUP	(PAD_CTL_PUS_100K_UP |			\
-	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
-	PAD_CTL_SRE_SLOW)
-
-#define WEAK_PULLDOWN	(PAD_CTL_PUS_100K_DOWN |		\
-	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
-	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
-
-#define OUTPUT_40OHM (PAD_CTL_SPEED_MED|PAD_CTL_DSE_40ohm)
-
-int dram_init(void)
-{
-	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
-
-	return 0;
-}
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
 
-static iomux_v3_cfg_t const uart1_pads[] = {
-	MX6_PAD_SD3_DAT6__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX6_PAD_SD3_DAT7__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const uart2_pads[] = {
-	MX6_PAD_EIM_D26__UART2_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
-	MX6_PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
-};
-
-#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
-
-/* I2C1, SGTL5000 */
-static struct i2c_pads_info i2c_pad_info0 = {
-	.scl = {
-		.i2c_mode = MX6_PAD_EIM_D21__I2C1_SCL | PC,
-		.gpio_mode = MX6_PAD_EIM_D21__GPIO3_IO21 | PC,
-		.gp = IMX_GPIO_NR(3, 21)
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_EIM_D28__I2C1_SDA | PC,
-		.gpio_mode = MX6_PAD_EIM_D28__GPIO3_IO28 | PC,
-		.gp = IMX_GPIO_NR(3, 28)
-	}
-};
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
 
-/* I2C2 Camera, MIPI */
-static struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | PC,
-		.gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | PC,
-		.gp = IMX_GPIO_NR(4, 12)
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
-		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
-		.gp = IMX_GPIO_NR(4, 13)
-	}
-};
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
 
-/* I2C3, J15 - RGB connector */
-static struct i2c_pads_info i2c_pad_info2 = {
-	.scl = {
-		.i2c_mode = MX6_PAD_GPIO_5__I2C3_SCL | PC,
-		.gpio_mode = MX6_PAD_GPIO_5__GPIO1_IO05 | PC,
-		.gp = IMX_GPIO_NR(1, 5)
-	},
-	.sda = {
-		.i2c_mode = MX6_PAD_GPIO_16__I2C3_SDA | PC,
-		.gpio_mode = MX6_PAD_GPIO_16__GPIO7_IO11 | PC,
-		.gp = IMX_GPIO_NR(7, 11)
-	}
-};
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
 
-static iomux_v3_cfg_t const usdhc2_pads[] = {
-	MX6_PAD_SD2_CLK__SD2_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD2_CMD__SD2_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD2_DAT0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD2_DAT1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD2_DAT2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD2_DAT3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const usdhc3_pads[] = {
-	MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD3_DAT5__GPIO7_IO00    | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
-};
-
-static iomux_v3_cfg_t const usdhc4_pads[] = {
-	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
-	MX6_PAD_NANDF_D6__GPIO2_IO06    | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
-};
-
-static iomux_v3_cfg_t const enet_pads1[] = {
-	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	/* pin 35 - 1 (PHY_AD2) on reset */
-	MX6_PAD_RGMII_RXC__GPIO6_IO30		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* pin 32 - 1 - (MODE0) all */
-	MX6_PAD_RGMII_RD0__GPIO6_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* pin 31 - 1 - (MODE1) all */
-	MX6_PAD_RGMII_RD1__GPIO6_IO27		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* pin 28 - 1 - (MODE2) all */
-	MX6_PAD_RGMII_RD2__GPIO6_IO28		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* pin 27 - 1 - (MODE3) all */
-	MX6_PAD_RGMII_RD3__GPIO6_IO29		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	/* pin 33 - 1 - (CLK125_EN) 125Mhz clockout enabled */
-	MX6_PAD_RGMII_RX_CTL__GPIO6_IO24	| MUX_PAD_CTRL(NO_PAD_CTRL),
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),	/* for spi displays */
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
 	/* pin 42 PHY nRST */
-	MX6_PAD_EIM_D23__GPIO3_IO23		| MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_ENET_RXD0__GPIO1_IO27		| MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const enet_pads2[] = {
-	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
-};
-
-static iomux_v3_cfg_t const misc_pads[] = {
-	MX6_PAD_GPIO_1__USB_OTG_ID		| MUX_PAD_CTRL(WEAK_PULLUP),
-	MX6_PAD_KEY_COL4__USB_OTG_OC		| MUX_PAD_CTRL(WEAK_PULLUP),
-	MX6_PAD_EIM_D30__USB_H1_OC		| MUX_PAD_CTRL(WEAK_PULLUP),
-	/* OTG Power enable */
-	MX6_PAD_EIM_D22__GPIO3_IO22		| MUX_PAD_CTRL(OUTPUT_40OHM),
-};
-
-/* wl1271 pads on nitrogen6x */
-static iomux_v3_cfg_t const wl12xx_pads[] = {
-	(MX6_PAD_NANDF_CS1__GPIO6_IO14 & ~MUX_PAD_CTRL_MASK)
-		| MUX_PAD_CTRL(WEAK_PULLDOWN),
-	(MX6_PAD_NANDF_CS2__GPIO6_IO15 & ~MUX_PAD_CTRL_MASK)
-		| MUX_PAD_CTRL(OUTPUT_40OHM),
-	(MX6_PAD_NANDF_CS3__GPIO6_IO16 & ~MUX_PAD_CTRL_MASK)
-		| MUX_PAD_CTRL(OUTPUT_40OHM),
-};
-#define WL12XX_WL_IRQ_GP	IMX_GPIO_NR(6, 14)
-#define WL12XX_WL_ENABLE_GP	IMX_GPIO_NR(6, 15)
-#define WL12XX_BT_ENABLE_GP	IMX_GPIO_NR(6, 16)
-
-/* Button assignments for J14 */
-static iomux_v3_cfg_t const button_pads[] = {
-	/* Menu */
-	MX6_PAD_NANDF_D1__GPIO2_IO01	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
-	/* Back */
-	MX6_PAD_NANDF_D2__GPIO2_IO02	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
-	/* Labelled Search (mapped to Power under Android) */
-	MX6_PAD_NANDF_D3__GPIO2_IO03	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
-	/* Home */
-	MX6_PAD_NANDF_D4__GPIO2_IO04	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
-	/* Volume Down */
-	MX6_PAD_GPIO_19__GPIO4_IO05	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
-	/* Volume Up */
-	MX6_PAD_GPIO_18__GPIO7_IO13	| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
+	/* Sabrelite has different reset pin*/
+#define GP_RGMII2_PHY_RESET	IMX_GPIO_NR(3, 23)
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* i2c1_isl1208 */
+#define GPIRQ_RTC_ISL1208	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+	/* Needed if inappropriately used with SOM2 carrier board */
+#define GP_SGTL5000_HP_MUTE	IMX_GPIO_NR(3, 29)		/* Low is muted */
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+
+	/* i2c2 ov5640 mipi Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+
+	/* i2c2 TC358743 interrupt */
+#define GPIRQ_TC3587		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* i2c2 ov5642 Camera controls, J5 */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO_6__GPIO1_IO06, WEAK_PULLUP),
+#define GP_OV5642_RESET		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb666_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb24_pads[] = {
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
 };
-
-static void setup_iomux_enet(void)
-{
-	gpio_direction_output(IMX_GPIO_NR(3, 23), 0); /* SABRE Lite PHY rst */
-	gpio_direction_output(IMX_GPIO_NR(1, 27), 0); /* Nitrogen6X PHY rst */
-	gpio_direction_output(IMX_GPIO_NR(6, 30), 1);
-	gpio_direction_output(IMX_GPIO_NR(6, 25), 1);
-	gpio_direction_output(IMX_GPIO_NR(6, 27), 1);
-	gpio_direction_output(IMX_GPIO_NR(6, 28), 1);
-	gpio_direction_output(IMX_GPIO_NR(6, 29), 1);
-	imx_iomux_v3_setup_multiple_pads(enet_pads1, ARRAY_SIZE(enet_pads1));
-	gpio_direction_output(IMX_GPIO_NR(6, 24), 1);
-
-	/* Need delay 10ms according to KSZ9021 spec */
-	udelay(1000 * 10);
-	gpio_set_value(IMX_GPIO_NR(3, 23), 1); /* SABRE Lite PHY reset */
-	gpio_set_value(IMX_GPIO_NR(1, 27), 1); /* Nitrogen6X PHY reset */
-
-	imx_iomux_v3_setup_multiple_pads(enet_pads2, ARRAY_SIZE(enet_pads2));
-	udelay(100);	/* Wait 100 us before using mii interface */
-}
-
-static iomux_v3_cfg_t const usb_pads[] = {
-	MX6_PAD_GPIO_17__GPIO7_IO12 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-static void setup_iomux_uart(void)
-{
-	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
-	imx_iomux_v3_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads));
-}
+#define I2C_BUS_CNT	3
 
 #ifdef CONFIG_USB_EHCI_MX6
 int board_ehci_hcd_init(int port)
 {
-	imx_iomux_v3_setup_multiple_pads(usb_pads, ARRAY_SIZE(usb_pads));
-
-	/* Reset USB hub */
-	gpio_direction_output(IMX_GPIO_NR(7, 12), 0);
-	mdelay(2);
-	gpio_set_value(IMX_GPIO_NR(7, 12), 1);
+	if (port) {
+		/* Reset USB hub */
+		gpio_set_value(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
 
 	return 0;
 }
@@ -278,749 +300,197 @@
 {
 	if (port)
 		return 0;
-	gpio_set_value(GP_USB_OTG_PWR, on);
+	gpio_set_value(GP_REG_USBOTG, on);
 	return 0;
 }
 
 #endif
 
 #ifdef CONFIG_FSL_ESDHC
-static struct fsl_esdhc_cfg usdhc_cfg[2] = {
-	{USDHC3_BASE_ADDR},
-	{USDHC4_BASE_ADDR},
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
 };
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
-	int gp_cd = (cfg->esdhc_base == USDHC3_BASE_ADDR) ? IMX_GPIO_NR(7, 0) :
-			IMX_GPIO_NR(2, 6);
-
-	gpio_direction_input(gp_cd);
-	return !gpio_get_value(gp_cd);
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int ret;
-	u32 index = 0;
-
-	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
-	usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
-
-	usdhc_cfg[0].max_bus_width = 4;
-	usdhc_cfg[1].max_bus_width = 4;
-
-	for (index = 0; index < CONFIG_SYS_FSL_USDHC_NUM; ++index) {
-		switch (index) {
-		case 0:
-			imx_iomux_v3_setup_multiple_pads(
-				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
-			break;
-		case 1:
-		       imx_iomux_v3_setup_multiple_pads(
-			       usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
-		       break;
-		default:
-		       printf("Warning: you configured more USDHC controllers"
-			       "(%d) then supported by the board (%d)\n",
-			       index + 1, CONFIG_SYS_FSL_USDHC_NUM);
-		       return -EINVAL;
-		}
-
-		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[index]);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
 #endif
 
 #ifdef CONFIG_MXC_SPI
 int board_spi_cs_gpio(unsigned bus, unsigned cs)
 {
-	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(3, 19)) : -1;
-}
-
-static iomux_v3_cfg_t const ecspi1_pads[] = {
-	/* SS1 */
-	MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
-	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
-};
-
-static void setup_spi(void)
-{
-	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
-					 ARRAY_SIZE(ecspi1_pads));
+	if (bus == 0 && cs == 0)
+		return GP_ECSPI1_NOR_CS;
+	if (bus == 1 && cs == 0)
+		return GP_ECSPI2_CS;
+	if (cs >> 8)
+		return (cs >> 8);
+	return -1;
 }
 #endif
 
-int board_phy_config(struct phy_device *phydev)
-{
-	/* min rx data delay */
-	ksz9021_phy_extended_write(phydev,
-			MII_KSZ9021_EXT_RGMII_RX_DATA_SKEW, 0x0);
-	/* min tx data delay */
-	ksz9021_phy_extended_write(phydev,
-			MII_KSZ9021_EXT_RGMII_TX_DATA_SKEW, 0x0);
-	/* max rx/tx clock delay, min rx/tx control */
-	ksz9021_phy_extended_write(phydev,
-			MII_KSZ9021_EXT_RGMII_CLOCK_SKEW, 0xf0f0);
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-
-int board_eth_init(bd_t *bis)
-{
-	uint32_t base = IMX_FEC_BASE;
-	struct mii_dev *bus = NULL;
-	struct phy_device *phydev = NULL;
-	int ret;
-
-	setup_iomux_enet();
-
-#ifdef CONFIG_FEC_MXC
-	bus = fec_get_miibus(base, -1);
-	if (!bus)
-		return -EINVAL;
-	/* scan phy 4,5,6,7 */
-	phydev = phy_find_by_mask(bus, (0xf << 4), PHY_INTERFACE_MODE_RGMII);
-	if (!phydev) {
-		ret = -EINVAL;
-		goto free_bus;
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable) {
+		SETUP_IOMUX_PADS(rgb666_pads);
+		if ((di->pixfmt == IPU_PIX_FMT_RGB24) ||
+		    (di->pixfmt == IPU_PIX_FMT_BGR24))
+			SETUP_IOMUX_PADS(rgb24_pads);
+#ifdef CONFIG_MXC_SPI_DISPLAY
+		if (di->fbflags & FBF_SPI)
+			enable_spi_rgb(di);
+#endif
+		mdelay(100); /* let panel sync up before enabling backlight */
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+	} else {
+		gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
 	}
-	printf("using phy at %d\n", phydev->addr);
-	ret  = fec_probe(bis, -1, base, bus, phydev);
-	if (ret)
-		goto free_phydev;
-#endif
-
-#ifdef CONFIG_CI_UDC
-	/* For otg ethernet*/
-	usb_eth_initialize(bis);
-#endif
-	return 0;
-
-free_phydev:
-	free(phydev);
-free_bus:
-	free(bus);
-	return ret;
-}
-
-static void setup_buttons(void)
-{
-	imx_iomux_v3_setup_multiple_pads(button_pads,
-					 ARRAY_SIZE(button_pads));
 }
 
-#if defined(CONFIG_VIDEO_IPUV3)
-
-static iomux_v3_cfg_t const backlight_pads[] = {
-	/* Backlight on RGB connector: J15 */
-	MX6_PAD_SD1_DAT3__GPIO1_IO21 | MUX_PAD_CTRL(NO_PAD_CTRL),
-#define RGB_BACKLIGHT_GP IMX_GPIO_NR(1, 21)
-
-	/* Backlight on LVDS connector: J6 */
-	MX6_PAD_SD1_CMD__GPIO1_IO18 | MUX_PAD_CTRL(NO_PAD_CTRL),
-#define LVDS_BACKLIGHT_GP IMX_GPIO_NR(1, 18)
-};
-
-static iomux_v3_cfg_t const rgb_pads[] = {
-	MX6_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
-	MX6_PAD_DI0_PIN15__IPU1_DI0_PIN15,
-	MX6_PAD_DI0_PIN2__IPU1_DI0_PIN02,
-	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,
-	MX6_PAD_DI0_PIN4__GPIO4_IO20,
-	MX6_PAD_DISP0_DAT0__IPU1_DISP0_DATA00,
-	MX6_PAD_DISP0_DAT1__IPU1_DISP0_DATA01,
-	MX6_PAD_DISP0_DAT2__IPU1_DISP0_DATA02,
-	MX6_PAD_DISP0_DAT3__IPU1_DISP0_DATA03,
-	MX6_PAD_DISP0_DAT4__IPU1_DISP0_DATA04,
-	MX6_PAD_DISP0_DAT5__IPU1_DISP0_DATA05,
-	MX6_PAD_DISP0_DAT6__IPU1_DISP0_DATA06,
-	MX6_PAD_DISP0_DAT7__IPU1_DISP0_DATA07,
-	MX6_PAD_DISP0_DAT8__IPU1_DISP0_DATA08,
-	MX6_PAD_DISP0_DAT9__IPU1_DISP0_DATA09,
-	MX6_PAD_DISP0_DAT10__IPU1_DISP0_DATA10,
-	MX6_PAD_DISP0_DAT11__IPU1_DISP0_DATA11,
-	MX6_PAD_DISP0_DAT12__IPU1_DISP0_DATA12,
-	MX6_PAD_DISP0_DAT13__IPU1_DISP0_DATA13,
-	MX6_PAD_DISP0_DAT14__IPU1_DISP0_DATA14,
-	MX6_PAD_DISP0_DAT15__IPU1_DISP0_DATA15,
-	MX6_PAD_DISP0_DAT16__IPU1_DISP0_DATA16,
-	MX6_PAD_DISP0_DAT17__IPU1_DISP0_DATA17,
-	MX6_PAD_DISP0_DAT18__IPU1_DISP0_DATA18,
-	MX6_PAD_DISP0_DAT19__IPU1_DISP0_DATA19,
-	MX6_PAD_DISP0_DAT20__IPU1_DISP0_DATA20,
-	MX6_PAD_DISP0_DAT21__IPU1_DISP0_DATA21,
-	MX6_PAD_DISP0_DAT22__IPU1_DISP0_DATA22,
-	MX6_PAD_DISP0_DAT23__IPU1_DISP0_DATA23,
-};
-
-static void do_enable_hdmi(struct display_info_t const *dev)
-{
-	imx_enable_hdmi_phy();
-}
-
-static int detect_i2c(struct display_info_t const *dev)
-{
-	return ((0 == i2c_set_bus_num(dev->bus))
-		&&
-		(0 == i2c_probe(dev->addr)));
-}
-
-static void enable_lvds(struct display_info_t const *dev)
-{
-	struct iomuxc *iomux = (struct iomuxc *)
-				IOMUXC_BASE_ADDR;
-	u32 reg = readl(&iomux->gpr[2]);
-	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT;
-	writel(reg, &iomux->gpr[2]);
-	gpio_direction_output(LVDS_BACKLIGHT_GP, 1);
-}
-
-static void enable_lvds_jeida(struct display_info_t const *dev)
-{
-	struct iomuxc *iomux = (struct iomuxc *)
-				IOMUXC_BASE_ADDR;
-	u32 reg = readl(&iomux->gpr[2]);
-	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT
-	     |IOMUXC_GPR2_BIT_MAPPING_CH0_JEIDA;
-	writel(reg, &iomux->gpr[2]);
-	gpio_direction_output(LVDS_BACKLIGHT_GP, 1);
-}
-
-static void enable_rgb(struct display_info_t const *dev)
-{
-	imx_iomux_v3_setup_multiple_pads(
-		rgb_pads,
-		 ARRAY_SIZE(rgb_pads));
-	gpio_direction_output(RGB_BACKLIGHT_GP, 1);
-}
-
-struct display_info_t const displays[] = {{
-	.bus	= 1,
-	.addr	= 0x50,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= detect_i2c,
-	.enable	= do_enable_hdmi,
-	.mode	= {
-		.name           = "HDMI",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= NULL,
-	.enable	= enable_lvds_jeida,
-	.mode	= {
-		.name           = "LDB-WXGA",
-		.refresh        = 60,
-		.xres           = 1280,
-		.yres           = 800,
-		.pixclock       = 14065,
-		.left_margin    = 40,
-		.right_margin   = 40,
-		.upper_margin   = 3,
-		.lower_margin   = 80,
-		.hsync_len      = 10,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= NULL,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "LDB-WXGA-S",
-		.refresh        = 60,
-		.xres           = 1280,
-		.yres           = 800,
-		.pixclock       = 14065,
-		.left_margin    = 40,
-		.right_margin   = 40,
-		.upper_margin   = 3,
-		.lower_margin   = 80,
-		.hsync_len      = 10,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 2,
-	.addr	= 0x4,
-	.pixfmt	= IPU_PIX_FMT_LVDS666,
-	.detect	= detect_i2c,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "Hannstar-XGA",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_LVDS666,
-	.detect	= NULL,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "LG-9.7",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385, /* ~65MHz */
-		.left_margin    = 480,
-		.right_margin   = 260,
-		.upper_margin   = 16,
-		.lower_margin   = 6,
-		.hsync_len      = 250,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 2,
-	.addr	= 0x38,
-	.pixfmt	= IPU_PIX_FMT_LVDS666,
-	.detect	= detect_i2c,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "wsvga-lvds",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 600,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 2,
-	.addr	= 0x10,
-	.pixfmt	= IPU_PIX_FMT_RGB666,
-	.detect	= detect_i2c,
-	.enable	= enable_rgb,
-	.mode	= {
-		.name           = "fusion7",
-		.refresh        = 60,
-		.xres           = 800,
-		.yres           = 480,
-		.pixclock       = 33898,
-		.left_margin    = 96,
-		.right_margin   = 24,
-		.upper_margin   = 3,
-		.lower_margin   = 10,
-		.hsync_len      = 72,
-		.vsync_len      = 7,
-		.sync           = 0x40000002,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB666,
-	.detect	= NULL,
-	.enable	= enable_rgb,
-	.mode	= {
-		.name           = "svga",
-		.refresh        = 60,
-		.xres           = 800,
-		.yres           = 600,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 2,
-	.addr	= 0x41,
-	.pixfmt	= IPU_PIX_FMT_LVDS666,
-	.detect	= detect_i2c,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "amp1024x600",
-		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 600,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_LVDS666,
-	.detect	= 0,
-	.enable	= enable_lvds,
-	.mode	= {
-		.name           = "wvga-lvds",
-		.refresh        = 57,
-		.xres           = 800,
-		.yres           = 480,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 2,
-	.addr	= 0x48,
-	.pixfmt	= IPU_PIX_FMT_RGB666,
-	.detect	= detect_i2c,
-	.enable	= enable_rgb,
-	.mode	= {
-		.name           = "wvga-rgb",
-		.refresh        = 57,
-		.xres           = 800,
-		.yres           = 480,
-		.pixclock       = 37037,
-		.left_margin    = 40,
-		.right_margin   = 60,
-		.upper_margin   = 10,
-		.lower_margin   = 10,
-		.hsync_len      = 20,
-		.vsync_len      = 10,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} }, {
-	.bus	= 0,
-	.addr	= 0,
-	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= NULL,
-	.enable	= enable_rgb,
-	.mode	= {
-		.name           = "qvga",
-		.refresh        = 60,
-		.xres           = 320,
-		.yres           = 240,
-		.pixclock       = 37037,
-		.left_margin    = 38,
-		.right_margin   = 37,
-		.upper_margin   = 16,
-		.lower_margin   = 15,
-		.hsync_len      = 30,
-		.vsync_len      = 3,
-		.sync           = 0,
-		.vmode          = FB_VMODE_NONINTERLACED
-} } };
-size_t display_count = ARRAY_SIZE(displays);
-
-int board_cfb_skip(void)
+void board_pre_enable(const struct display_info_t *di)
 {
-	return NULL != getenv("novideo");
+	SETUP_IOMUX_PADS(rgb666_pads);
+	enable_spi_rgb(di);
 }
 
-static void setup_display(void)
-{
-	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
-	int reg;
-
-	enable_ipu_clock();
-	imx_setup_hdmi();
-	/* Turn on LDB0,IPU,IPU DI0 clocks */
-	reg = __raw_readl(&mxc_ccm->CCGR3);
-	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK;
-	writel(reg, &mxc_ccm->CCGR3);
-
-	/* set LDB0, LDB1 clk select to 011/011 */
-	reg = readl(&mxc_ccm->cs2cdr);
-	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
-		 |MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
-	reg |= (3<<MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
-	      |(3<<MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->cs2cdr);
-
-	reg = readl(&mxc_ccm->cscmr2);
-	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
-	writel(reg, &mxc_ccm->cscmr2);
-
-	reg = readl(&mxc_ccm->chsccdr);
-	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
-		<<MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
-	writel(reg, &mxc_ccm->chsccdr);
-
-	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
-	     |IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH
-	     |IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
-	     |IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
-	     |IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
-	     |IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
-	     |IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
-	     |IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
-	     |IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
-	writel(reg, &iomux->gpr[2]);
-
-	reg = readl(&iomux->gpr[3]);
-	reg = (reg & ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK
-			|IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
-	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
-	       <<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
-	writel(reg, &iomux->gpr[3]);
-
-	/* backlights off until needed */
-	imx_iomux_v3_setup_multiple_pads(backlight_pads,
-					 ARRAY_SIZE(backlight_pads));
-	gpio_direction_input(LVDS_BACKLIGHT_GP);
-	gpio_direction_input(RGB_BACKLIGHT_GP);
-}
-#endif
-
-static iomux_v3_cfg_t const init_pads[] = {
-	/* SGTL5000 sys_mclk */
-	NEW_PAD_CTRL(MX6_PAD_GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
-
-	/* J5 - Camera MCLK */
-	NEW_PAD_CTRL(MX6_PAD_GPIO_3__CCM_CLKO2, OUTPUT_40OHM),
-
-	/* wl1271 pads on nitrogen6x */
-	/* WL12XX_WL_IRQ_GP */
-	NEW_PAD_CTRL(MX6_PAD_NANDF_CS1__GPIO6_IO14, WEAK_PULLDOWN),
-	/* WL12XX_WL_ENABLE_GP */
-	NEW_PAD_CTRL(MX6_PAD_NANDF_CS2__GPIO6_IO15, OUTPUT_40OHM),
-	/* WL12XX_BT_ENABLE_GP */
-	NEW_PAD_CTRL(MX6_PAD_NANDF_CS3__GPIO6_IO16, OUTPUT_40OHM),
-	/* USB otg power */
-	NEW_PAD_CTRL(MX6_PAD_EIM_D22__GPIO3_IO22, OUTPUT_40OHM),
-	NEW_PAD_CTRL(MX6_PAD_NANDF_D5__GPIO2_IO05, OUTPUT_40OHM),
-	NEW_PAD_CTRL(MX6_PAD_NANDF_WP_B__GPIO6_IO09, OUTPUT_40OHM),
-	NEW_PAD_CTRL(MX6_PAD_GPIO_8__GPIO1_IO08, OUTPUT_40OHM),
-	NEW_PAD_CTRL(MX6_PAD_GPIO_6__GPIO1_IO06, OUTPUT_40OHM),
-};
-
-#define WL12XX_WL_IRQ_GP	IMX_GPIO_NR(6, 14)
-
-static unsigned gpios_out_low[] = {
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+	VD_640_480M_60(HDMI, NULL, 1, 0x50),
+	VD_720_480M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_AUO_B101EW05(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_DT035BTFT(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+#ifdef CONFIG_MXC_SPI_DISPLAY
+	VD_AUO_G050(LCD, NULL, 1, 0),
+	VD_A030JN01_UPS051(LCD, NULL, 1, 2),
+	VD_A030JN01_YUV720(LCD, NULL, 1, 1),
+	VD_KD024FM(LCD, NULL, 2, 3),
+#endif
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII2_PHY_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_RGB,
 	/* Disable wl1271 */
-	IMX_GPIO_NR(6, 15),	/* disable wireless */
-	IMX_GPIO_NR(6, 16),	/* disable bluetooth */
-	IMX_GPIO_NR(3, 22),	/* disable USB otg power */
-	IMX_GPIO_NR(2, 5),	/* ov5640 mipi camera reset */
-	IMX_GPIO_NR(1, 8),	/* ov5642 reset */
-};
-
-static unsigned gpios_out_high[] = {
-	IMX_GPIO_NR(1, 6),	/* ov5642 powerdown */
-	IMX_GPIO_NR(6, 9),	/* ov5640 mipi camera power down */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_REG_USBOTG,
+	GP_OV5642_RESET,
+	GP_USB_HUB_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_SGTL5000_HP_MUTE,
+	GP_OV5642_POWER_DOWN,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_DOWN,
+	GP_GPIOKEY_VOL_UP,
+	GPIRQ_ENET_PHY,
+	GPIRQ_RTC_ISL1208,
+	GPIRQ_TC3587,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+	GP_USDHC4_CD,
 };
 
-static void set_gpios(unsigned *p, int cnt, int val)
-{
-	int i;
-
-	for (i = 0; i < cnt; i++)
-		gpio_direction_output(*p++, val);
-}
-
 int board_early_init_f(void)
 {
-	setup_iomux_uart();
-
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
 	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
 	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
-	gpio_direction_input(WL12XX_WL_IRQ_GP);
-
-	imx_iomux_v3_setup_multiple_pads(wl12xx_pads, ARRAY_SIZE(wl12xx_pads));
-	imx_iomux_v3_setup_multiple_pads(init_pads, ARRAY_SIZE(init_pads));
-	setup_buttons();
-
-#if defined(CONFIG_VIDEO_IPUV3)
-	setup_display();
-#endif
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
 	return 0;
 }
 
-/*
- * Do not overwrite the console
- * Use always serial for U-Boot console
- */
-int overwrite_console(void)
-{
-	return 1;
-}
-
 int board_init(void)
 {
-	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
-
-	clrsetbits_le32(&iomuxc_regs->gpr[1],
-			IOMUXC_GPR1_OTG_ID_MASK,
-			IOMUXC_GPR1_OTG_ID_GPIO1);
-
-	imx_iomux_v3_setup_multiple_pads(misc_pads, ARRAY_SIZE(misc_pads));
-
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-#ifdef CONFIG_MXC_SPI
-	setup_spi();
-#endif
-	imx_iomux_v3_setup_multiple_pads(
-		usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
-	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
-
-#ifdef CONFIG_CMD_SATA
-	setup_sata();
-#endif
-
-	return 0;
-}
-
-int checkboard(void)
-{
-	if (gpio_get_value(WL12XX_WL_IRQ_GP))
-		puts("Board: Nitrogen6X\n");
-	else
-		puts("Board: SABRE Lite\n");
-
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
 	return 0;
 }
 
-struct button_key {
-	char const	*name;
-	unsigned	gpnum;
-	char		ident;
-};
-
-static struct button_key const buttons[] = {
-	{"back",	IMX_GPIO_NR(2, 2),	'B'},
-	{"home",	IMX_GPIO_NR(2, 4),	'H'},
-	{"menu",	IMX_GPIO_NR(2, 1),	'M'},
-	{"search",	IMX_GPIO_NR(2, 3),	'S'},
-	{"volup",	IMX_GPIO_NR(7, 13),	'V'},
-	{"voldown",	IMX_GPIO_NR(4, 5),	'v'},
-};
-
-/*
- * generate a null-terminated string containing the buttons pressed
- * returns number of keys pressed
- */
-static int read_keys(char *buf)
+#ifndef CONFIG_SYS_BOARD
+const char *board_get_board_type(void)
 {
-	int i, numpressed = 0;
-	for (i = 0; i < ARRAY_SIZE(buttons); i++) {
-		if (!gpio_get_value(buttons[i].gpnum))
-			buf[numpressed++] = buttons[i].ident;
-	}
-	buf[numpressed] = '\0';
-	return numpressed;
-}
-
-static int do_kbd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	char envvalue[ARRAY_SIZE(buttons)+1];
-	int numpressed = read_keys(envvalue);
-	setenv("keybd", envvalue);
-	return numpressed == 0;
+	if (gpio_get_value(GPIRQ_WL1271_WL))
+		return "nitrogen6x";
+	return "sabrelite";
 }
+#endif
 
-U_BOOT_CMD(
-	kbd, 1, 1, do_kbd,
-	"Tests for keypresses, sets 'keybd' environment variable",
-	"Returns 0 (true) to shell if key is pressed."
-);
-
-#ifdef CONFIG_PREBOOT
-static char const kbd_magic_prefix[] = "key_magic";
-static char const kbd_command_prefix[] = "key_cmd";
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
 
-static void preboot_keys(void)
-{
-	int numpressed;
-	char keypress[ARRAY_SIZE(buttons)+1];
-	numpressed = read_keys(keypress);
-	if (numpressed) {
-		char *kbd_magic_keys = getenv("magic_keys");
-		char *suffix;
-		/*
-		 * loop over all magic keys
-		 */
-		for (suffix = kbd_magic_keys; *suffix; ++suffix) {
-			char *keys;
-			char magic[sizeof(kbd_magic_prefix) + 1];
-			sprintf(magic, "%s%c", kbd_magic_prefix, *suffix);
-			keys = getenv(magic);
-			if (keys) {
-				if (!strcmp(keys, keypress))
-					break;
-			}
-		}
-		if (*suffix) {
-			char cmd_name[sizeof(kbd_command_prefix) + 1];
-			char *cmd;
-			sprintf(cmd_name, "%s%c", kbd_command_prefix, *suffix);
-			cmd = getenv(cmd_name);
-			if (cmd) {
-				setenv("preboot", cmd);
-				return;
-			}
-		}
-	}
-}
-#endif
 
 #ifdef CONFIG_CMD_BMODE
-static const struct boot_mode board_boot_modes[] = {
+const struct boot_mode board_boot_modes[] = {
 	/* 4 bit bus width */
 	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
 	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
 	{NULL,		0},
 };
 #endif
-
-int misc_init_r(void)
-{
-#ifdef CONFIG_PREBOOT
-	preboot_keys();
-#endif
-
-#ifdef CONFIG_CMD_BMODE
-	add_board_boot_modes(board_boot_modes);
-#endif
-	setenv_hex("reset_cause", get_imx_reset_cause());
-	return 0;
-}
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/spi_display.c u-boot-imx6/board/boundary/nitrogen6x/spi_display.c
--- u-boot-2017.07/board/boundary/nitrogen6x/spi_display.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/spi_display.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,664 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/video.h>
+#include <spi.h>
+#include "spi_display.h"
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define SPI_MOSI_R_PAD_CTRL	SPI_PAD_CTRL | PAD_CTL_ODE | PAD_CTL_PUS_22K_UP
+
+#define GP_SPI_DISPLAY_RESET	IMX_GPIO_NR(4, 20)
+
+#define WEAK_PULLDN	(PAD_CTL_PUS_100K_DOWN |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDN_OUTPUT (PAD_CTL_PUS_100K_DOWN |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLUP	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+struct spi_display_info {
+	int mode;
+	int speed_r;
+	int speed_w;
+	int reset_active_low;
+	int cs_gpio;
+	int reset_gpio;
+	u8 *init_cmds;
+	u8 *on_cmds;
+	const iomux_v3_cfg_t *spi_mosi_r_pads;
+	const iomux_v3_cfg_t *spi_mosi_w_pads;
+	const iomux_v3_cfg_t *spi_ss0_pad;
+	const iomux_v3_cfg_t *spi_ss0_gpio_pad;
+	int (*spi_write_rtn)(struct spi_slave *spi, u8 *cmds);
+	int (*spi_read_rtn)(struct spi_slave *spi, int reg);
+	int (*spi_setup_rtn)(struct spi_display_info *di);
+	int (*spi_exit_rtn)(struct spi_display_info *di);
+};
+
+static iomux_v3_cfg_t const spi_mosi_r_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_MOSI_R_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_mosi_w_pads[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_pad[] = {
+	IOMUX_PAD_CTRL(CSI0_DAT11__ECSPI2_SS0, SPI_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const spi_ss0_gpio_pad[] = {
+#define GP_ECSPI2_CS		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, SPI_PAD_CTRL),
+};
+
+static int AUO_G050_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	debug("%s\n", __func__);
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = 0x20;
+			buf[1] = reg >> 8;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			buf[0] = 0;
+			buf[1] = reg;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			udelay(2);
+			if (!len) {
+				debug("spi: reg:%04x\n", reg);
+				break;
+			}
+			buf[0] = 0x40;
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%04x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int AUO_G050_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = 0x20;
+	buf[1] = reg >> 8;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg1 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0;
+	buf[1] = reg;
+	ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg2 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	udelay(2);
+	buf[0] = 0xC0;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed to select reg3 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%04x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	udelay(2);
+	return rbuf[1];
+}
+
+#define A(reg, cnt) (reg >> 8), (reg & 0xff), cnt
+
+static u8 AUO_G050_display_init_cmds[] = {
+/* Display Mode Setting */
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x00,
+	A(0xb100, 2), 0x0c, 0x00,
+	A(0xbc00, 3), 0x05, 0x05, 0x05,
+	A(0xb700, 2), 0x22, 0x22,
+	A(0xb800, 4), 0x01, 0x03, 0x03, 0x03,
+	A(0xc803, 1), 0x96,
+	A(0xc805, 1), 0x96,
+	A(0xc807, 1), 0x96,
+	A(0xc809, 1), 0x96,
+	A(0xc80b, 1), 0x2a,
+	A(0xc80c, 1), 0x2a,
+	A(0xc80f, 1), 0x2a,
+	A(0xc810, 1), 0x2a,
+	A(0xf000, 5), 0x55, 0xaa, 0x52, 0x08, 0x01,
+	A(0xb900, 3), 0x34, 0x34, 0x34,
+	A(0xba00, 3), 0x14, 0x14, 0x14,
+	A(0xbe00, 2), 0x00, 0x8c,
+	A(0xb000, 3), 0x00, 0x00, 0x00,
+	A(0xb800, 3), 0x24, 0x24, 0x24,
+	A(0xbc00, 3), 0x00, 0x88, 0x01,
+	A(0xbd00, 3), 0x00, 0x88, 0x01,
+	A(0xd100, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd200, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd300, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd400, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd500, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0xd600, 52),  0x00, 0x00, 0x00, 0x10, 0x00, 0x31, 0x00, 0x5a, 0x00, 0x78, 0x00, 0x9b, 0x00, 0xbe, 0x00, 0xe6, 0x01, 0x04,
+			0x01, 0x36, 0x01, 0x59, 0x01, 0x90, 0x01, 0xbd, 0x01, 0xbe, 0x01, 0xe5, 0x02, 0x0d, 0x02, 0x29, 0x02, 0x44,
+			0x02, 0x5d, 0x02, 0xbc, 0x02, 0xe9, 0x03, 0x16, 0x03, 0x48, 0x03, 0xac, 0x03, 0xe8, 0x03, 0xff,
+	A(0x1100, 0),	/* exit sleep mode, wait 120 ms */
+	A(0, 0)
+};
+
+static u8 AUO_G050_display_on_cmds[] = {
+	A(0x2900, 0),
+	A(0, 0)
+};
+
+/* *************************************************** */
+
+static int A030JN01_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	while (1) {
+		uint reg = (cmds[0] << 8) | cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		do {
+			buf[0] = reg + (reg & 0x40);
+			buf[1] = *cmds++;
+			ret = spi_xfer(spi, 2 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%02x %02x\n", reg, buf[1]);
+			udelay(2);
+			reg++;
+		} while (--len);
+	}
+	return ret;
+}
+
+static int A030JN01_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	u8 buf[4];
+	u8 rbuf[4];
+	int ret = 0;
+
+	buf[0] = (reg + (reg & 0x40)) | 0x40;
+	buf[1] = 0xff;
+	ret = spi_xfer(spi, 2 * 8, buf, rbuf, SPI_XFER_BEGIN | SPI_XFER_END);
+	if (ret) {
+		debug("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+		return ret;
+	}
+	debug("spi: reg:0x%02x: %02x %02x\n", reg, rbuf[0], rbuf[1]);
+	return rbuf[1];
+}
+
+static u8 A030JN01_display_YUV720_init_cmds[] = {
+/* Display Mode Setting */
+	A(4, 2), 0x6b, 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_UPS051_init_cmds[] = {
+	A(5, 1), 0x5f,
+	A(0, 0)
+};
+
+static u8 A030JN01_display_on_cmds[] = {
+	A(0, 0)
+};
+
+/* *************************************************** */
+
+static iomux_v3_cfg_t const KD024FM_spi_pads[] = {
+#define GP_KD024FM_CS		IMX_GPIO_NR(5, 13)
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),	/* Pin 8 CS */
+#define GP_KD024FM_IM2		IMX_GPIO_NR(5, 17)
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+#define GP_KD024FM_IM1		IMX_GPIO_NR(5, 16)
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+#define GP_KD024FM_IM0		IMX_GPIO_NR(5, 15)
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLDN),
+#define GP_KD024FM_RESET	IMX_GPIO_NR(5, 14)
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLDN),
+#define GP_KD024FM_RS		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),	/* Pin 10 RS ** */
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, WEAK_PULLUP),	/* Pin 9 SCL */
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, WEAK_PULLUP),	/* Pin 16 SDA1 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, WEAK_PULLUP),	/* Pin 35 SDO */
+#define GP_KD024FM_PCLK		IMX_GPIO_NR(4, 16)
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+#define GP_KD024FM_HSYNC	IMX_GPIO_NR(4, 18)
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),	/* HSYNC */
+#define GP_KD024FM_VSYNC	IMX_GPIO_NR(4, 19)
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),	/* VSYNC */
+#define GP_KD024FM_DRDY		IMX_GPIO_NR(4, 17)
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),	/* DRDY */
+};
+
+static iomux_v3_cfg_t const KD024FM_display_pads[] = {
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+};
+
+static int KD024FM_spi_write_rtn(struct spi_slave *spi, u8 *cmds)
+{
+	u8 buf[4];
+	int ret = 0;
+
+	while (1) {
+		uint reg = cmds[1];
+		uint len = cmds[2];
+
+		if (!len && !reg)
+			break;
+		cmds += 3;
+		gpio_direction_output(GP_KD024FM_RS, 0);
+		buf[0] = reg;
+		ret = spi_xfer(spi, 1 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+		if (ret) {
+			printf("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+			return ret;
+		}
+		if (!len) {
+			debug("spi: reg:%02x\n", reg);
+			continue;
+		}
+
+		gpio_set_value(GP_KD024FM_RS, 1);
+		while (len--) {
+			buf[0] = *cmds++;
+			ret = spi_xfer(spi, 1 * 8, buf, NULL, SPI_XFER_BEGIN | SPI_XFER_END);
+			if (ret) {
+				printf("%s: Failed 0x%x, %d\n", __func__, reg, ret);
+				return ret;
+			}
+			debug("spi: reg:%02x %02x\n", reg, buf[0]);
+			udelay(2);
+		}
+	}
+	return ret;
+}
+
+static int KD024FM_spi_read_rtn(struct spi_slave *spi, int reg)
+{
+	printf("%s: undefined\n", __func__);
+	return 0;
+}
+
+static int KD024FM_spi_setup_rtn(struct spi_display_info *di)
+{
+	gpio_direction_output(di->cs_gpio, 1);
+	gpio_direction_output(GP_KD024FM_IM2, 1);
+	gpio_direction_output(GP_KD024FM_IM1, 1);
+	gpio_direction_output(GP_KD024FM_IM0, 0);
+	gpio_direction_output(di->reset_gpio, 1);
+	gpio_direction_output(GP_KD024FM_RS, 0);
+	gpio_direction_output(GP_KD024FM_HSYNC, 1);
+	gpio_direction_output(GP_KD024FM_VSYNC, 1);
+	gpio_direction_output(GP_KD024FM_DRDY, 1);
+	gpio_direction_output(GP_KD024FM_PCLK, 1);
+	SETUP_IOMUX_PADS(KD024FM_spi_pads);
+	return 0;
+}
+
+static int KD024FM_spi_exit_rtn(struct spi_display_info *di)
+{
+	SETUP_IOMUX_PADS(KD024FM_display_pads);
+	return 0;
+}
+
+
+static u8 KD024FM_display_init_cmds[] = {
+	A(0x3a, 1), 0x05,	/* ST7789S Frame rate setting */
+	A(0x36, 1), 0x00,
+	A(0xb2, 5), 0x00, 0x00, 0x00, 0x33, 0x33,
+	A(0xb7, 1), 0x35,
+	A(0xb8, 3), 0x2f, 0x2b, 0x2f,	/* ST7789S Power setting */
+	A(0xbb, 1), 0x24,
+	A(0xc0, 1), 0x2c,
+	A(0xc3, 1), 0x10,
+	A(0xc4, 1), 0x20,
+	A(0xc6, 1), 0x11,
+	A(0xd0, 2), 0xa4, 0xa1,
+	A(0xe8, 1), 0x03,
+	A(0xe9, 3), 0x0d, 0x12, 0x00,
+	/* ST7789S gamma setting */
+	A(0xe0, 14), 0xd0, 0x00, 0x00, 0x08, 0x11, 0x1a, 0x2b, 0x33, 0x42, 0x26, 0x12, 0x21, 0x2f, 0x11,
+	A(0xe1, 14), 0xd0, 0x02, 0x09, 0x0d, 0x0d, 0x27, 0x2b, 0x33, 0x42, 0x17, 0x12, 0x11, 0x2f, 0x31,
+	A(0x21, 0),
+	/* SET RGB Interface */
+	A(0xb0, 3), 0x11, 0x00, 0x00,
+	/* set DE mode ; SET Hs,Vs,DE,DOTCLK signal polarity */
+	A(0xb1, 3), 0xc0, 0x08, 0x14,
+	A(0x3a, 1), 0x88,		/* 18 Bit RGB, 0x55 means 16 Bit RGB */
+	A(0x11, 0),
+	A(0, 0)
+};
+
+static u8 KD024FM_display_on_cmds[] = {
+	A(0x29, 0),
+	A(0x2c, 0),
+	A(0, 0)
+};
+
+struct spi_display_info spi_di[] = {
+	{ .mode = SPI_MODE_0, .speed_r = 10000, .speed_w = 1000000, .reset_active_low = 1,
+			.cs_gpio = GP_ECSPI2_CS, .reset_gpio = GP_SPI_DISPLAY_RESET,
+			.init_cmds = AUO_G050_display_init_cmds, .on_cmds = AUO_G050_display_on_cmds,
+			.spi_mosi_r_pads = spi_mosi_r_pads,
+			.spi_mosi_w_pads = spi_mosi_w_pads,
+			.spi_ss0_pad = spi_ss0_pad,
+			.spi_ss0_gpio_pad = spi_ss0_gpio_pad,
+			.spi_write_rtn = AUO_G050_spi_write_rtn, .spi_read_rtn = AUO_G050_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.cs_gpio = GP_ECSPI2_CS, .reset_gpio = GP_SPI_DISPLAY_RESET,
+			.init_cmds = A030JN01_display_YUV720_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_mosi_r_pads = spi_mosi_r_pads,
+			.spi_mosi_w_pads = spi_mosi_w_pads,
+			.spi_ss0_pad = spi_ss0_pad,
+			.spi_ss0_gpio_pad = spi_ss0_gpio_pad,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+	{ .mode = SPI_MODE_3, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.cs_gpio = GP_ECSPI2_CS, .reset_gpio = GP_SPI_DISPLAY_RESET,
+			.init_cmds = A030JN01_display_UPS051_init_cmds, .on_cmds = A030JN01_display_on_cmds,
+			.spi_mosi_r_pads = spi_mosi_r_pads,
+			.spi_mosi_w_pads = spi_mosi_w_pads,
+			.spi_ss0_pad = spi_ss0_pad,
+			.spi_ss0_gpio_pad = spi_ss0_gpio_pad,
+			.spi_write_rtn = A030JN01_spi_write_rtn, .spi_read_rtn = A030JN01_spi_read_rtn},
+	{ .mode = SPI_MODE_0, .speed_r = 10000, .speed_w = 10000, .reset_active_low = 1,
+			.cs_gpio = GP_KD024FM_CS, .reset_gpio = GP_KD024FM_RESET,
+			.init_cmds = KD024FM_display_init_cmds, .on_cmds = KD024FM_display_on_cmds,
+			.spi_write_rtn = KD024FM_spi_write_rtn, .spi_read_rtn = KD024FM_spi_read_rtn,
+			.spi_setup_rtn = KD024FM_spi_setup_rtn, .spi_exit_rtn = KD024FM_spi_exit_rtn},
+};
+
+const struct display_info_t *g_dev;
+
+/*
+ * Return 1 for successful detection of display
+ */
+int detect_spi(struct display_info_t const *dev)
+{
+	return 1;
+}
+
+static void init_spi(struct display_info_t const *dev)
+{
+	struct spi_display_info *di = &spi_di[dev->addr];
+	unsigned reset_gpio = di->reset_gpio;
+	int reset_val = di->reset_active_low ? 0 : 1;
+
+	debug("%s\n", __func__);
+	gpio_direction_output(di->cs_gpio, 1);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	gpio_direction_output(reset_gpio, reset_val);
+	udelay(200);
+	gpio_direction_output(reset_gpio, reset_val ^ 1);
+	mdelay(200);
+}
+
+void enable_spi_rgb(struct display_info_t const *dev)
+{
+	struct spi_display_info *di = &spi_di[dev->addr];
+	struct spi_slave *spi;
+	int ret;
+
+	g_dev = dev;
+	if (di->spi_setup_rtn)
+		di->spi_setup_rtn(di);
+	init_spi(dev);
+	gpio_direction_output(di->cs_gpio, 1);
+	if (di->spi_mosi_w_pads)
+		SETUP_IOMUX_PADS(di->spi_mosi_w_pads);
+
+	enable_spi_clk(1, dev->bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(dev->bus, di->spi_ss0_pad ? 0 : di->cs_gpio << 8,
+			di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	/*
+	 * Initialization sequence
+	 * 1. Display Mode Settings
+	 * 2. Power Settings
+	 * 3. Gamma Settings
+	 * 4. Sleep Out
+	 * 5. Wait >= 7 frame
+	 * 6. Display on
+	 */
+	if (di->spi_ss0_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_pad);
+	ret = di->spi_write_rtn(spi, di->init_cmds);
+	if (ret) {
+		printf("%s: Failed to display_init_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	mdelay(200);
+	ret = di->spi_write_rtn(spi, di->on_cmds);
+	if (ret) {
+		printf("%s: Failed to display_on_cmds %d\n", __func__, ret);
+		goto release_bus;
+	}
+	ret = 1;
+	if (di->spi_ss0_gpio_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_gpio_pad);
+
+	/* Release spi bus */
+release_bus:
+	spi_release_bus(spi);
+free_bus:
+	spi_free_slave(spi);
+	enable_spi_clk(0, dev->bus);
+	if (di->spi_exit_rtn)
+		di->spi_exit_rtn(di);
+	return;
+}
+
+static int do_spid(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	int arg = 2;
+	uint reg;
+	u8 buf[80];
+
+	if (argc < 2)
+		return 1;
+	if (di->spi_setup_rtn)
+		di->spi_setup_rtn(di);
+	gpio_direction_output(di->cs_gpio, 1);
+	if (di->spi_mosi_w_pads)
+		SETUP_IOMUX_PADS(di->spi_mosi_w_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, di->spi_ss0_pad ? 0 : di->cs_gpio << 8,
+			di->speed_w, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	if (argc > ARRAY_SIZE(buf) - 3)
+		argc = ARRAY_SIZE(buf) - 3;
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	buf[0] = reg >> 8;
+	buf[1] = reg;
+	buf[2] = argc - arg;
+	while (arg < argc) {
+		buf[arg + 1] = simple_strtoul(argv[arg], NULL, 16);
+		arg++;
+	}
+	arg++;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	buf[arg++] = 0;
+	if (di->spi_ss0_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_pad);
+	di->spi_write_rtn(spi, buf);
+	if (di->spi_ss0_gpio_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_gpio_pad);
+	spi_release_bus(spi);
+free_bus:
+	if (di->spi_exit_rtn)
+		di->spi_exit_rtn(di);
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spid, 70, 0, do_spid,
+	"write cmd, data to spi display",
+	"reg16 [byte]"
+);
+
+static int do_spidr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct spi_slave *spi;
+	int display_index = g_dev ? g_dev->addr : 0;
+	int bus = g_dev ? g_dev->bus : 1;
+	struct spi_display_info *di = &spi_di[display_index];
+	int ret = 0;
+	uint reg;
+	int val;
+
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	if (di->spi_setup_rtn)
+		di->spi_setup_rtn(di);
+	gpio_direction_output(di->cs_gpio, 1);
+	if (di->spi_mosi_r_pads)
+		SETUP_IOMUX_PADS(di->spi_mosi_r_pads);
+
+	enable_spi_clk(1, bus);
+
+	/* Setup spi_slave */
+	spi = spi_setup_slave(bus, di->spi_ss0_pad ? 0 : di->cs_gpio << 8, di->speed_r, di->mode);
+	if (!spi) {
+		printf("%s: Failed to set up slave\n", __func__);
+		return 1;
+	}
+
+	/* Claim spi bus */
+	ret = spi_claim_bus(spi);
+	if (ret) {
+		debug("%s: Failed to claim SPI bus: %d\n", __func__, ret);
+		goto free_bus;
+	}
+
+	reg = simple_strtoul(argv[1], NULL, 16);
+	if (di->spi_ss0_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_pad);
+	val = di->spi_read_rtn(spi, reg);
+	if (di->spi_ss0_gpio_pad)
+		SETUP_IOMUX_PADS(di->spi_ss0_gpio_pad);
+	printf("spidr: reg:0x%x = 0x%x\n", reg, val);
+	spi_release_bus(spi);
+free_bus:
+	if (di->spi_exit_rtn)
+		di->spi_exit_rtn(di);
+	spi_free_slave(spi);
+	enable_spi_clk(0, bus);
+	return ret ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	spidr, 70, 0, do_spidr,
+	"read spi display register",
+	"reg16"
+);
diff -Nru u-boot-2017.07/board/boundary/nitrogen6x/spi_display.h u-boot-imx6/board/boundary/nitrogen6x/spi_display.h
--- u-boot-2017.07/board/boundary/nitrogen6x/spi_display.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen6x/spi_display.h	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,2 @@
+int detect_spi(struct display_info_t const *dev);
+void enable_spi_rgb(struct display_info_t const *dev);
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/Kconfig u-boot-imx6/board/boundary/nitrogen7/Kconfig
--- u-boot-2017.07/board/boundary/nitrogen7/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/Kconfig	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,21 @@
+if TARGET_NITROGEN7
+
+config SYS_BOARD
+	default "nitrogen7"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx7"
+
+config SYS_CONFIG_NAME
+	default "nitrogen7"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/MAINTAINERS u-boot-imx6/board/boundary/nitrogen7/MAINTAINERS
--- u-boot-2017.07/board/boundary/nitrogen7/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/MAINTAINERS	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+NITROGEN7 BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nitrogen7
+F:	include/configs/nitrogen7.h
+F:	configs/nitrogen7_defconfig
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/Makefile u-boot-imx6/board/boundary/nitrogen7/Makefile
--- u-boot-2017.07/board/boundary/nitrogen7/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/Makefile	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,6 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nitrogen7.o
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/nitrogen7.c u-boot-imx6/board/boundary/nitrogen7/nitrogen7.c
--- u-boot-2017.07/board/boundary/nitrogen7/nitrogen7.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/nitrogen7.c	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx7-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include "../../freescale/common/pfuze.h"
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/arch/crm_regs.h>
+#include <usb.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_DSE_3P3V_49OHM | \
+	PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU47KOHM)
+
+#define I2C_PAD_CTRL    (PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+	PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PUS_PU100KOHM)
+
+#define QSPI_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_PUS_PU100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_3P3V_49OHM
+
+#define SETUP_IOMUX_PADS(x)					\
+	imx_iomux_v3_setup_multiple_pads(x, ARRAY_SIZE(x))
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* fec */
+#ifdef CONFIG_FEC_MXC
+	/* PHY - AR8035 */
+	IOMUX_PAD_CTRL(GPIO1_IO10__ENET1_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(GPIO1_IO11__ENET1_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TD0__ENET1_RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TD1__ENET1_RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TD2__ENET1_RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TD3__ENET1_RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET1_RGMII_TXC__ENET1_RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(GPIO1_IO12__CCM_ENET_REF_CLK1, PAD_CTRL_ENET_TX),
+#endif
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(SD3_STROBE__GPIO6_IO10, WEAK_PULLUP),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO1_IO02__GPIO1_IO2, WEAK_PULLUP),
+
+	/* flexcan2 */
+	IOMUX_PAD_CTRL(GPIO1_IO14__FLEXCAN2_RX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO1_IO15__FLEXCAN2_TX, WEAK_PULLUP),
+#define GP_CAN_STANDBY		IMX_GPIO_NR(2, 14)
+	IOMUX_PAD_CTRL(EPDC_DATA14__GPIO2_IO14, WEAK_PULLUP),
+
+	/* GPIOs - J2 */
+	IOMUX_PAD_CTRL(SAI1_TX_DATA__GPIO6_IO15, WEAK_PULLUP),	/* pin 1 */
+	IOMUX_PAD_CTRL(SAI1_RX_DATA__GPIO6_IO12, WEAK_PULLUP),	/* pin 3 */
+	IOMUX_PAD_CTRL(SD1_WP__GPIO5_IO1, WEAK_PULLUP),		/* pin 5 */
+	IOMUX_PAD_CTRL(SD1_RESET_B__GPIO5_IO2, WEAK_PULLUP),	/* pin 7 */
+	IOMUX_PAD_CTRL(EPDC_DATA07__GPIO2_IO7, WEAK_PULLUP),	/* pin 15 */
+	IOMUX_PAD_CTRL(EPDC_DATA08__GPIO2_IO8, WEAK_PULLUP),	/* pin 17 */
+	IOMUX_PAD_CTRL(EPDC_DATA09__GPIO2_IO9, WEAK_PULLUP),	/* pin 19 */
+	IOMUX_PAD_CTRL(EPDC_DATA10__GPIO2_IO10, WEAK_PULLUP),	/* pin 21 */
+	IOMUX_PAD_CTRL(EPDC_DATA11__GPIO2_IO11, WEAK_PULLUP),	/* pin 23 */
+	IOMUX_PAD_CTRL(EPDC_DATA12__GPIO2_IO12, WEAK_PULLUP),	/* pin 25 */
+	IOMUX_PAD_CTRL(EPDC_DATA13__GPIO2_IO13, WEAK_PULLUP),	/* pin 27 */
+	IOMUX_PAD_CTRL(EPDC_GDCLK__GPIO2_IO24, WEAK_PULLUP),	/* pin 33 */
+	IOMUX_PAD_CTRL(EPDC_GDOE__GPIO2_IO25, WEAK_PULLUP),	/* pin 35 */
+	IOMUX_PAD_CTRL(EPDC_GDRL__GPIO2_IO26, WEAK_PULLUP),	/* pin 37 */
+	IOMUX_PAD_CTRL(EPDC_SDCE0__GPIO2_IO20, WEAK_PULLUP),	/* pin 39 */
+	IOMUX_PAD_CTRL(EPDC_SDCE1__GPIO2_IO21, WEAK_PULLUP),	/* pin 41 */
+	IOMUX_PAD_CTRL(EPDC_SDCE2__GPIO2_IO22, WEAK_PULLUP),	/* pin 43 */
+	IOMUX_PAD_CTRL(EPDC_SDCE3__GPIO2_IO23, WEAK_PULLUP),	/* pin 45 */
+	IOMUX_PAD_CTRL(EPDC_GDSP__GPIO2_IO27, WEAK_PULLUP),	/* pin 47 */
+	IOMUX_PAD_CTRL(EPDC_SDCLK__GPIO2_IO16, WEAK_PULLUP),	/* pin 51 */
+	IOMUX_PAD_CTRL(EPDC_SDLE__GPIO2_IO17, WEAK_PULLUP),	/* pin 53 */
+	IOMUX_PAD_CTRL(EPDC_SDOE__GPIO2_IO18, WEAK_PULLUP),	/* pin 55 */
+	IOMUX_PAD_CTRL(EPDC_PWR_COM__GPIO2_IO30, WEAK_PULLUP),	/* pin 57 */
+	IOMUX_PAD_CTRL(EPDC_PWR_STAT__GPIO2_IO31, WEAK_PULLUP),	/* pin 59 */
+
+	IOMUX_PAD_CTRL(EPDC_BDR0__GPIO2_IO28, WEAK_PULLUP),	/* pin 2 */
+	IOMUX_PAD_CTRL(EPDC_BDR1__GPIO2_IO29, WEAK_PULLUP),	/* pin 4 */
+	IOMUX_PAD_CTRL(EPDC_SDSHR__GPIO2_IO19, WEAK_PULLUP),	/* pin 6 */
+	IOMUX_PAD_CTRL(SD2_RESET_B__GPIO5_IO11, WEAK_PULLUP),	/* pin 10 */
+	IOMUX_PAD_CTRL(SAI1_TX_SYNC__GPIO6_IO14, WEAK_PULLUP),	/* pin 26 */
+	IOMUX_PAD_CTRL(SAI1_TX_BCLK__GPIO6_IO13, WEAK_PULLUP),	/* pin 28 */
+	IOMUX_PAD_CTRL(SD2_CD_B__GPIO5_IO9, WEAK_PULLUP),	/* pin 30 */
+	IOMUX_PAD_CTRL(SAI2_RX_DATA__GPIO6_IO21, WEAK_PULLUP),	/* pin 34 */
+	IOMUX_PAD_CTRL(SAI2_TX_DATA__GPIO6_IO22, WEAK_PULLUP),	/* pin 38 */
+	IOMUX_PAD_CTRL(SAI2_TX_BCLK__GPIO6_IO20, WEAK_PULLUP),	/* pin 40 */
+	IOMUX_PAD_CTRL(SAI2_TX_SYNC__GPIO6_IO19, WEAK_PULLUP),	/* pin 42 */
+
+	/* i2c1 - pmic */
+#define GP_PMIC_INT_B	IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(ECSPI2_MISO__GPIO4_IO22, WEAK_PULLUP),
+
+	/* i2c2 - rv4162 */
+#define GP_RTC			IMX_GPIO_NR(2, 15)
+	IOMUX_PAD_CTRL(EPDC_DATA15__GPIO2_IO15, WEAK_PULLUP),
+
+	/* i2c2a */
+#define GP_I2C2A_EN		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO1_IO07__GPIO1_IO7, WEAK_PULLUP),
+#define GP_MIPI			IMX_GPIO_NR(1, 6)
+	IOMUX_PAD_CTRL(GPIO1_IO06__GPIO1_IO6, WEAK_PULLUP),
+#define GP_MIPI_BACKLIGHT	 IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(GPIO1_IO13__GPIO1_IO13, WEAK_PULLUP),
+
+	/* i2c3 - J9, J2(gpio connector), J20(rgb connector) */
+#define GP_I2C_TOUCH	IMX_GPIO_NR(5, 10)
+//	IOMUX_PAD_CTRL(SD2_WP__GPIO5_IO10, WEAK_PULLUP),
+	/* i2c4 - PCIe, WM8960*/
+
+	/* PCIe */
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(6, 17)
+	IOMUX_PAD_CTRL(SAI1_RX_BCLK__GPIO6_IO17, WEAK_PULLUP),
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(SAI1_RX_SYNC__GPIO6_IO16, WEAK_PULLUP),
+
+	/* PWM1 - rgb */
+#define GP_BACKLIGHT_RGB	IMX_GPIO_NR(1, 1)
+	IOMUX_PAD_CTRL(GPIO1_IO01__GPIO1_IO1, WEAK_PULLDN_OUTPUT),
+//	IOMUX_PAD_CTRL(GPIO1_IO01__PWM1_OUT, WEAK_PULLDN_OUTPUT),
+
+	/* PWM2 */
+	IOMUX_PAD_CTRL(GPIO1_IO09__PWM2_OUT, WEAK_PULLUP),
+
+	/* QSPIA */
+	IOMUX_PAD_CTRL(EPDC_DATA00__QSPI_A_DATA0, QSPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EPDC_DATA01__QSPI_A_DATA1, QSPI_PAD_CTRL),
+#if 1
+	IOMUX_PAD_CTRL(EPDC_DATA02__QSPI_A_DATA2, QSPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EPDC_DATA03__QSPI_A_DATA3, QSPI_PAD_CTRL),
+#else
+#define GP_SPI_nWP		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(EPDC_DATA02__GPIO2_IO2, WEAK_PULLUP),
+#define GP_SPI_nHOLD		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(EPDC_DATA03__GPIO2_IO3, WEAK_PULLUP),
+#endif
+	IOMUX_PAD_CTRL(EPDC_DATA05__QSPI_A_SCLK, QSPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EPDC_DATA06__QSPI_A_SS0_B, QSPI_PAD_CTRL),
+
+	/* SAI1 - wm8960 on i2c4 */
+	IOMUX_PAD_CTRL(ENET1_CRS__SAI1_TX_SYNC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_RX_CLK__SAI1_TX_BCLK, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_TX_CLK__SAI1_RX_DATA0, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_COL__SAI1_TX_DATA0, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SAI1_MCLK__SAI1_MCLK, WEAK_PULLUP),
+
+	/* uart1 */
+	IOMUX_PAD_CTRL(UART1_TX_DATA__UART1_DCE_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART1_RX_DATA__UART1_DCE_RX, UART_PAD_CTRL),
+
+	/* uart2 */
+	IOMUX_PAD_CTRL(UART2_TX_DATA__UART2_DCE_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART2_RX_DATA__UART2_DCE_RX, UART_PAD_CTRL),
+
+	/* uart3 */
+	IOMUX_PAD_CTRL(UART3_TX_DATA__UART3_DCE_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(UART3_RX_DATA__UART3_DCE_RX, UART_PAD_CTRL),
+#define GP_UART3_RS485_TX	IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(EPDC_DATA04__GPIO2_IO4, WEAK_PULLUP),
+
+	/* uart6 - bluetooth */
+	IOMUX_PAD_CTRL(ECSPI1_MOSI__UART6_DCE_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(ECSPI1_SCLK__UART6_DCE_RX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(ECSPI1_MISO__UART6_DCE_RTS, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(ECSPI1_SS0__UART6_DCE_CTS, UART_PAD_CTRL),
+
+#ifdef CONFIG_USB_EHCI_MX7
+	/* usbotg1 */
+	IOMUX_PAD_CTRL(GPIO1_IO04__USB_OTG1_OC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO1_IO05__USB_OTG1_PWR, WEAK_PULLUP),
+//	IOMUX_PAD_CTRL(SD2_WP__USB_OTG1_ID, WEAK_PULLUP),
+#define GP_OTG1_ID	IMX_GPIO_NR(5, 10)
+	IOMUX_PAD_CTRL(SD2_WP__GPIO5_IO10, WEAK_PULLUP),
+
+	/* usbotg2 */
+	IOMUX_PAD_CTRL(UART3_RTS_B__USB_OTG2_OC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(UART3_CTS_B__USB_OTG2_PWR, WEAK_PULLUP),
+#endif
+
+	/* usdhc1 */
+	IOMUX_PAD_CTRL(SD1_CLK__SD1_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_CMD__SD1_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA0__SD1_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA1__SD1_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA2__SD1_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD1_DATA3__SD1_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC1_CD		IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(SD1_CD_B__GPIO5_IO0, USDHC_PAD_CTRL),
+#define GP_PMIC_SD1_VSEL	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO1_IO08__SD1_VSELECT, WEAK_PULLUP),
+
+	/* usdhc2 - murata wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__SD2_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO03__CCM_CLKO2, WEAK_PULLUP),	/* Slow clock */
+#define GP_BT_REG_ON	IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(ECSPI2_SS0__GPIO4_IO23, WEAK_PULLUP),
+#define GP_WL_HOST_WAKE	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(ECSPI2_SCLK__GPIO4_IO20, WEAK_PULLUP),
+#define GP_WL_REG_ON	IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(ECSPI2_MOSI__GPIO4_IO21, WEAK_PULLUP),
+
+	/* usdhc3 - emmc */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA3__SD3_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA4__SD3_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA5__SD3_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA6__SD3_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA7__SD3_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(SD3_RESET_B__GPIO6_IO11, USDHC_PAD_CTRL),
+
+	/* watchdog */
+	IOMUX_PAD_CTRL(GPIO1_IO00__WDOG1_WDOG_B, WEAK_PULLUP_OUTPUT),
+};
+
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(LCD_CLK__LCD_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_ENABLE__LCD_ENABLE, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_HSYNC__LCD_HSYNC, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_VSYNC__LCD_VSYNC, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_RESET__LCD_RESET, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA00__LCD_DATA0, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA01__LCD_DATA1, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA02__LCD_DATA2, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA03__LCD_DATA3, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA04__LCD_DATA4, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA05__LCD_DATA5, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA06__LCD_DATA6, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA07__LCD_DATA7, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA08__LCD_DATA8, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA09__LCD_DATA9, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA10__LCD_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA11__LCD_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA12__LCD_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA13__LCD_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA14__LCD_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA15__LCD_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA16__LCD_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA17__LCD_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA18__LCD_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA19__LCD_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA20__LCD_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA21__LCD_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA22__LCD_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(LCD_DATA23__LCD_DATA23, RGB_PAD_CTRL),
+};
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(LCD_CLK__GPIO3_IO0, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_ENABLE__GPIO3_IO1, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_HSYNC__GPIO3_IO2, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_VSYNC__GPIO3_IO3, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_RESET__GPIO3_IO4, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA00__GPIO3_IO5, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA01__GPIO3_IO6, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA02__GPIO3_IO7, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA03__GPIO3_IO8, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA04__GPIO3_IO9, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA05__GPIO3_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA06__GPIO3_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA07__GPIO3_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA08__GPIO3_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA09__GPIO3_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA10__GPIO3_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA11__GPIO3_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA12__GPIO3_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA13__GPIO3_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA14__GPIO3_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA15__GPIO3_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA16__GPIO3_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA17__GPIO3_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA18__GPIO3_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA19__GPIO3_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA20__GPIO3_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA21__GPIO3_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA22__GPIO3_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(LCD_DATA23__GPIO3_IO28, WEAK_PULLUP),
+};
+
+#ifdef CONFIG_SYS_I2C_MXC
+/* I2C1 for PMIC */
+static const struct i2c_pads_info i2c_pads[] = {
+	I2C_PADS_INFO_ENTRY(I2C1, I2C1_SCL, 4, 8, I2C1_SDA, 4, 9, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, I2C2_SCL, 4, 10, I2C2_SDA, 4, 11, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, I2C3_SCL, 4, 12, I2C3_SDA, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C4, I2C4_SCL, 4, 14, I2C4_SDA, 4, 15, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	4
+#else
+#define i2c_pads	NULL
+#define I2C_BUS_CNT	0
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC1_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC1_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* fusion7 specific touchscreen */
+	VD_FUSION7(LCD, fbp_detect_i2c, 2, 0x10),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_SHARP_WVGA(LCD, NULL, 2, 0x48),
+	VD_DC050WX(LCD, NULL, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+	VD_AT035GT_07ET3(LCD, NULL, 2, 0x48),
+
+	VD_LSA40AT9001(LCD, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_I2C2A_EN,
+	GP_MIPI_BACKLIGHT,
+	GP_PCIE_DISABLE,
+	GP_PCIE_RESET,
+	GP_BACKLIGHT_RGB,
+	GP_UART3_RS485_TX,
+	GP_PMIC_SD1_VSEL,
+	GP_BT_REG_ON,
+	GP_WL_REG_ON,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_CAN_STANDBY,
+#ifdef GP_SPI_nWP
+	GP_SPI_nWP,
+#endif
+#ifdef GP_SPI_nHOLD
+	GP_SPI_nHOLD,
+#endif
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_PMIC_INT_B,
+	GP_RTC,
+	GP_MIPI,
+	GP_I2C_TOUCH,
+	GP_USDHC1_CD,
+	GP_WL_HOST_WAKE,
+	GP_OTG1_ID,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x10, 0x10, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x10, 0x2a, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	return 0;
+}
+#endif
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_USB_EHCI_MX7
+int board_usb_phy_mode(int port)
+{
+	if (port)
+		return USB_INIT_HOST;
+	return gpio_get_value(GP_OTG1_ID) ? USB_INIT_DEVICE : USB_INIT_HOST;
+}
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+	return 0;
+}
+#endif
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/nitrogen7.cfg u-boot-imx6/board/boundary/nitrogen7/nitrogen7.cfg
--- u-boot-2017.07/board/boundary/nitrogen7/nitrogen7.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/nitrogen7.cfg	2018-08-27 21:35:36.950804999 +0300
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* H5TC4G63CFR-PBA */
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : sd
+ */
+#ifdef CONFIG_LINK_QSPI
+BOOT_FROM	qspi
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x30340004 0x4F400005	/* IOMUXC_GPR_GPR1 - enable ocram EPDC function */
+
+DATA 4 0x30391000 0x00000002	/* SRC_DDRC_RCR - assert ddr phy reset */
+DATA 4 0x307a0000 0x01040001	/* DDRC_MSTR - DDR3, burst 8, rank 1 */
+DATA 4 0x307a01a0 0x80400003	/* DDRC_DFIUPD0 - disable auto req */
+DATA 4 0x307a01a4 0x00100020	/* DDRC_DFIUPD1 - min/max delay line recalibration */
+DATA 4 0x307a01a8 0x80100004	/* DDRC_DFIUPD2 - req controls */
+DATA 4 0x307a0064 0x00400046	/* DDRC_RFSHTMG - */
+DATA 4 0x307a0490 0x00000001	/* DDRC_MP_PCTRL_0 - port enable */
+DATA 4 0x307a00d0 0x00020083	/* DDRC_INIT0 - wait 2 clocks after cke high */
+DATA 4 0x307a00d4 0x00690000	/* DDRC_INIT1 - reset width */
+DATA 4 0x307a00dc 0x09300004	/* DDRC_INIT3 - MR0/MR1 reg values */
+DATA 4 0x307a00e0 0x04080000	/* DDRC_INIT4 - MR2/MR3 reg values */
+DATA 4 0x307a00e4 0x00100004	/* DDRC_INIT5 - ZQ cal clks(512)*/
+DATA 4 0x307a00f4 0x0000033f	/* DDRC_RANKCTL - */
+DATA 4 0x307a0100 0x09081109	/* DDRC_DRAMTMG0 - RAS */
+DATA 4 0x307a0104 0x0007020d	/* DDRC_DRAMTMG1 - tRC */
+DATA 4 0x307a0108 0x03040407	/* DDRC_DRAMTMG2 - WL/RL */
+DATA 4 0x307a010c 0x00002006	/* DDRC_DRAMTMG3 - tMRD */
+DATA 4 0x307a0110 0x04020205	/* DDRC_DRAMTMG4 - tRCD, tRRD, tRP */
+DATA 4 0x307a0114 0x03030202	/* DDRC_DRAMTMG5 - tCKE */
+DATA 4 0x307a0120 0x00000803	/* DDRC_DRAMTMG8 - tXS */
+DATA 4 0x307a0180 0x00800020	/* DDRC_ZQCTL0 - 32 NOP clks after short calibration */
+DATA 4 0x307a0184 0x02000100	/* DDRC_ZQCTL1 - short calibration interval */
+DATA 4 0x307a0190 0x02098204	/* DDRC_DFITMG0 - */
+DATA 4 0x307a0194 0x00030303	/* DDRC_DFITMG1 - */
+DATA 4 0x307a0200 0x00000016	/* DDRC_ADDRMAP0 - bit(A28=22+6) used for rank */
+DATA 4 0x307a0204 0x00171717	/* DDRC_ADDRMAP1 - bit(A25,A26,A27) for bank*/
+DATA 4 0x307a0214 0x04040404	/* DDRC_ADDRMAP5 - bit(A10) for row bit 0, bit(A21) for row bit 11 */
+DATA 4 0x307a0218 0x0f040404	/* DDRC_ADDRMAP6 - bit(A22) for row bit 12, A24 for row bit 14 */
+DATA 4 0x307a0240 0x06000604	/* DDRC_ODTCFG - odt clocks */
+DATA 4 0x307a0244 0x00000001	/* DDRC_ODTMAP - enable rank 0 */
+DATA 4 0x30391000 0x00000000	/* SRC_DDRC_RCR - release ddr phy reset  */
+
+DATA 4 0x30790000 0x17420f40	/* DDR_PHY_PHY_CON0 */
+DATA 4 0x30790004 0x10210100	/* DDR_PHY_PHY_CON1 */
+DATA 4 0x30790010 0x00060807	/* DDR_PHY_PHY_CON4 - BL8, tRL */
+DATA 4 0x307900b0 0x1010007e	/* DDR_PHY_MDLL_CON0 */
+DATA 4 0x3079009c 0x00000d6e	/* DDR_PHY_DRVDS_CON0 - drive strength, CA/RAS/CAS/WEN/ODT/RESET/BANK */
+
+DATA 4 0x30790020 0x08080808	/* DDR_PHY_OFFSET_RD_CON0, read DQS calibration */
+DATA 4 0x30790030 0x08080808	/* DDR_PHY_OFFSET_WR_CON0, write DQS calibration */
+DATA 4 0x30790050 0x01000010	/* DDR_PHY_CMD_SDLL_CON0, resync */
+DATA 4 0x30790050 0x00000010	/* DDR_PHY_CMD_SDLL_CON0 */
+
+DATA 4 0x307900c0 0x0e407304	/* DDR_PHY_ZQ_CON0, */
+DATA 4 0x307900c0 0x0e447304	/* DDR_PHY_ZQ_CON0, zq_clk_div_en */
+DATA 4 0x307900c0 0x0e447306	/* DDR_PHY_ZQ_CON0, start calibration */
+
+CHECK_BITS_SET 4 0x307900c4 0x1	/* DDR_PHY_ZQ_CON1, zq calibration done */
+
+DATA 4 0x307900c0 0x0e447304	/* DDR_PHY_ZQ_CON0, zq_clk_div_en*/
+DATA 4 0x307900c0 0x0e407304	/* DDR_PHY_ZQ_CON0 */
+
+DATA 4 0x30384130 0x00000000	/* CCM_CCGR19 - turn off clocks */
+DATA 4 0x30340020 0x00000178	/* IOMUXC_GPR_GPR8 - start DDR PHY */
+DATA 4 0x30384130 0x00000002	/* CCM_CCGR19 - turn on clock */
+DATA 4 0x30790018 0x0000000f	/* DDR_PHY_RODT_CON0  */
+
+CHECK_BITS_SET 4 0x307a0004 0x1	/* DDRC_STAT - wait for normal mode */
+
+DATA 4 0x88780000 0x12345678
+CHECK_BITS_SET 4 0x88780000 0x8
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/qspi-mx25l6405d u-boot-imx6/board/boundary/nitrogen7/qspi-mx25l6405d
--- u-boot-2017.07/board/boundary/nitrogen7/qspi-mx25l6405d	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/qspi-mx25l6405d	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,128 @@
+0			/* 0 dqs_loopback=0 or 1*/ /* The binary file can be built using "./qspi_param.awk qspi-MX25L6405D | xxd -r >qspi-MX25L6405D.nitrogen7" */
+0			/* 4 hold_delay=0 to 3*/
+0			/* 8 reserved */
+0			/* c reserved */
+0			/*10 device_quad_mode_en=1 to enable sending command to SPI device*/
+0			/*14 device_cmd=command to device for enabling Quad I/O mode*/
+03000001		/*18 write_cmd_ipcr=hex value to be written to IPCR register for write cmd of device*/
+02000000		/*1c write_enable_ipcr=hex value to be written to IPCR register for write enable of device*/
+3			/*20 cs_hold_time=0 to 0xF*/
+3			/*24 cs_setup_time=0 to 0xF*/
+8000000			/*28 sflash_A1_size=size in byte(hex)*/
+0			/*2c sflash_A2_size=size in byte(hex)*/
+0			/*30 sflash_B1_size=size in byte(hex)*/
+0			/*34 sflash_B2_size=size in byte(hex)*/
+5			/*38 sclk_freq=0 to 6, 0:18Mhz, 1:49Mhz, 2:55Mhz, 3:60Mhz, 4:66Mhz, 5:76MHz, 6:99Mhz, max 80 MHz*/
+0			/*3c busy_bit_offset=bit position of device BUSY in device status register*/
+1			/*40 sflash_type=1 (Single), 2 (Dual), 4 (Quad mode of operation)*/
+0			/*44 sflash_port=0 or 1 (Port B used)*/
+0			/*48 ddr_mode_enable=0 or 1*/
+0			/*4c dqs_enable=0 or 1*/
+0			/*50 parallel_mode_enable=0 or 1*/
+0			/*54 portA_cs1=0 or 1*/
+0			/*58 portB_cs1=0 or 1*/
+0			/*5c fsphs=0 (Full Speed Phase sampling at non-inverted clock) or 1 (sampling at inverted clock)*/
+0			/*60 fsdly=0 (Full Speed Delay One clk delay) or 1 (two clk cycle delay)*/
+0			/*64 ddrsmp=0 to 7 (sampling point for incoming data in DDR mode)*/
+0818040b		/*68 lut[0] QSPI_CMD_FAST_READ */
+1c040c08		/*6c lut[1] */
+2400			/*70 lut[2] */
+0			/*74 lut[3] */
+1c010405		/*78 lut[4] QSPI_CMD_RDSR(Read status register 1) */
+2400			/*7c lut[5] */
+0			/*80 lut[6] */
+0			/*84 lut[7] */
+24000406		/*88 lut[8] QSPI_CMD_WREN(write enable) */
+0			/*8c lut[9] */
+0			/*90 lut[10] */
+0			/*94 lut[11] */
+20010401		/*98 lut[12] QSPI_CMD_WRITE_STATUS(Write status register 1) */
+2400			/*9c lut[13] */
+0			/*a0 lut[14] */
+0			/*a4 lut[15] */
+0			/*a8 lut[16] */
+0			/*ac lut[17] */
+0			/*b0 lut[18] */
+0			/*b4 lut[19] */
+0			/*b8 lut[20] */
+0			/*bc lut[21] */
+0			/*c0 lut[22] */
+0			/*c4 lut[23] */
+0			/*c8 lut[24] */
+0			/*cc lut[25] */
+0			/*d0 lut[26] */
+0			/*d4 lut[27] */
+0			/*d8 lut[28] */
+0			/*dc lut[29] */
+0			/*e0 lut[30] */
+0			/*e4 lut[31] */
+0			/*e8 lut[32] */
+0			/*ec lut[33] */
+0			/*f0 lut[34] */
+0			/*f4 lut[35] */
+0			/*f8 lut[36] */
+0			/*fc lut[37] */
+0			/*100 lut[38] */
+0			/*104 lut[39] */
+0			/*108 lut[40] */
+0			/*10c lut[41] */
+0			/*110 lut[42] */
+0			/*114 lut[43] */
+0			/*118 lut[44] */
+0			/*11c lut[45] */
+0			/*120 lut[46] */
+0			/*124 lut[47] */
+0			/*128 lut[48] */
+0			/*12c lut[49] */
+0			/*130 lut[50] */
+0			/*134 lut[51] */
+0			/*138 lut[52] */
+0			/*13c lut[53] */
+0			/*140 lut[54] */
+0			/*144 lut[55] */
+0			/*148 lut[56] */
+0			/*14c lut[57] */
+0			/*150 lut[58] */
+0			/*154 lut[59] */
+0			/*158 lut[60] */
+0			/*15c lut[61] */
+0			/*160 lut[62] */
+0			/*164 lut[63] */
+1000001			/*168 read_status_ipcr=hex value to be written to IPCR register for reading status reg of device */
+0			/*16c enable_dqs_phase=0 or 1 */
+0			/*170 Not used */
+0			/*174 */
+0			/*178 */
+0			/*17c */
+0			/*180 */
+0			/*184 */
+0			/*188 */
+0			/*18c */
+0			/*190 */
+0			/*194 DQS pin pad setting override */
+0			/*198 SCLK pin pad setting override */
+0			/*19c DATA pins pad setting override */
+0			/*1a0 CS pins pad setting override */
+0			/*1a4 0: dqs loopback from pad/1: dqs loopback internally */
+0			/*1a8 dqs phase selection */
+0			/*1ac dqs fa delay chain selection */
+0			/*1b0 dqs fb delay chain selection */
+0			/*1b4 sclk fa delay chain selection */
+0			/*1b8 sclk fb delay chain selection */
+0			/*1bc */
+0			/*1c0 reserve[0] */
+0			/*1c4 reserve[1] */
+0			/*1c8 reserve[2] */
+0			/*1cc reserve[3] */
+0			/*1d0 reserve[4] */
+0			/*1d4 reserve[5] */
+0			/*1d8 reserve[6] */
+0			/*1dc reserve[7] */
+0			/*1e0 reserve[8] */
+0			/*1e4 reserve[9] */
+0			/*1e8 reserve[10] */
+0			/*1ec reserve[11] */
+0			/*1f0 reserve[12] */
+0			/*1f4 reserve[13] */
+0			/*1f8 reserve[14] */
+c0ffee01		/*1fc tag, QSPI configuration tag, should be 0xc0ffee01 */
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/qspi_param.awk u-boot-imx6/board/boundary/nitrogen7/qspi_param.awk
--- u-boot-2017.07/board/boundary/nitrogen7/qspi_param.awk	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/qspi_param.awk	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,12 @@
+#!/usr/bin/awk -f
+{
+	s="00000000"$1;
+	l=length(s);
+	if(!((NR-1)%4))
+		printf "%03x ",(NR-1)*4;
+	for(i=l-1;i>l-8;i-=2)
+		printf " %s",substr(s,i,2);
+	if(!(NR%4))
+		printf "\n";
+}
+
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/qspi-sst25vf016b u-boot-imx6/board/boundary/nitrogen7/qspi-sst25vf016b
--- u-boot-2017.07/board/boundary/nitrogen7/qspi-sst25vf016b	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/qspi-sst25vf016b	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,128 @@
+0			/* 0 dqs_loopback=0 or 1*/ /* The binary file can be built using "./qspi_param.awk qspi-SST25VF016B | xxd -r >qspi-SST25VF016B.nitrogen7" */
+0			/* 4 hold_delay=0 to 3*/
+0			/* 8 reserved */
+0			/* c reserved */
+0			/*10 device_quad_mode_en=1 to enable sending command to SPI device*/
+0			/*14 device_cmd=command to device for enabling Quad I/O mode*/
+03000002		/*18 write_cmd_ipcr=hex value to be written to IPCR register for write cmd of device*/
+02000000		/*1c write_enable_ipcr=hex value to be written to IPCR register for write enable of device*/
+3			/*20 cs_hold_time=0 to 0xF*/
+3			/*24 cs_setup_time=0 to 0xF*/
+1000000			/*28 sflash_A1_size=size in byte(hex)*/
+0			/*2c sflash_A2_size=size in byte(hex)*/
+0			/*30 sflash_B1_size=size in byte(hex)*/
+0			/*34 sflash_B2_size=size in byte(hex)*/
+5			/*38 sclk_freq=0 to 6, 0:18Mhz, 1:49Mhz, 2:55Mhz, 3:60Mhz, 4:66Mhz, 5:76MHz, 6:99Mhz, max 80 MHz*/
+0			/*3c busy_bit_offset=bit position of device BUSY in device status register*/
+1			/*40 sflash_type=1 (Single), 2 (Dual), 4 (Quad mode of operation)*/
+0			/*44 sflash_port=0 or 1 (Port B used)*/
+0			/*48 ddr_mode_enable=0 or 1*/
+0			/*4c dqs_enable=0 or 1*/
+0			/*50 parallel_mode_enable=0 or 1*/
+0			/*54 portA_cs1=0 or 1*/
+0			/*58 portB_cs1=0 or 1*/
+0			/*5c fsphs=0 (Full Speed Phase sampling at non-inverted clock) or 1 (sampling at inverted clock)*/
+0			/*60 fsdly=0 (Full Speed Delay One clk delay) or 1 (two clk cycle delay)*/
+0			/*64 ddrsmp=0 to 7 (sampling point for incoming data in DDR mode)*/
+0818040b		/*68 lut[0] QSPI_CMD_FAST_READ */
+1c040c08		/*6c lut[1] */
+2400			/*70 lut[2] */
+0			/*74 lut[3] */
+1c010405		/*78 lut[4] QSPI_CMD_RDSR(Read status register 1) */
+2400			/*7c lut[5] */
+0			/*80 lut[6] */
+0			/*84 lut[7] */
+24000406		/*88 lut[8] QSPI_CMD_WREN(write enable) */
+0			/*8c lut[9] */
+0			/*90 lut[10] */
+0			/*94 lut[11] */
+20010401		/*98 lut[12] QSPI_CMD_WRITE_STATUS(Write status register 1) */
+2400			/*9c lut[13] */
+0			/*a0 lut[14] */
+0			/*a4 lut[15] */
+0			/*a8 lut[16] */
+0			/*ac lut[17] */
+0			/*b0 lut[18] */
+0			/*b4 lut[19] */
+0			/*b8 lut[20] */
+0			/*bc lut[21] */
+0			/*c0 lut[22] */
+0			/*c4 lut[23] */
+0			/*c8 lut[24] */
+0			/*cc lut[25] */
+0			/*d0 lut[26] */
+0			/*d4 lut[27] */
+0			/*d8 lut[28] */
+0			/*dc lut[29] */
+0			/*e0 lut[30] */
+0			/*e4 lut[31] */
+0			/*e8 lut[32] */
+0			/*ec lut[33] */
+0			/*f0 lut[34] */
+0			/*f4 lut[35] */
+0			/*f8 lut[36] */
+0			/*fc lut[37] */
+0			/*100 lut[38] */
+0			/*104 lut[39] */
+0			/*108 lut[40] */
+0			/*10c lut[41] */
+0			/*110 lut[42] */
+0			/*114 lut[43] */
+0			/*118 lut[44] */
+0			/*11c lut[45] */
+0			/*120 lut[46] */
+0			/*124 lut[47] */
+0			/*128 lut[48] */
+0			/*12c lut[49] */
+0			/*130 lut[50] */
+0			/*134 lut[51] */
+0			/*138 lut[52] */
+0			/*13c lut[53] */
+0			/*140 lut[54] */
+0			/*144 lut[55] */
+0			/*148 lut[56] */
+0			/*14c lut[57] */
+0			/*150 lut[58] */
+0			/*154 lut[59] */
+0			/*158 lut[60] */
+0			/*15c lut[61] */
+0			/*160 lut[62] */
+0			/*164 lut[63] */
+1000001			/*168 read_status_ipcr=hex value to be written to IPCR register for reading status reg of device */
+0			/*16c enable_dqs_phase=0 or 1 */
+0			/*170 Not used */
+0			/*174 */
+0			/*178 */
+0			/*17c */
+0			/*180 */
+0			/*184 */
+0			/*188 */
+0			/*18c */
+0			/*190 */
+0			/*194 DQS pin pad setting override */
+0			/*198 SCLK pin pad setting override */
+0			/*19c DATA pins pad setting override */
+0			/*1a0 CS pins pad setting override */
+0			/*1a4 0: dqs loopback from pad/1: dqs loopback internally */
+0			/*1a8 dqs phase selection */
+0			/*1ac dqs fa delay chain selection */
+0			/*1b0 dqs fb delay chain selection */
+0			/*1b4 sclk fa delay chain selection */
+0			/*1b8 sclk fb delay chain selection */
+0			/*1bc */
+0			/*1c0 reserve[0] */
+0			/*1c4 reserve[1] */
+0			/*1c8 reserve[2] */
+0			/*1cc reserve[3] */
+0			/*1d0 reserve[4] */
+0			/*1d4 reserve[5] */
+0			/*1d8 reserve[6] */
+0			/*1dc reserve[7] */
+0			/*1e0 reserve[8] */
+0			/*1e4 reserve[9] */
+0			/*1e8 reserve[10] */
+0			/*1ec reserve[11] */
+0			/*1f0 reserve[12] */
+0			/*1f4 reserve[13] */
+0			/*1f8 reserve[14] */
+c0ffee01		/*1fc tag, QSPI configuration tag, should be 0xc0ffee01 */
diff -Nru u-boot-2017.07/board/boundary/nitrogen7/qspi-w25q128bv u-boot-imx6/board/boundary/nitrogen7/qspi-w25q128bv
--- u-boot-2017.07/board/boundary/nitrogen7/qspi-w25q128bv	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nitrogen7/qspi-w25q128bv	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,128 @@
+0			/* 0 dqs_loopback=0 or 1*/ /* The binary file can be built using "./qspi_param.awk qspi-W25Q128BV | xxd -r >qspi-W25Q128BV.nitrogen7" */
+0			/* 4 hold_delay=0 to 3*/
+0			/* 8 reserved */
+0			/* c reserved */
+1			/*10 device_quad_mode_en=1 to enable sending command to SPI device*/
+0200			/*14 device_cmd=command to device for enabling Quad I/O mode(status reg1 & 2 write) */
+03000002		/*18 write_cmd_ipcr=hex value to be written to IPCR register for write cmd of device*/
+02000000		/*1c write_enable_ipcr=hex value to be written to IPCR register for write enable of device*/
+3			/*20 cs_hold_time=0 to 0xF*/
+3			/*24 cs_setup_time=0 to 0xF*/
+1000000			/*28 sflash_A1_size=size in byte(hex)*/
+0			/*2c sflash_A2_size=size in byte(hex)*/
+0			/*30 sflash_B1_size=size in byte(hex)*/
+0			/*34 sflash_B2_size=size in byte(hex)*/
+6			/*38 sclk_freq=0 to 6*/
+0			/*3c busy_bit_offset=bit position of device BUSY in device status register*/
+4			/*40 sflash_type=1 (Single), 2 (Dual), 4 (Quad mode of operation)*/
+0			/*44 sflash_port=0 or 1 (Port B used)*/
+0			/*48 ddr_mode_enable=0 or 1*/
+0			/*4c dqs_enable=0 or 1*/
+0			/*50 parallel_mode_enable=0 or 1*/
+0			/*54 portA_cs1=0 or 1*/
+0			/*58 portB_cs1=0 or 1*/
+0			/*5c fsphs=0 (Full Speed Phase sampling at non-inverted clock) or 1 (sampling at inverted clock)*/
+0			/*60 fsdly=0 (Full Speed Delay One clk delay) or 1 (two clk cycle delay)*/
+0			/*64 ddrsmp=0 to 7 (sampling point for incoming data in DDR mode)*/
+0a1804eb		/*68 lut[0] Fast Read Quad I/O, needs status reg write to enable cmd */
+0e041200		/*6c lut[1] */
+24001e04		/*70 lut[2] */
+0			/*74 lut[3] */
+1c010405		/*78 lut[4] QSPI_CMD_RDSR(Read status register 1) */
+2400			/*7c lut[5] */
+0			/*80 lut[6] */
+0			/*84 lut[7] */
+24000406		/*88 lut[8] QSPI_CMD_WREN(write enable) */
+0			/*8c lut[9] */
+0			/*90 lut[10] */
+0			/*94 lut[11] */
+20010401		/*98 lut[12] QSPI_CMD_WRITE_STATUS(Write status register 1) */
+2400			/*9c lut[13] */
+0			/*a0 lut[14] */
+0			/*a4 lut[15] */
+1c010435		/*a8 lut[16] QSPI_CMD_RDSR2(Read status register 2) */
+2400			/*ac lut[17] */
+0			/*b0 lut[18] */
+0			/*b4 lut[19] */
+0			/*b8 lut[20] */
+0			/*bc lut[21] */
+0			/*c0 lut[22] */
+0			/*c4 lut[23] */
+0			/*c8 lut[24] */
+0			/*cc lut[25] */
+0			/*d0 lut[26] */
+0			/*d4 lut[27] */
+0			/*d8 lut[28] */
+0			/*dc lut[29] */
+0			/*e0 lut[30] */
+0			/*e4 lut[31] */
+0			/*e8 lut[32] */
+0			/*ec lut[33] */
+0			/*f0 lut[34] */
+0			/*f4 lut[35] */
+0			/*f8 lut[36] */
+0			/*fc lut[37] */
+0			/*100 lut[38] */
+0			/*104 lut[39] */
+0			/*108 lut[40] */
+0			/*10c lut[41] */
+0			/*110 lut[42] */
+0			/*114 lut[43] */
+0			/*118 lut[44] */
+0			/*11c lut[45] */
+0			/*120 lut[46] */
+0			/*124 lut[47] */
+0			/*128 lut[48] */
+0			/*12c lut[49] */
+0			/*130 lut[50] */
+0			/*134 lut[51] */
+0			/*138 lut[52] */
+0			/*13c lut[53] */
+0			/*140 lut[54] */
+0			/*144 lut[55] */
+0			/*148 lut[56] */
+0			/*14c lut[57] */
+0			/*150 lut[58] */
+0			/*154 lut[59] */
+0			/*158 lut[60] */
+0			/*15c lut[61] */
+0			/*160 lut[62] */
+0			/*164 lut[63] */
+1000001			/*168 read_status_ipcr=hex value to be written to IPCR register for reading status reg of device */
+0			/*16c enable_dqs_phase=0 or 1 */
+0			/*170 Not used */
+0			/*174 */
+0			/*178 */
+0			/*17c */
+0			/*180 */
+0			/*184 */
+0			/*188 */
+0			/*18c */
+0			/*190 */
+0			/*194 DQS pin pad setting override */
+0			/*198 SCLK pin pad setting override */
+0			/*19c DATA pins pad setting override */
+0			/*1a0 CS pins pad setting override */
+0			/*1a4 0: dqs loopback from pad/1: dqs loopback internally */
+0			/*1a8 dqs phase selection */
+0			/*1ac dqs fa delay chain selection */
+0			/*1b0 dqs fb delay chain selection */
+0			/*1b4 sclk fa delay chain selection */
+0			/*1b8 sclk fb delay chain selection */
+0			/*1bc */
+0			/*1c0 reserve[0] */
+0			/*1c4 reserve[1] */
+0			/*1c8 reserve[2] */
+0			/*1cc reserve[3] */
+0			/*1d0 reserve[4] */
+0			/*1d4 reserve[5] */
+0			/*1d8 reserve[6] */
+0			/*1dc reserve[7] */
+0			/*1e0 reserve[8] */
+0			/*1e4 reserve[9] */
+0			/*1e8 reserve[10] */
+0			/*1ec reserve[11] */
+0			/*1f0 reserve[12] */
+0			/*1f4 reserve[13] */
+0			/*1f8 reserve[14] */
+c0ffee01		/*1fc tag, QSPI configuration tag, should be 0xc0ffee01 */
diff -Nru u-boot-2017.07/board/boundary/nw/Kconfig u-boot-imx6/board/boundary/nw/Kconfig
--- u-boot-2017.07/board/boundary/nw/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nw/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_NW
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "nw"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "nw"
+
+config ENV_BD_ADDR
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/nw/MAINTAINERS u-boot-imx6/board/boundary/nw/MAINTAINERS
--- u-boot-2017.07/board/boundary/nw/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nw/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,8 @@
+NW BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/nw/
+F:	include/configs/nw.h
+F:	configs/nw_defconfig
+F:	configs/nw2_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/nw/Makefile u-boot-imx6/board/boundary/nw/Makefile
--- u-boot-2017.07/board/boundary/nw/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nw/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := nw.o
diff -Nru u-boot-2017.07/board/boundary/nw/nw.c u-boot-imx6/board/boundary/nw/nw.c
--- u-boot-2017.07/board/boundary/nw/nw.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nw/nw.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static iomux_v3_cfg_t const init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+#define GP_BT_RFKILL_SHUTDOWN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS		IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+#define GPIRQ_BT		IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+#define GP_BT_WAKE		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, WEAK_PULLUP),
+
+	/* i2c1_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG	IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for GB863021 bluetooth */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, USDHC_PAD_CTRL), /* USBOTG ID pin */
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - GB863021 wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+#ifndef CONFIG_REV2
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#else
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP), /* RESET */
+#endif
+
+	/* wlan wifi GB863021 */
+#define GPIRQ_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GPIRQ_WL_CLK_REQ	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, RTC */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 hdmi */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	2
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+#if !defined(CONFIG_REV2)
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+#else
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+#endif
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+static void setup_spi(void)
+{
+	gpio_direction_output(CONFIG_SF_DEFAULT_CS, 1);
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+#ifdef CONFIG_REV2
+	GP_EMMC_RESET,
+#endif
+	/* Disable WiFi/BT */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+	GP_BT_RFKILL_SHUTDOWN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_RTC_RV4162,
+#ifndef CONFIG_REV2
+	GP_USDHC3_CD,
+#endif
+	GPIRQ_BT,
+	GPIRQ_WL,
+	GPIRQ_WL_CLK_REQ,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/nw/nw.cfg u-boot-imx6/board/boundary/nw/nw.cfg
--- u-boot-2017.07/board/boundary/nw/nw.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/nw/nw.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x430e0320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03040303
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4b46494a
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x383c4843
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001c0018
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001e001d
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* BOM removed, not supported */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/oc/6x_bootscript.txt u-boot-imx6/board/boundary/oc/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/oc/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/6x_bootscript.txt	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,34 @@
+setenv bootargs enable_wait_mode=off
+setenv nextcon 0;
+
+if test xXGA = "x$panel" ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB24
+else
+	if test xLDB-WXGA = "x$panel" ; then
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1280x800MR@60,if=RGB666
+	else
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,OC-VGA,if=RGB24
+	fi
+fi
+
+setenv nextcon 1
+setenv fbmem "fbmem=10M";
+if hdmidet ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem $fbmem,28M;
+	setexpr nextcon $nextcon + 1;
+else
+	echo "------ no HDMI monitor";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs $bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 ;
+${fs}load ${dtype} ${disk}:1 10800000 /boot/uImage
+&& ${fs}load ${dtype} ${disk}:1 12800000 /boot/uramdisk.img
+&& bootm 10800000 12800000 ;
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/oc/6x_bootscript-yocto.txt u-boot-imx6/board/boundary/oc/6x_bootscript-yocto.txt
--- u-boot-2017.07/board/boundary/oc/6x_bootscript-yocto.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/6x_bootscript-yocto.txt	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,126 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+setenv bootargs enable_wait_mode=off
+setenv nextcon 0;
+
+i2c dev 1 ;
+if i2c probe 0x50 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+i2c dev 2
+if i2c probe 0x04 ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LDB-XGA,if=RGB666
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no Freescale display";
+fi
+
+if i2c probe 0x38 ; then
+	if itest.s "xLDB-WXGA" == "x$panel"; then
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1280x800MR@60,if=RGB666
+		screenres=1280,800
+	else
+		setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,1024x600M@60,if=RGB666
+		screenres=1024,600
+	fi
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+	setenv bootargs $bootargs ft5x06.screenres=$screenres
+	if itest.s "x" -ne "x$calibration" ; then
+		setenv bootargs $bootargs ft5x06_ts.calibration=$calibration
+	fi
+else
+	echo "------ no ft5x06 touch controller";
+fi
+
+if i2c probe 0x48 ; then
+	if itest.s "xqvga" == "x$panel" ; then
+		display="320x240MR@60,if=RGB24";
+	else
+		display="CLAA-WVGA,if=RGB666";
+	fi
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=lcd,$display
+	if test "0" -eq $nextcon; then
+		setenv fbmem "fbmem=10M";
+	else
+		setenv fbmem ${fbmem},10M
+	fi
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no 800x480 display";
+fi
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+if test "sata" = "${dtype}" ; then
+	setenv bootargs "$bootargs root=/dev/sda$bootpart" ;
+else
+	setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+fi
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+	setenv fdt_addr 0x11000000
+	setenv fdt_high 0xffffffff
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/oc/Kconfig u-boot-imx6/board/boundary/oc/Kconfig
--- u-boot-2017.07/board/boundary/oc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,20 @@
+if TARGET_OC
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "oc"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "oc"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/oc/MAINTAINERS u-boot-imx6/board/boundary/oc/MAINTAINERS
--- u-boot-2017.07/board/boundary/oc/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+OC BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/oc/
+F:	include/configs/oc.h
+F:	configs/ocquad_defconfig
+F:	configs/ocsolo_defconfig
+F:	configs/ocsolo1g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/oc/Makefile u-boot-imx6/board/boundary/oc/Makefile
--- u-boot-2017.07/board/boundary/oc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := oc.o
diff -Nru u-boot-2017.07/board/boundary/oc/oc.c u-boot-imx6/board/boundary/oc/oc.c
--- u-boot-2017.07/board/boundary/oc/oc.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/oc.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static iomux_v3_cfg_t const init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, OUTPUT_40OHM),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+
+	/* i2c1mux */
+#define GP_I2C1MUXA_EN	IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* CAM */
+#define GP_I2C1MUXB_EN	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),	/* RTC */
+
+	/* WiFi/BT pads */
+#define GPIRQ_WL1271_WL	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WL_ENABLE	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM),
+
+	/* PWM on LVDS connector: J6 */
+#define GP_LVDS_BACKLIGHT IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+	/* Backlight on LVDS connector: J6 */
+#define GP_LVDS_BACKLIGHT_EN IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, OUTPUT_40OHM),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USB */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USDHC2 - wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+int board_ehci_power(int port, int on)
+{
+       if (port)
+               return 0;
+       gpio_set_value(GP_REG_USBOTG, on);
+       return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS_BACKLIGHT, enable);
+	gpio_direction_output(GP_LVDS_BACKLIGHT_EN, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+
+	VD_VGA(LVDS, NULL, 0, 0x00),
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_I2C1MUXA_EN,		/* i2cmux cam enable */
+	GP_WIFI_WL_ENABLE,
+	GP_BT_RFKILL_RESET,
+	GP_REG_WLAN_EN,
+	GP_USB_HUB_RESET,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_I2C1MUXB_EN,		/* i2cmux rtc enable*/
+};
+
+static const unsigned short gpios_in[] = {
+	GP_LVDS_BACKLIGHT,
+	GP_LVDS_BACKLIGHT_EN,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/oc/oc_q1g.cfg u-boot-imx6/board/boundary/oc/oc_q1g.cfg
--- u-boot-2017.07/board/boundary/oc/oc_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/oc_q1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/oc/oc_s1g.cfg u-boot-imx6/board/boundary/oc/oc_s1g.cfg
--- u-boot-2017.07/board/boundary/oc/oc_s1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/oc_s1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* BOM removed, not supported */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/oc/oc_s512m.cfg u-boot-imx6/board/boundary/oc/oc_s512m.cfg
--- u-boot-2017.07/board/boundary/oc/oc_s512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/oc/oc_s512m.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* BOM removed, not supported */
+#include "../common/mx6/800mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/per/Kconfig u-boot-imx6/board/boundary/per/Kconfig
--- u-boot-2017.07/board/boundary/per/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,20 @@
+if TARGET_PER
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "per"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "per"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/per/linux_pads.sh u-boot-imx6/board/boundary/per/linux_pads.sh
--- u-boot-2017.07/board/boundary/per/linux_pads.sh	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/linux_pads.sh	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,13 @@
+#!/bin/sh
+echo $1
+echo 's/GPIO([1-7])_IO0([0-9])/GPIO_\\1_\\2/' >t.sed
+echo 's/GPIO([1-7])_IO([1-3][0-9])/GPIO_\\1_\\2/' >>t.sed
+echo 's/GPIO_1__USB_OTG_ID/GPIO_1__USBOTG_ID/' >>t.sed
+echo 's/KEY_COL4__USB_OTG_OC/KEY_COL4__USBOH3_USBOTG_OC/' >>t.sed
+echo 's/EIM_D30__USB_H1_OC/EIM_D30__USBOH3_USBH1_OC/' >>t.sed
+echo 's/UART([1-6]_[RT]X)_DATA/UART\\1D/' >>t.sed
+echo 's/__RGMII_/__ENET_RGMII_/' >>t.sed
+echo 's/(IPU[12]_CSI[01]_D)ATA0/\\1_/' >>t.sed
+echo 's/(IPU[12]_CSI[01]_D)ATA([1-9])/\\1_\\2/' >>t.sed
+echo 's/__AUD/__AUDMUX_AUD/' >>t.sed
+sed -r -f t.sed $1 >$1.linux_pads
diff -Nru u-boot-2017.07/board/boundary/per/MAINTAINERS u-boot-imx6/board/boundary/per/MAINTAINERS
--- u-boot-2017.07/board/boundary/per/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+PER BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/per/
+F:	include/configs/per.h
+F:	configs/per_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/per/Makefile u-boot-imx6/board/boundary/per/Makefile
--- u-boot-2017.07/board/boundary/per/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := per.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
diff -Nru u-boot-2017.07/board/boundary/per/per.c u-boot-imx6/board/boundary/per/per.c
--- u-boot-2017.07/board/boundary/per/per.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/per.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,513 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define PADCFG_INPUT		(PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+#define PADCFG_INPUT_L		(PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+#define PADCFG_INPUT_DN		(PADCFG_INPUT | PAD_CTL_PUS_100K_DOWN)
+#define PADCFG_INPUT_UP		(PADCFG_INPUT | PAD_CTL_PUS_100K_UP)
+#define PADCFG_INPUT_L_UP	(PADCFG_INPUT_L | PAD_CTL_PUS_100K_UP)
+
+#define AUD_PAD_CTRL	(PADCFG_INPUT_L_UP | PAD_CTL_SRE_FAST)
+#define CSI_PAD_CTRL	(PADCFG_INPUT_UP | PAD_CTL_SRE_FAST)
+#define UART_PAD_CTRL	(PADCFG_INPUT_UP | PAD_CTL_SRE_FAST)
+
+#define PADCFG_FLOAT_IRQ (PADCFG_INPUT)
+
+#define USDHC_PAD_CTRL_50MHZ (PAD_CTL_PUS_47K_UP |		\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define OTGID_PAD_CTRL		USDHC_PAD_CTRL_50MHZ
+#define HDMICEC_PAD_CTRL	(PADCFG_INPUT_UP | PAD_CTL_ODE | PAD_CTL_SRE_SLOW)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPDIF_PAD_CTRL	WEAK_PULLUP
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Audio - GS2971, WM5102 */
+	IOMUX_PAD_CTRL(DISP0_DAT23__AUD4_RXD, AUD_PAD_CTRL),	/* pin J3 - AOUT1/2 */
+	IOMUX_PAD_CTRL(SD2_CMD__AUD4_RXC, AUD_PAD_CTRL),		/* pin J4 - ACLK*/
+	IOMUX_PAD_CTRL(DISP0_DAT18__AUD4_RXFS, AUD_PAD_CTRL),	/* pin H4 - WCLK*/
+
+	/* Audio - TC3587 mipi hdmi input */
+	IOMUX_PAD_CTRL(DISP0_DAT13__AUD5_RXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__AUD5_RXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__AUD5_RXD, AUD_PAD_CTRL),
+
+	/* Audio - WM5102 */
+	IOMUX_PAD_CTRL(DI0_PIN2__AUD6_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN3__AUD6_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN4__AUD6_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__AUD6_TXC, AUD_PAD_CTRL),
+
+	/* WM5102 */
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* MCLK2 */
+	IOMUX_PAD_CTRL(NANDF_CS2__CCM_CLKO2, OUTPUT_40OHM),	/* MCLK1 */
+#define GP_WM5102_RESET		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, OUTPUT_40OHM),
+#define GPIRQ_WM5102		IMX_GPIO_NR(5, 10)
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+#define GP_WM5102_LDO_EN	IMX_GPIO_NR(5, 11)
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, OUTPUT_40OHM),
+
+	/* camera - video0 - ADV7180 - I2C3, crystal 28.636 MHz */
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),	/* Hsync */
+	IOMUX_PAD_CTRL(CSI0_VSYNC__GPIO5_IO21, WEAK_PULLUP),	/* Vsync */
+#define GP_ADV7180_RESET	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, OUTPUT_40OHM),
+#define GPIRQ_ADV7180		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* camera - video1 - TC3587 mipi hdmi input */
+#define GP_TC3587_VIDEO_DETECT	IMX_GPIO_NR(3, 23)
+	IOMUX_PAD_CTRL(EIM_D23__GPIO3_IO23, WEAK_PULLUP),	/* J13 Pin 1 - Video detect */
+#define GP_TC3587_HPD_IN	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),		/* J13, pin 20 */
+#define GP_TC3587_RESET		IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, OUTPUT_40OHM),
+#define GPIRQ_TC3587		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, PADCFG_FLOAT_IRQ),
+
+	/* camera - video2 - GS2971(SDI) on CSI1 */
+#if defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
+	/* Dualite/Solo doesn't have IPU2 */
+	IOMUX_PAD_CTRL(EIM_A24__IPU1_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU1_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU1_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU1_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU1_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU1_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU1_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU1_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU1_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU1_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU1_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU1_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU1_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU1_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU1_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU1_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU1_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU1_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU1_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA9__IPU1_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU1_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] */
+#else
+	IOMUX_PAD_CTRL(EIM_A24__IPU2_CSI1_DATA19, CSI_PAD_CTRL),	/* GPIO2[30] */
+	IOMUX_PAD_CTRL(EIM_A23__IPU2_CSI1_DATA18, CSI_PAD_CTRL),	/* GPIO6[6] */
+	IOMUX_PAD_CTRL(EIM_A22__IPU2_CSI1_DATA17, CSI_PAD_CTRL),	/* GPIO2[16] */
+	IOMUX_PAD_CTRL(EIM_A21__IPU2_CSI1_DATA16, CSI_PAD_CTRL),	/* GPIO2[17] */
+	IOMUX_PAD_CTRL(EIM_A20__IPU2_CSI1_DATA15, CSI_PAD_CTRL),	/* GPIO2[18] */
+	IOMUX_PAD_CTRL(EIM_A19__IPU2_CSI1_DATA14, CSI_PAD_CTRL),	/* GPIO2[19] */
+	IOMUX_PAD_CTRL(EIM_A18__IPU2_CSI1_DATA13, CSI_PAD_CTRL),	/* GPIO2[20] */
+	IOMUX_PAD_CTRL(EIM_A17__IPU2_CSI1_DATA12, CSI_PAD_CTRL),	/* GPIO2[21] */
+	IOMUX_PAD_CTRL(EIM_EB0__IPU2_CSI1_DATA11, CSI_PAD_CTRL),	/* GPIO2[28] */
+	IOMUX_PAD_CTRL(EIM_EB1__IPU2_CSI1_DATA10, CSI_PAD_CTRL),	/* GPIO2[29] */
+	IOMUX_PAD_CTRL(EIM_DA0__IPU2_CSI1_DATA09, CSI_PAD_CTRL),	/* GPIO3[0] */
+	IOMUX_PAD_CTRL(EIM_DA1__IPU2_CSI1_DATA08, CSI_PAD_CTRL),	/* GPIO3[1] */
+	IOMUX_PAD_CTRL(EIM_DA2__IPU2_CSI1_DATA07, CSI_PAD_CTRL),	/* GPIO3[2] */
+	IOMUX_PAD_CTRL(EIM_DA3__IPU2_CSI1_DATA06, CSI_PAD_CTRL),	/* GPIO3[3] */
+	IOMUX_PAD_CTRL(EIM_DA4__IPU2_CSI1_DATA05, CSI_PAD_CTRL),	/* GPIO3[4] */
+	IOMUX_PAD_CTRL(EIM_DA5__IPU2_CSI1_DATA04, CSI_PAD_CTRL),	/* GPIO3[5] */
+	IOMUX_PAD_CTRL(EIM_DA6__IPU2_CSI1_DATA03, CSI_PAD_CTRL),	/* GPIO3[6] */
+	IOMUX_PAD_CTRL(EIM_DA7__IPU2_CSI1_DATA02, CSI_PAD_CTRL),	/* GPIO3[7] */
+	IOMUX_PAD_CTRL(EIM_DA8__IPU2_CSI1_DATA01, CSI_PAD_CTRL),	/* GPIO3[8] */
+	IOMUX_PAD_CTRL(EIM_DA9__IPU2_CSI1_DATA00, CSI_PAD_CTRL),	/* GPIO3[9] */
+	IOMUX_PAD_CTRL(EIM_A16__IPU2_CSI1_PIXCLK, CSI_PAD_CTRL),	/* GPIO2[22] - pin A8 */
+#endif
+	/* Not used, but MUST be in GPIO mode */
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),	/* CSI1_DATA_EN not used (pin B5 stat2) */
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLUP),	/* pin A5 stat0, hsync */
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),	/* pin A6 stat1, vsync */
+
+#define GP_GS2971_SMPTE_BYPASS	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),		/* pin G7 - i/o SMPTE bypass */
+#define GP_GS2971_RESET		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, OUTPUT_40OHM),	/* 0 - pin C7 - reset */
+#define GP_GS2971_DVI_LOCK	IMX_GPIO_NR(3, 14)
+	IOMUX_PAD_CTRL(EIM_DA14__GPIO3_IO14, WEAK_PULLUP),		/* pin B6 - stat3 - DVI_LOCK */
+#define GP_GS2971_DATA_ERR	IMX_GPIO_NR(3, 15)
+	IOMUX_PAD_CTRL(EIM_DA15__GPIO3_IO15, WEAK_PULLUP),		/* pin C6 - stat5 - DATA error */
+#define GP_GS2971_LB_CONT	IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),		/* pin A3 - LB control - float, analog input */
+#define GP_GS2971_Y_1ANC	IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),	/* pin C5 - stat4 - 1ANC - Y signal detect */
+#define GP_GS2971_RC_BYPASS	IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, OUTPUT_40OHM),	/* 0 - pin G3 - RC bypass - output is buffered(low) */
+#define GP_GS2971_IOPROC_EN	IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, OUTPUT_40OHM),	/* 0 - pin H8 - io(A/V) processor enable */
+#define GP_GS2971_AUDIO_EN	IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, OUTPUT_40OHM),	/* 0 - pin H3 - Audio Enable */
+#define GP_GS2971_TIM_861	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, OUTPUT_40OHM),	/* 0 - pin H5 - TIM861 timing format, 1-use HSYNC/VSYNC */
+#define GP_GS2971_SW_EN		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, OUTPUT_40OHM),	/* 0 - pin D7 - SW_EN - line lock enable */
+#define GP_GS2971_STANDBY	IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, OUTPUT_40OHM),		/* 1 - pin K2 - Standby */
+#define GP_GS2971_DVB_ASI	IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),	/* pin G8 i/o DVB_ASI */
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 - GS2971 */
+	IOMUX_PAD_CTRL(EIM_OE__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_CS1__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_CS0__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_GS2971_CS	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP_OUTPUT),
+
+	/* ECSPI3 - WM5102 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI3_WM5102_CS	IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP_OUTPUT),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),	/* Micrel RGMII Phy Reset */
+#define GP_ENET_PHY_INT		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),	/* Micrel RGMII Phy Interrupt */
+
+	/* HDMI */
+	IOMUX_PAD_CTRL(KEY_ROW2__HDMI_TX_CEC_LINE, HDMICEC_PAD_CTRL),
+
+#define GP_TP101_ALERT		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+
+	/* Hogs */
+#define GP_ANX7738_RESET	IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, WEAK_PULLDN_OUTPUT),
+
+	/* i2c1 mux enables */
+#define GP_I2C1_MUX_KL04	IMX_GPIO_NR(5, 27)
+	IOMUX_PAD_CTRL(CSI0_DAT9__GPIO5_IO27, WEAK_PULLDN_OUTPUT),
+#define GP_I2C1_MUX_ANX7814	IMX_GPIO_NR(1, 10)
+	IOMUX_PAD_CTRL(SD2_CLK__GPIO1_IO10, WEAK_PULLDN_OUTPUT),
+#define GP_I2C1_MUX_AX7738	IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLDN_OUTPUT),
+#define GP_I2C1_MUX_TC3587	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN_OUTPUT),
+
+	/* i2c1 anx7814 - hdmi to mydp transmitter */
+#define GP_ANX7814_P_DWN       IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(SD2_DAT2__GPIO1_IO13, WEAK_PULLUP_OUTPUT),
+#define GP_ANX7814_RESET       IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN_OUTPUT),
+#define GP_ANX7814_CBL_DET     IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLDN),
+#define GP_ANX7814_HDMI_INTR   IMX_GPIO_NR(1, 14)
+	IOMUX_PAD_CTRL(SD2_DAT1__GPIO1_IO14, WEAK_PULLDN),
+
+	/* i2c2 mux enables */
+#define GP_I2C2_MUX_ANX7814_DDC	 IMX_GPIO_NR(1, 15)
+	IOMUX_PAD_CTRL(SD2_DAT0__GPIO1_IO15, WEAK_PULLDN_OUTPUT),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, OUTPUT_40OHM),
+#define GP_PCIE_RADIO_ON	IMX_GPIO_NR(6, 10)
+	IOMUX_PAD_CTRL(NANDF_RB0__GPIO6_IO10, OUTPUT_40OHM),
+
+	/* UART1 - J2 - PTT connector */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),	/* J2, pin 9 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),	/* J2, pin 10 */
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),		/* J2, pin 7: PTT_R */
+	IOMUX_PAD_CTRL(EIM_EB3__GPIO2_IO31, WEAK_PULLUP),		/* J2, pin 6: PTT_L */
+
+	/* UART2 - debug */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 - relay J3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),	/* J3, pin 5 */
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),	/* J3, pin 6 */
+#define GP_RELAY_DETECT		IMX_GPIO_NR(7, 2)
+	IOMUX_PAD_CTRL(SD3_CMD__GPIO7_IO02, PADCFG_FLOAT_IRQ),	/* J3 pin 7 */
+#define GP_J3_CARRIER_SENSE	IMX_GPIO_NR(7, 4)
+	IOMUX_PAD_CTRL(SD3_DAT0__GPIO7_IO04, PADCFG_FLOAT_IRQ),
+
+
+#define GP_PTT_ON	IMX_GPIO_NR(7, 5)
+	IOMUX_PAD_CTRL(SD3_DAT1__GPIO7_IO05, PADCFG_FLOAT_IRQ),
+
+#define GP_J11_HDMI_POWER_EN	IMX_GPIO_NR(7, 3)
+	IOMUX_PAD_CTRL(SD3_CLK__GPIO7_IO03, PADCFG_INPUT_L_UP),	/* power on J11 pin 3 */
+
+	/* UART4 - GPS */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+#define GP_GPS_RESET	IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, PADCFG_FLOAT_IRQ),
+#define GPIRQ_GPS	IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+#define GP_GPS_HEARTBEAT IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+
+	/* UART5 - J6 data connector */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),	/* J6, pin 5 */
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),	/* J6, pin 6 */
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),		/* J6, pin 8 - Data detect */
+#define GP_J6_POWER_EN	IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),		/* J6, Power enable */
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),		/* J6, pin 16 */
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),	/* low indicates over current */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, OUTPUT_40OHM),	/* USB Hub Reset for USB2512 4 port hub */
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, OTGID_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),	/* low indicates over current */
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, OUTPUT_40OHM),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL_50MHZ),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL_50MHZ),
+#define GP_EMMC_RESET	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM),	/* eMMC reset */
+
+	/* 1-wire J11 pin 22, J3 pin 8, J6 pin 9*/
+#define GP_1WIRE_EN	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+
+	/* Microcontroller KL04Z32TFK4 on I2C1 */
+#define GP_KL04_SWD_CLK	IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLDN),	/* SWD_CLK */
+#define GP_KL04_SWD_IO	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),	/* SWD_IO */
+#define GP_KL04_RESET	IMX_GPIO_NR(5, 20)
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__GPIO5_IO20, WEAK_PULLDN),
+#define GP_KL04_PROGRAM	IMX_GPIO_NR(5, 22)
+	IOMUX_PAD_CTRL(CSI0_DAT4__GPIO5_IO22, WEAK_PULLDN),
+#define GPIRQ_KL04	IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+
+	/* Make sure these no-connects don't wiggle */
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	/* Reset USB hub */
+	if (port) {
+		gpio_set_value(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_USB_OTG_PWR, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_KL04_RESET,		/* inverted before kl04, not in reset */
+	GP_KL04_PROGRAM,	/* inverted before kl04 */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_WM5102_RESET,
+	GP_WM5102_LDO_EN,
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_J6_POWER_EN,
+	GP_RGMII_PHY_RESET,
+	GP_PCIE_RADIO_ON,
+	GP_PCIE_RESET,
+	GP_GS2971_RESET,
+	GP_GS2971_RC_BYPASS,
+	GP_GS2971_IOPROC_EN,
+	GP_GS2971_AUDIO_EN,
+	GP_GS2971_TIM_861,
+	GP_GS2971_SW_EN,
+	GP_GS2971_DVB_ASI,
+	GP_ANX7738_RESET,
+	GP_TC3587_RESET,
+	GP_I2C1_MUX_KL04,
+	GP_I2C1_MUX_ANX7814,
+	GP_I2C1_MUX_AX7738,
+	GP_I2C1_MUX_TC3587,
+	GP_ANX7814_RESET,
+	GP_I2C2_MUX_ANX7814_DDC,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_GS2971_CS,
+	GP_ECSPI3_WM5102_CS,
+	GP_GS2971_STANDBY,
+	GP_ANX7814_P_DWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_KL04_SWD_CLK,
+	GP_KL04_SWD_IO,
+	GP_TP101_ALERT,
+	GP_GS2971_SMPTE_BYPASS,
+	GP_GS2971_DVI_LOCK,
+	GP_GS2971_DATA_ERR,
+	GP_GS2971_LB_CONT,
+	GP_GS2971_Y_1ANC,
+	GPIRQ_KL04,
+	GPIRQ_WM5102,
+	GPIRQ_TC3587,
+	GP_ANX7814_CBL_DET,
+	GP_ANX7814_HDMI_INTR,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/per/per.cfg u-boot-imx6/board/boundary/per/per.cfg
--- u-boot-2017.07/board/boundary/per/per.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/per.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43160328
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03110303
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4a43454b
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x36404135
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x001f0023
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0023001f
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 1
+#define BUS_WIDTH 32
+/* MT41K512M16TNA-125 IT:E, BOM removed, not supported */
+#include "../common/mx6/1066mhz_256mx16-hynix.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/per/spl.c u-boot-imx6/board/boundary/per/spl.c
--- u-boot-2017.07/board/boundary/per/spl.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/per/spl.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/mx6-ddr.h>
+#include <asm/imx-common/boot_mode.h>
+
+#include <i2c.h>
+#include <spl.h>
+
+#if 0
+void board_init_f(ulong dummy)
+{
+#if 0
+	arch_cpu_init();
+	board_early_init_f();
+	timer_init();
+	preloader_console_init();
+
+	print_cpuinfo();
+	board_init_r(NULL, 0);
+#endif
+}
+#endif
+
+void spl_board_init(void)
+{
+#if 0
+	int i;
+	u32 const *regs ;
+	int num_regs;
+	unsigned char mac_address[6];
+        imx_get_mac_from_fuse(0,mac_address);
+	printf("ethaddr: %pM\n", mac_address);
+
+	if (is_cpu_type(MXC_CPU_MX6Q)) {
+#if 1
+		regs = mx6q_1g;
+		num_regs = ARRAY_SIZE(mx6q_1g);
+#else
+		regs = mx6q_2g;
+		num_regs = ARRAY_SIZE(mx6q_2g);
+#endif
+	} else {
+#if CONFIG_DDR_MB == 512
+		regs = mx6dl_512m;
+		num_regs = ARRAY_SIZE(mx6dl_512m);
+printf("Configuring for 512MiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 1024
+		regs = mx6dl_1gn;
+		num_regs = ARRAY_SIZE(mx6dl_1gn);
+printf("Configuring for 1GiB narrow memory bus\n");
+#elif CONFIG_DDR_MB == 2048
+		regs = mx6dl_2g;
+		num_regs = ARRAY_SIZE(mx6dl_2g);
+printf("Configuring for 2GiB wide memory bus\n");
+#endif
+	}
+	for (i=0; i < num_regs; i+=2) {
+		writel(regs[i+1],regs[i]);
+	}
+        dram_init();
+#endif
+	printf("%s\n", __func__);
+}
+
+u32 spl_boot_device(void)
+{
+	printf("%s\n", __func__);
+#if 0
+	unsigned reg;
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	printf("%s: sbmr1 == 0x%08x\n", __func__, psrc->sbmr1);
+	printf("%s: gpr9  == 0x%08x\n", __func__, psrc->gpr9);
+	printf("%s: gpr10 == 0x%08x\n", __func__, psrc->gpr10);
+	return BOOT_DEVICE_USB;
+#endif
+#if 1
+	return BOOT_DEVICE_SPI;
+#endif
+}
+
+#if 0
+void spl_usb_load_image(void)
+{
+	boot_mode_apply(MAKE_CFGVAL(0x01, 0x00, 0x00, 0x00));
+	reset_cpu(0);
+}
+
+#endif
diff -Nru u-boot-2017.07/board/boundary/rc/Kconfig u-boot-imx6/board/boundary/rc/Kconfig
--- u-boot-2017.07/board/boundary/rc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/rc/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_RC
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "rc"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "rc"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/rc/MAINTAINERS u-boot-imx6/board/boundary/rc/MAINTAINERS
--- u-boot-2017.07/board/boundary/rc/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/rc/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+RC BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/rc/
+F:	include/configs/rc.h
+F:	configs/rc_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/rc/Makefile u-boot-imx6/board/boundary/rc/Makefile
--- u-boot-2017.07/board/boundary/rc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/rc/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := rc.o
diff -Nru u-boot-2017.07/board/boundary/rc/rc1g.cfg u-boot-imx6/board/boundary/rc/rc1g.cfg
--- u-boot-2017.07/board/boundary/rc/rc1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/rc/rc1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x420F020F
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x01760175
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x41640171
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x015E0160
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45464B4A
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x49484A46
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40402E32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x3A3A3231
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x003A003A
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0030002F
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x002F0038
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00270039
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/rc/rc.c u-boot-imx6/board/boundary/rc/rc.c
--- u-boot-2017.07/board/boundary/rc/rc.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/rc/rc.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* AR8035 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+#define GPIRQ_MIC_DET		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GPIRQ_HP_DET		IMX_GPIO_NR(1, 3)
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* i2c2_rv4172 rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(2, 26)
+	IOMUX_PAD_CTRL(EIM_RW__GPIO2_IO26, WEAK_PULLUP),
+
+	/* J25 */
+#define GPIRQ_IR		IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLDN),
+
+	/* PWM2 */
+#define GP_PWM2			IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* TEST POINTS */
+#define GP_TP68			IMX_GPIO_NR(2, 0)
+	IOMUX_PAD_CTRL(NANDF_D0__GPIO2_IO00, BUTTON_PAD_CTRL),
+#define GP_TP69			IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+#define GP_TP70			IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_TP71			IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_TP77			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+#define GP_TP78			IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),  /* slow clock */
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_WP		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLUP),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+
+	/* Make sure unused LCD pins don't toggle */
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_RGMII_PHY_RESET,
+	GP_PCIE_RESET,
+	GP_PWM2,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_USB_HUB_RESET,	/* disable hub */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GPIRQ_RTC_RV4162,
+	GPIRQ_MIC_DET,
+	GPIRQ_HP_DET,
+	GPIRQ_I2C3_J7,
+	GPIRQ_IR,
+	GP_PCIE_DISABLE,
+	GP_TP68,
+	GP_TP69,
+	GP_TP70,
+	GP_TP71,
+	GP_TP77,
+	GP_TP78,
+	GP_USDHC3_WP,
+	GP_USDHC3_CD,
+	GPIRQ_WL1271_WL,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_TP68,	'B', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/s/Kconfig u-boot-imx6/board/boundary/s/Kconfig
--- u-boot-2017.07/board/boundary/s/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/s/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_S
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "s"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "s"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/s/MAINTAINERS u-boot-imx6/board/boundary/s/MAINTAINERS
--- u-boot-2017.07/board/boundary/s/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/s/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+S BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/s/
+F:	include/configs/s.h
+F:	configs/s_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/s/Makefile u-boot-imx6/board/boundary/s/Makefile
--- u-boot-2017.07/board/boundary/s/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/s/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := s.o
diff -Nru u-boot-2017.07/board/boundary/s/s.c u-boot-imx6/board/boundary/s/s.c
--- u-boot-2017.07/board/boundary/s/s.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/s/s.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,429 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(EIM_OE__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_CS1__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_CS0__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS1		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+#define GP_FLEXCAN_STANDBY	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+
+	/* gpio_Keys */
+#define GP_TEMP_ALARM		IMX_GPIO_NR(2, 21)
+	IOMUX_PAD_CTRL(EIM_A17__GPIO2_IO21, WEAK_PULLUP),
+#define GP_FAN_FAIL		IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_AC_FAIL		IMX_GPIO_NR(2, 18)
+	IOMUX_PAD_CTRL(EIM_A20__GPIO2_IO18, WEAK_PULLUP),
+#define GP_J5_PIN33		IMX_GPIO_NR(1, 16)
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+#define GP_J34_PIN6		IMX_GPIO_NR(5, 4)
+	IOMUX_PAD_CTRL(EIM_A24__GPIO5_IO04, WEAK_PULLUP),
+#define GP_J34_PIN8		IMX_GPIO_NR(6, 6)
+	IOMUX_PAD_CTRL(EIM_A23__GPIO6_IO06, WEAK_PULLUP),
+#define GP_ON_OFF		IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+
+	/* gpio outputs */
+#define GP_LED_RED		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP_OUTPUT),
+#define GP_LED_GREEN		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLUP_OUTPUT),
+#define GP_LED_AMBER		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP_OUTPUT),
+#define GP_J34_DRY1		IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(EIM_A22__GPIO2_IO16, WEAK_PULLDN_OUTPUT),
+#define GP_J34_DRY2		IMX_GPIO_NR(5, 2)
+	IOMUX_PAD_CTRL(EIM_A25__GPIO5_IO02, WEAK_PULLDN_OUTPUT),
+
+	/* gpio test points */
+#define GP_TP_R201	IMX_GPIO_NR(4, 16)
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+
+	/* i2c1_isl1208 */
+#define GPIRQ_RTC_ISL1208	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLUP),
+
+	/* i2c1_SGTL5000 sys_mclk */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+#define GP_TDA7491P_GAIN0	IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_GAIN1	IMX_GPIO_NR(3, 30)
+	IOMUX_PAD_CTRL(EIM_D30__GPIO3_IO30, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_STBY	IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_MUTE	IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_MIC_DET		IMX_GPIO_NR(1, 24)
+	IOMUX_PAD_CTRL(ENET_RX_ER__GPIO1_IO24, WEAK_PULLUP),
+
+	/* i2c3, ov5642 Camera controls, J5 */
+	IOMUX_PAD_CTRL(CSI0_DAT8__IPU1_CSI0_DATA08, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__IPU1_CSI0_DATA09, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT10__IPU1_CSI0_DATA10, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT11__IPU1_CSI0_DATA11, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT12__IPU1_CSI0_DATA12, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__IPU1_CSI0_DATA13, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT14__IPU1_CSI0_DATA14, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT15__IPU1_CSI0_DATA15, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT16__IPU1_CSI0_DATA16, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT17__IPU1_CSI0_DATA17, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT18__IPU1_CSI0_DATA18, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT19__IPU1_CSI0_DATA19, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DATA_EN__IPU1_CSI0_DATA_EN, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(CSI0_PIXCLK__IPU1_CSI0_PIXCLK, CSI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_MCLK__GPIO5_IO19, WEAK_PULLUP),	/* Hsync */
+	IOMUX_PAD_CTRL(CSI0_VSYNC__GPIO5_IO21, WEAK_PULLUP),	/* Vsync */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5642_POWER_DOWN	IMX_GPIO_NR(3, 29)
+	IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+#define GP_OV5642_RESET		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLDN),
+
+	/* i2c3 edid enable*/
+#define GP_I2C3_EDID		IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(EIM_A21__GPIO2_IO17, WEAK_PULLDN_OUTPUT),
+
+	/* Power off */
+#define GP_POWER_OFF		IMX_GPIO_NR(7, 1)
+	IOMUX_PAD_CTRL(SD3_DAT4__GPIO7_IO01, WEAK_PULLDN_OUTPUT),	/* 0 is on */
+
+	/* PWM1 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_TPS	IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for wl1271 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 - J27 pins 2, 4 */
+	IOMUX_PAD_CTRL(KEY_COL0__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 - J32 pins 2, 4 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - sdcard */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC4_CD		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USBH1_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USBH1_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC4_CD},
+};
+#endif
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : (cs >> 8) ? (cs >> 8) : -1;
+}
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_BACKLIGHT_TPS, enable);
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* lvds */
+	VD_AUO_B101EW05(LVDS, fbp_detect_i2c, 2, 0x50),
+	VD_WXGA_J(LVDS, NULL, 0, 0),
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, (GP_I2C3_EDID << 8 ) | 2, 0x3a),
+	VD_1920_1080M_60(HDMI, NULL, (GP_I2C3_EDID << 8 ) | 2, 0x3a),
+	VD_1024_768M_60(HDMI, NULL, (GP_I2C3_EDID << 8 ) | 2, 0x3a),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	/* Disable wl1271 */
+	GP_BT_RFKILL_RESET,
+	GP_RGMII_PHY_RESET,
+	GP_J34_DRY1,
+	GP_J34_DRY2,
+	GP_TDA7491P_GAIN0,
+	GP_TDA7491P_GAIN1,
+	GP_TDA7491P_STBY,
+	GP_TDA7491P_MUTE,
+	GP_OV5642_RESET,
+	GP_I2C3_EDID,
+	GP_POWER_OFF,
+	GP_BACKLIGHT_TPS,
+	GP_BACKLIGHT_LVDS,
+	GP_REG_USBOTG,
+	GP_REG_WLAN_EN,
+	GP_USBH1_HUB_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_CS1,
+	GP_FLEXCAN_STANDBY,
+	GP_LED_RED,
+	GP_LED_GREEN,
+	GP_LED_AMBER,
+	GP_OV5642_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_TEMP_ALARM,
+	GP_FAN_FAIL,
+	GP_AC_FAIL,
+	GP_J5_PIN33,
+	GP_J34_PIN6,
+	GP_J34_PIN8,
+	GP_ON_OFF,
+	GP_TP_R201,
+	GPIRQ_RTC_ISL1208,
+	GPIRQ_MIC_DET,
+	GP_USDHC3_CD,
+	GP_USDHC4_CD,
+	GPIRQ_WL1271_WL,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	gpio_set_value(GP_POWER_OFF, 1);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"power",	GP_ON_OFF,	'P', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/s/s_q2g.cfg u-boot-imx6/board/boundary/s/s_q2g.cfg
--- u-boot-2017.07/board/boundary/s/s_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/s/s_q2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ses/Kconfig u-boot-imx6/board/boundary/ses/Kconfig
--- u-boot-2017.07/board/boundary/ses/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ses/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_SES
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ses"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ses"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ses/MAINTAINERS u-boot-imx6/board/boundary/ses/MAINTAINERS
--- u-boot-2017.07/board/boundary/ses/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ses/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+SES BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ses/
+F:	include/configs/ses.h
+F:	configs/ses_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/ses/Makefile u-boot-imx6/board/boundary/ses/Makefile
--- u-boot-2017.07/board/boundary/ses/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ses/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ses.o
diff -Nru u-boot-2017.07/board/boundary/ses/ses.c u-boot-imx6/board/boundary/ses/ses.c
--- u-boot-2017.07/board/boundary/ses/ses.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ses/ses.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* baclight lvds */
+#define GP_BACKLIGHT_LVDS_EN	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLDN),
+
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 - J41 */
+	IOMUX_PAD_CTRL(CSI0_DAT10__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT9__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT8__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS0		IMX_GPIO_NR(5, 29)
+	IOMUX_PAD_CTRL(CSI0_DAT11__GPIO5_IO29, WEAK_PULLUP),
+#define GP_ECSPI2_CS1		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_ECSPI2_GPIO2		IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_ECSPI2_GPIO8		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* ECSPI3 - J40 */
+	IOMUX_PAD_CTRL(DISP0_DAT2__ECSPI3_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__ECSPI3_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT0__ECSPI3_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI3_CS0		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+#define GP_ECSPI3_CS1		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_ECSPI3_CS2		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_ECSPI3_CS3		IMX_GPIO_NR(4, 27)
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* Hogs, test points */
+#define GP_TP76			IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SD1_DAT0__GPIO1_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_3__GPIO1_IO03, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLDN),
+
+	/* I2C1 ADC101 */
+#define GPIRQ_I2C1_ADC101	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+
+	/* PWM2 - Backlight on LVDS connector: J1, pin 34 */
+#define GP_BACKLIGHT_LVDS_PWM	IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(2, 5)
+	IOMUX_PAD_CTRL(NANDF_D5__GPIO2_IO05, WEAK_PULLDN),
+
+	/* UART1, J37 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 - J30 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 for silex */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4, J38 */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5, J36 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC2 - Silex, TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC2 - wlan */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+#define GP_WIFI_WAKE		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, WEAK_PULLUP),
+#define GP_WIFI_QOW		IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, WEAK_PULLUP),
+#define GPIRQ_BT_HOST_WAKE	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN),
+#define GP_BT_CLK_REQ		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, ADC101C021CIMK */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2  */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J39 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS_PWM, enable);
+	gpio_direction_output(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* uses both lvds connectors */
+	VD_DV210FBM(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_BACKLIGHT_LVDS_EN,
+	GP_BT_RFKILL_RESET, 	/* disable bluetooth */
+	GP_RGMII_PHY_RESET,
+	GP_BACKLIGHT_LVDS_PWM,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_REG_WLAN_EN,		/* disable wireless */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_CS0,
+	GP_ECSPI2_CS1,
+	GP_ECSPI3_CS0,
+	GP_ECSPI3_CS1,
+	GP_ECSPI3_CS2,
+	GP_ECSPI3_CS3
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ECSPI2_GPIO2,
+	GP_ECSPI2_GPIO8,
+	GPIRQ_ENET_PHY,
+	GP_TP76,
+	GPIRQ_I2C1_ADC101,
+	GPIRQ_WL1271_WL,
+	GP_WIFI_WAKE,
+	GP_WIFI_QOW,
+	GPIRQ_BT_HOST_WAKE,
+	GP_BT_CLK_REQ,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp76",	GP_TP76,	'T', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/ses/ses_q2g.cfg u-boot-imx6/board/boundary/ses/ses_q2g.cfg
--- u-boot-2017.07/board/boundary/ses/ses_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ses/ses_q2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* 5 board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43160327
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x03100307
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x031e032c
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x0315025c
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x40333842
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3b373344
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x393c3e32
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4332463e
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0015001e
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0024001b
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00110023
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000c0017
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* D2516EC4BXGGB-U */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/snap/Kconfig u-boot-imx6/board/boundary/snap/Kconfig
--- u-boot-2017.07/board/boundary/snap/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/snap/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,20 @@
+if TARGET_SNAP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "snap"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "snap"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/snap/MAINTAINERS u-boot-imx6/board/boundary/snap/MAINTAINERS
--- u-boot-2017.07/board/boundary/snap/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/snap/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,6 @@
+TA BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/snap/
+F:	include/configs/snap.h
+F:	configs/snap_defconfig
diff -Nru u-boot-2017.07/board/boundary/snap/Makefile u-boot-imx6/board/boundary/snap/Makefile
--- u-boot-2017.07/board/boundary/snap/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/snap/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,6 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+obj-y  := snap.o
diff -Nru u-boot-2017.07/board/boundary/snap/snap2g.cfg u-boot-imx6/board/boundary/snap/snap2g.cfg
--- u-boot-2017.07/board/boundary/snap/snap2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/snap/snap2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/snap/snap.c u-boot-imx6/board/boundary/snap/snap.c
--- u-boot-2017.07/board/boundary/snap/snap.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/snap/snap.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	 (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 pads (serial nor eeprom) */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),
+#define GP_ENET_PHY_INT		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* i2c2 ov5640 mipi Camera controls */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(6, 4)
+	IOMUX_PAD_CTRL(CSI0_DAT18__GPIO6_IO04, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET		IMX_GPIO_NR(6, 5)
+	IOMUX_PAD_CTRL(CSI0_DAT19__GPIO6_IO05, WEAK_PULLDN),
+
+
+	/* I2C1 - rtc */
+	/* I2C2 - mipi camera, pcie */
+	/* I2C3 - sata */
+#define GP_I2C3_EN_SATA		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN),
+
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, OUTPUT_40OHM),
+
+/* PWM3 goes to mipi camera */
+#define GP_PWM3			IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, OUTPUT_40OHM),
+
+	/* rtc */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+	/* Sata hard drive detect, high if present */
+#define GP_HD_DETECT	IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+
+	/* Test points */
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP75			IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 - console */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USBH1_HUB_RESET	IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN_OUTPUT),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - micro SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+
+	/* J8 on DB */
+#define GP_GIO1		IMX_GPIO_NR(1, 15)
+	IOMUX_PAD_CTRL(SD2_DAT0__GPIO1_IO15, WEAK_PULLUP),
+#define GP_GIO2		IMX_GPIO_NR(1, 14)
+	IOMUX_PAD_CTRL(SD2_DAT1__GPIO1_IO14, WEAK_PULLUP),
+#define GP_GIO3		IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(SD2_DAT2__GPIO1_IO13, WEAK_PULLUP),
+#define GP_GIO4		IMX_GPIO_NR(1, 12)
+	IOMUX_PAD_CTRL(SD2_DAT3__GPIO1_IO12, WEAK_PULLUP),
+#define GP_GIO5		IMX_GPIO_NR(1, 11)
+	IOMUX_PAD_CTRL(SD2_CMD__GPIO1_IO11, WEAK_PULLUP),
+#define GP_GIO6		IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+
+	/* spares on DB */
+#define GP_IO00		IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+#define GP_IO01		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+#define GP_IO02		IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+#define GP_IO03		IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+#define GP_IO04		IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_IO05		IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_IO06		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+#define GP_IO07		IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(GPIO_0__GPIO1_IO00, WEAK_PULLUP),
+#define GP_IO08		IMX_GPIO_NR(1, 0)
+	IOMUX_PAD_CTRL(SD1_CLK__GPIO1_IO20, WEAK_PULLUP),
+#define GP_IO09		IMX_GPIO_NR(1, 10)
+	IOMUX_PAD_CTRL(SD2_CLK__GPIO1_IO10, WEAK_PULLUP),
+#define GP_IO10		IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	int gp = port ? GP_USBH1_HUB_RESET : GP_REG_USBOTG;
+	gpio_set_value(gp, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_I2C3_EN_SATA,
+	GP_PCIE_RESET,
+	GP_USBH1_HUB_RESET,
+	GP_REG_USBOTG,
+	GP_EMMC_RESET,
+	GP_OV5640_MIPI_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_PWM3,
+	GP_OV5640_MIPI_POWER_DOWN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ENET_PHY_INT,
+	GPIRQ_RTC_RV4162,
+	GP_HD_DETECT,
+	GP_TP71,
+	GP_TP75,
+	GP_USDHC3_CD,
+	GP_GIO1,
+	GP_GIO2,
+	GP_GIO3,
+	GP_GIO4,
+	GP_GIO5,
+	GP_GIO6,
+	GP_IO00,
+	GP_IO01,
+	GP_IO02,
+	GP_IO03,
+	GP_IO04,
+	GP_IO05,
+	GP_IO06,
+	GP_IO07,
+	GP_IO08,
+	GP_IO09,
+	GP_IO10,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			NULL, 0, GP_HD_DETECT);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"b1",		GP_TP71,	'1', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/sp/6x_bootscript.txt u-boot-imx6/board/boundary/sp/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/sp/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/6x_bootscript.txt	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,90 @@
+# Yocto-specifics
+setenv bootpart 2
+setenv bootdir /
+
+setenv bootargs enable_wait_mode=off
+setenv bootargs $bootargs ar1020_i2c.calibration=-17810,0,60214224,0,-22625,78839808,65536,768,1024
+setenv nextcon 0;
+
+if hdmidet ; then
+	setenv bootargs $bootargs video=mxcfb${nextcon}:dev=hdmi,1280x720M@60,if=RGB24,bpp=32
+	setenv fbmem "fbmem=28M";
+	setexpr nextcon $nextcon + 1
+else
+	echo "------ no HDMI monitor";
+fi
+
+setenv bootargs $bootargs video=mxcfb${nextcon}:dev=ldb,LG-9.7,if=RGB666,bpp=32
+if test "0" -eq $nextcon; then
+	setenv fbmem "fbmem=10M";
+else
+	setenv fbmem ${fbmem},10M
+fi
+setexpr nextcon $nextcon + 1
+
+while test "4" -ne $nextcon ; do
+	setenv bootargs $bootargs video=mxcfb${nextcon}:off ;
+	setexpr nextcon $nextcon + 1 ;
+done
+
+setenv bootargs $bootargs $fbmem
+setenv bootargs "$bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait"
+
+if itest.s x$bootpart == x ; then
+	bootpart=1
+fi
+
+setenv bootargs "$bootargs root=/dev/mmcblk0p$bootpart" ;
+
+dtbname="imx6";
+if itest.s x6S != "x$cpu" ; then
+	dtbname=${dtbname}q-;
+else
+	dtbname=${dtbname}s-;
+fi
+
+if itest.s x == "x$board" ; then
+	board=sabrelite
+fi
+dtbname=${dtbname}${board}.dtb;
+
+if itest.s x == x${bootdir} ; then
+	bootdir=/boot/
+fi
+
+if ${fs}load ${dtype} ${disk}:1 12000000 ${bootdir}$dtbname ; then
+	havedtb=1;
+else
+	havedtb=
+fi
+
+if itest.s x == x$allow_noncea ; then
+	setenv bootargs $bootargs mxc_hdmi.only_cea=1;
+	echo "only CEA modes allowed on HDMI port";
+else
+        setenv bootargs $bootargs mxc_hdmi.only_cea=0;
+        echo "non-CEA modes allowed on HDMI, audio may be affected";
+fi
+
+if kbd ; then
+	if itest.s xB == x$keybd ; then
+		if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage-usbwrite ; then
+			if ${fs}load ${dtype} ${disk}:1 12800000 ${bootdir}uramdisk-usbwrite.img ; then
+			   if itest.s x$havedtb == x ; then
+					bootm 10800000 12800000 ;
+			   else
+					bootm 10800000 12800000 12000000 ;
+			   fi
+			fi
+		fi
+	fi
+fi
+
+if ${fs}load ${dtype} ${disk}:1 10800000 ${bootdir}uImage ; then
+	if itest.s x$havedtb == x ; then
+		bootm 10800000 ;
+	else
+		bootm 10800000 - 12000000
+	fi
+fi
+echo "Error loading kernel image"
diff -Nru u-boot-2017.07/board/boundary/sp/Kconfig u-boot-imx6/board/boundary/sp/Kconfig
--- u-boot-2017.07/board/boundary/sp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,20 @@
+if TARGET_SP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "sp"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "sp"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/sp/MAINTAINERS u-boot-imx6/board/boundary/sp/MAINTAINERS
--- u-boot-2017.07/board/boundary/sp/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+SP BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/sp/
+F:	include/configs/sp.h
+F:	configs/sp_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/sp/Makefile u-boot-imx6/board/boundary/sp/Makefile
--- u-boot-2017.07/board/boundary/sp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := sp.o
diff -Nru u-boot-2017.07/board/boundary/sp/sp.c u-boot-imx6/board/boundary/sp/sp.c
--- u-boot-2017.07/board/boundary/sp/sp.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/sp.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	       \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |	       \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |	       \
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*
+ *
+ */
+static iomux_v3_cfg_t const init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, SPI_PAD_CTRL),
+
+	/* gpio_Keys */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLUP),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, WEAK_PULLUP),
+
+	/* gpios */
+#define GP_MAIN_POWER		IMX_GPIO_NR(3, 29)
+        IOMUX_PAD_CTRL(EIM_D29__GPIO3_IO29, WEAK_PULLUP),
+#define GP_L1			IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, PAD_CTL_DSE_240ohm),
+#define GP_L2			IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, PAD_CTL_DSE_240ohm),
+
+        /* i2c1mux */
+#define GP_I2C1MUXA_EN		IMX_GPIO_NR(3, 20)
+	IOMUX_PAD_CTRL(EIM_D20__GPIO3_IO20, WEAK_PULLUP),	/* CAM */
+#define GP_I2C1MUXB_EN		IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLUP),	/* RTC */
+
+#define GP_WIFI_WL_ENABLE	IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, OUTPUT_40OHM),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+#define GP_BACKLIGHT_RGB IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS_PWM IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN),
+	/* Backlight on LVDS connector: J6 */
+#define GP_BACKLIGHT_LVDS_EN IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN),
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN	IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP), /* USBOTG ID pin */
+
+	/* USDHC2 - TiWi wl1271 pads */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+
+	/* Wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1: ADS1000, AR1020-I/SO*/
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2  */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J8 - external touch, ISL1208 */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS_PWM, enable);
+	gpio_direction_output(GP_BACKLIGHT_LVDS_EN, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* egalax_ts */
+	VD_LG9_7(LVDS, fbp_detect_i2c, 2, 0x04),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	/* Disable wifi/bt */
+	GP_EMMC_RESET,		/* hold in reset */
+	GP_WIFI_WL_ENABLE,
+	GP_BT_RFKILL_RESET,
+	GP_REG_WLAN_EN,
+	GP_I2C1MUXA_EN,
+	GP_L1,
+	GP_L2,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_I2C1MUXB_EN,		/* enable RTC */
+	GP_MAIN_POWER,
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_WL1271_WL,
+	GP_BACKLIGHT_LVDS_PWM,
+	GP_BACKLIGHT_LVDS_EN,
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
+
+void board_poweroff(void)
+{
+	/* Turn off main power */
+	gpio_direction_output(GP_MAIN_POWER, 0);
+	while (1) {
+		udelay(1000000);
+	}
+}
+
+static int _do_poweroff(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(poweroff, 1, 1, _do_poweroff, "Turn off power", "");
diff -Nru u-boot-2017.07/board/boundary/sp/sp_s512m.cfg u-boot-imx6/board/boundary/sp/sp_s512m.cfg
--- u-boot-2017.07/board/boundary/sp/sp_s512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/sp/sp_s512m.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42350231
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x021A0218
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x4B4B4E49
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x3F3F3035
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0040003C
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x0032003E
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 32
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/800mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ta/6x_bootscript.txt u-boot-imx6/board/boundary/ta/6x_bootscript.txt
--- u-boot-2017.07/board/boundary/ta/6x_bootscript.txt	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/6x_bootscript.txt	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,53 @@
+if ${fs}load ${dtype} ${disk}:1 10800000 uEnv.txt ; then
+    env import -t 10800000 $filesize
+else
+    setenv bootargs
+fi
+
+setenv bootargs $bootargs video=mxcfb0:dev=ldb,1280x800MR@60,if=RGB666
+setenv bootargs $bootargs fbmem=10M ft5x06_ts.screenres=1280,800
+setenv bootargs $bootargs video=mxcfb1:off video=mxcfb2:off video=mxcfb3:off
+setenv bootargs $bootargs console=ttymxc1,115200 vmalloc=400M consoleblank=0 rootwait
+
+if itest.s "x" != "x${disable_giga}" ; then
+	setenv bootargs $bootargs fec.disable_giga=1
+fi
+
+if itest.s "x" != "x$gpumem" ; then
+	setenv bootargs $bootargs galcore.contiguousSize=$gpumem
+fi
+
+setenv initrd_high 0xffffffff
+setenv initrd_addr 0x12a00000
+
+echo "----------- trying to load /initrd.img";
+if ${fs}load ${dtype} ${disk}:${bootpart} ${initrd_addr} /initrd.img ; then
+	haverd=1;
+	setenv initrd_size ${filesize}
+	if itest 0 -eq ${disk}; then
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-2198000.usdhc-part1" ;
+	else
+		setenv bootargs "$bootargs root=/dev/disk/by-path/platform-219c000.usdhc-part1" ;
+	fi
+else
+	haverd=
+	setenv bootargs "$bootargs root=/dev/mmcblk0p1" ;
+fi
+
+dtbname=imx6q-ta.dtb
+bootdir=/boot
+
+setenv fdt_high 0xffffffff
+setenv fdt_addr    0x13000000
+echo "----------- trying to load ${bootdir}/$dtbname";
+if ${fs}load ${dtype} ${disk}:${bootpart} ${fdt_addr} ${bootdir}/$dtbname ; then
+	if ${fs}load ${dtype} ${disk}:${bootpart} 0x10800000 /vmlinuz ; then
+		if itest.s x$haverd == x ; then
+			bootz 0x10800000 - ${fdt_addr}
+		else
+			bootz 0x10800000 ${initrd_addr}:${initrd_size} ${fdt_addr} ;
+		fi
+	fi
+fi
+
+echo "Error loading kernel or device tree"
diff -Nru u-boot-2017.07/board/boundary/ta/Kconfig u-boot-imx6/board/boundary/ta/Kconfig
--- u-boot-2017.07/board/boundary/ta/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,20 @@
+if TARGET_TA
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ta"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ta"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ta/MAINTAINERS u-boot-imx6/board/boundary/ta/MAINTAINERS
--- u-boot-2017.07/board/boundary/ta/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,6 @@
+TA BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ta/
+F:	include/configs/ta.h
+F:	configs/ta_defconfig
diff -Nru u-boot-2017.07/board/boundary/ta/Makefile u-boot-imx6/board/boundary/ta/Makefile
--- u-boot-2017.07/board/boundary/ta/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,6 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+obj-y  := ta.o
diff -Nru u-boot-2017.07/board/boundary/ta/ta1g.cfg u-boot-imx6/board/boundary/ta/ta1g.cfg
--- u-boot-2017.07/board/boundary/ta/ta1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/ta1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn on main power */
+DATA 4, 0x020e03b4, 0xf0b0
+DATA 4, 0x020e00a0, 5
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ta/ta2g.cfg u-boot-imx6/board/boundary/ta/ta2g.cfg
--- u-boot-2017.07/board/boundary/ta/ta2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/ta2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn on main power */
+DATA 4, 0x020e03b4, 0xf0b0
+DATA 4, 0x020e00a0, 5
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* This configuration not yet produced */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/ta/ta.c u-boot-imx6/board/boundary/ta/ta.c
--- u-boot-2017.07/board/boundary/ta/ta.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ta/ta.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,348 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/* 3.3 V */
+#define USDHC3_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC3_PAD_CTRL (USDHC3_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/* 1.8 V */
+#define USDHC4_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC4_PAD_CTRL (USDHC4_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX  - SGTL5000 */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 pads (serial nor eeprom) */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, OUTPUT_40OHM),
+#define GP_ENET_PHY_INT		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* FLEXCAN */
+	IOMUX_PAD_CTRL(KEY_COL2__FLEXCAN1_TX, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_ROW2__FLEXCAN1_RX, WEAK_PULLUP),
+
+	/* GPIO Keys */
+	/* J23: Furnace, J24: Spare, J25: Gas delivery, J26:Auto sampler, J27: Front end power */
+#define GP_INTERLOCK_IRQ	IMX_GPIO_NR(2, 20)
+	IOMUX_PAD_CTRL(EIM_A18__GPIO2_IO20, WEAK_PULLUP),
+#define GP_ZERO_CROSSING_IRQ	IMX_GPIO_NR(2, 19)
+	IOMUX_PAD_CTRL(EIM_A19__GPIO2_IO19, WEAK_PULLUP),
+#define GP_SYNC_IRQ		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(EIM_DA12__GPIO3_IO12, WEAK_PULLUP),
+#define GP_HEATER_FAULT_IRQ	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLUP),
+#define GP_EXCH_FAULT1		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+#define GP_EXCH_FAULT2		IMX_GPIO_NR(3, 5)
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_EXCH_FAULT_IRQ	IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(EIM_DA10__GPIO3_IO10, WEAK_PULLUP),
+
+	/* GPIO Outputs */
+	/* Exchange */
+#define GP_EXCH_OFF		IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(EIM_DA11__GPIO3_IO11, WEAK_PULLDN),
+	/* Heater */
+#define GP_HEATER_OFF		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN),
+	/* LEDS */
+#define GP_CAN_CONNECT		IMX_GPIO_NR(3, 13)
+	IOMUX_PAD_CTRL(EIM_DA13__GPIO3_IO13, WEAK_PULLDN),
+#define GP_LED_RED		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN_OUTPUT),
+	/* dry contact relays */
+#define GP_RELAY_EVENT		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(EIM_DA7__GPIO3_IO07, WEAK_PULLDN_OUTPUT),
+#define GP_RELAY_GAS		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(EIM_DA9__GPIO3_IO09, WEAK_PULLDN_OUTPUT),
+
+	/* I2C1 - SGT5000 */
+	/* I2C2 - Nothing */
+	/* I2C3 - touch connector */
+#define GP_I2C3_IRQ		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* LVDS */
+#define GP_LVDS_CONTRAST	IMX_GPIO_NR(4, 20)
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+#define GP_LVDS_BACKLIGHT	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, OUTPUT_40OHM),
+
+	/* Test points */
+#define GP_TP71			IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(3, 8)
+	IOMUX_PAD_CTRL(EIM_DA8__GPIO3_IO08, WEAK_PULLUP),
+#define GP_TP77			IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+#define GP_TP78			IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+#define GP_TP79			IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLUP),
+#define GP_TP80			IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP),
+
+	/* SGTL5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D24__UART1_DTR_B, UART_PAD_CTRL),
+
+	/* UART2 - console */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART5 */
+	IOMUX_PAD_CTRL(KEY_COL1__UART5_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW1__UART5_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+#define GP_USBH1_PWR		IMX_GPIO_NR(2, 28)
+	IOMUX_PAD_CTRL(EIM_EB0__GPIO2_IO28, WEAK_PULLDN_OUTPUT),
+
+	/* USB OTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* USDHC3 - micro SD card */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC4_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, rv4162 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	int gp = port ? GP_USBH1_PWR : GP_USB_OTG_PWR;
+	gpio_set_value(gp, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	int gp = (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+	return gp;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_LVDS_BACKLIGHT, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* ft5x06 */
+	VD_HANNSTAR7(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_RELAY_EVENT,
+	GP_RELAY_GAS,
+	GP_LVDS_CONTRAST,
+	GP_LVDS_BACKLIGHT,
+	GP_USBH1_PWR,
+	GP_USB_OTG_PWR,
+	GP_EMMC_RESET,
+	GP_EXCH_OFF,
+	GP_HEATER_OFF,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_LED_RED,
+	GP_ECSPI1_NOR_CS,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_ENET_PHY_INT,
+	GP_CAN_CONNECT,
+	GP_INTERLOCK_IRQ,
+	GP_ZERO_CROSSING_IRQ,
+	GP_SYNC_IRQ,
+	GP_HEATER_FAULT_IRQ,
+	GP_EXCH_FAULT1,
+	GP_EXCH_FAULT2,
+	GP_EXCH_FAULT_IRQ,
+	GP_I2C3_IRQ,
+	GP_TP71,
+	GP_TP74,
+	GP_TP77,
+	GP_TP78,
+	GP_TP79,
+	GP_TP80,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"b1",		GP_TP71,	'1', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/usd/Kconfig u-boot-imx6/board/boundary/usd/Kconfig
--- u-boot-2017.07/board/boundary/usd/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_USD
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "usd"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "usd"
+
+config BOARD_LATE_SPECIFIC_INIT
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/usd/MAINTAINERS u-boot-imx6/board/boundary/usd/MAINTAINERS
--- u-boot-2017.07/board/boundary/usd/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/usd/
+F:	include/configs/usd.h
+F:	configs/usd_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/usd/Makefile u-boot-imx6/board/boundary/usd/Makefile
--- u-boot-2017.07/board/boundary/usd/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := usd.o
diff -Nru u-boot-2017.07/board/boundary/usd/usd.c u-boot-imx6/board/boundary/usd/usd.c
--- u-boot-2017.07/board/boundary/usd/usd.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd/usd.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC4_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 (ks8995 bridge) */
+	IOMUX_PAD_CTRL(DISP0_DAT17__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__ECSPI2_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS1		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP_OUTPUT),
+#define GP_KS8995_POWER_DOWN	IMX_GPIO_NR(5, 7)
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLDN_OUTPUT),
+#define GP_KS8995_RESET		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_KS8995_SCRS		IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLDN),
+#define GP_KS8995_SCOL		IMX_GPIO_NR(1, 29)
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpio status*/
+#define GP_5V_STATUS		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN),
+#define GP_48V_STATUS		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLDN),
+#define GP_48V_FAULT		IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN),
+#define GP_J33_PIN3_INPUT	IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),
+
+	/* GPIO output assignments */
+#define GP_REG_48V		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLDN_OUTPUT),
+#define GP_POWER_J33		IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN_OUTPUT),	/* 0 is off */
+#define GP_LED1			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN_OUTPUT),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hog Test points */
+#define GP_TP71			IMX_GPIO_NR(1, 25)
+	IOMUX_PAD_CTRL(ENET_CRS_DV__GPIO1_IO25, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP83			IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+#define GP_TP95			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_TP96			IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+#define GP_TP_R210		IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_TDA7491P_GAIN0	IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_GAIN1	IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_STBY	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_TDA7491P_MUTE	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_MIC_DET		IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* i2c2 ov5640 mipi Camera controls */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5640_MIPI_POWER_DOWN	IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET	IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN),
+
+
+	/* i2c3 J7 */
+#define GP_I2C3_J7_RESET	IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J5, pin 35 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN_OUTPUT),
+/* 0 is 8 bit */
+#define GP_LVDS_J5_PIN36	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLDN_OUTPUT),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 (J30) */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC4_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS :
+	       (bus == 1 && cs == 1) ? GP_ECSPI2_CS1 : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable);
+	gpio_set_value(GP_LVDS_J5_PIN36, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* IVO Default LVDS Display */
+	VD_M101NWWB(LVDS, fbp_detect_i2c, 2, 0x38),
+
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_AUO_B101EW05(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_HANNSTAR7(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_LD070WSVGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* uses both lvds connectors */
+	VD_1080P60(LVDS, NULL, 0, 0x00),
+	VD_1080P60_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_KS8995_RESET,
+	GP_KS8995_POWER_DOWN,
+	GP_RGMII_PHY_RESET,
+	GP_REG_48V,
+	GP_POWER_J33,
+	GP_LED1,
+	GP_TDA7491P_GAIN0,
+	GP_TDA7491P_GAIN1,
+	GP_TDA7491P_STBY,
+	GP_TDA7491P_MUTE,
+	GP_OV5640_MIPI_RESET,	/* camera reset */
+	GP_I2C3_J7_RESET,
+	GP_PCIE_RESET,
+	GP_BACKLIGHT_LVDS,
+	GP_LVDS_J5_PIN36,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_CS1,
+	GP_OV5640_MIPI_POWER_DOWN,	/* camera power down */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_KS8995_SCRS,
+	GP_KS8995_SCOL,
+	GPIRQ_ENET_PHY,
+	GP_5V_STATUS,
+	GP_48V_STATUS,
+	GP_48V_FAULT,
+	GP_J33_PIN3_INPUT,
+	GP_TP71,
+	GP_TP74,
+	GP_TP83,
+	GP_TP95,
+	GP_TP96,
+	GP_TP_R210,
+	GPIRQ_MIC_DET,
+	GPIRQ_I2C3_J7,
+	GP_PCIE_DISABLE,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_CMD_FBPANEL
+	gpio_set_value(GP_I2C3_J7_RESET, 1);
+#endif
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+void board_late_specific_init(void)
+{
+	gpio_set_value(GP_I2C3_J7_RESET, 0);
+}
+
+const struct button_key board_buttons[] = {
+	{"j3",	GP_J33_PIN3_INPUT,	'j', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/usd/usd.cfg u-boot-imx6/board/boundary/usd/usd.cfg
--- u-boot-2017.07/board/boundary/usd/usd.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd/usd.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/Kconfig u-boot-imx6/board/boundary/usd_mr2/Kconfig
--- u-boot-2017.07/board/boundary/usd_mr2/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_USD_MR2
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "usd_mr2"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "usd_mr2"
+
+config BOARD_LATE_SPECIFIC_INIT
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/MAINTAINERS u-boot-imx6/board/boundary/usd_mr2/MAINTAINERS
--- u-boot-2017.07/board/boundary/usd_mr2/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/usd_mr2/
+F:	include/configs/usd_mr2.h
+F:	configs/usd_mr2_q2g_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/Makefile u-boot-imx6/board/boundary/usd_mr2/Makefile
--- u-boot-2017.07/board/boundary/usd_mr2/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := usd_mr2.o
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/usd_mr2.c u-boot-imx6/board/boundary/usd_mr2/usd_mr2.c
--- u-boot-2017.07/board/boundary/usd_mr2/usd_mr2.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/usd_mr2.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,477 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL    (PAD_CTL_PUS_22K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+	PAD_CTL_ODE)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC4_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* AUDMUX3 */
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+
+	/* AUDMUX4 */
+	IOMUX_PAD_CTRL(DISP0_DAT20__AUD4_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__AUD4_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__AUD4_TXFS, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__AUD4_RXD, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ECSPI2 (ks8995 bridge) */
+	IOMUX_PAD_CTRL(DISP0_DAT19__ECSPI2_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__ECSPI2_MOSI, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS1		IMX_GPIO_NR(5, 9)
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP_OUTPUT),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+	/* pin 42 PHY nRST */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLDN),
+#define GPIRQ_ENET_PHY		IMX_GPIO_NR(1, 28)
+	IOMUX_PAD_CTRL(ENET_TX_EN__GPIO1_IO28, WEAK_PULLUP),
+
+	/* gpio_keys */
+#define GP_5V_STATUS		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLDN),
+#define GP_48V_STATUS		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLDN),
+#define GP_CH1_INPUT		IMX_GPIO_NR(1, 8)
+	IOMUX_PAD_CTRL(GPIO_8__GPIO1_IO08, WEAK_PULLUP),	/* CN6 PIN8 */
+#define GP_CH1_16V_FAULT	IMX_GPIO_NR(5, 5)
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, INPUT_FLOAT),
+#define GP_CH1_48V_FAULT	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, INPUT_FLOAT),
+
+#define GP_CH2_INPUT		IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLUP),	/* CN3 PIN8 */
+#define GP_CH2_16V_FAULT	IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, INPUT_FLOAT),
+#define GP_CH2_48V_FAULT	IMX_GPIO_NR(1, 7)
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, INPUT_FLOAT),
+
+	/* hdmi_cec */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* Hogs GPIO output assignments */
+#define GP_CH1_16V		IMX_GPIO_NR(5, 6)
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLDN_OUTPUT),
+#define GP_CH1_48V		IMX_GPIO_NR(4, 15)
+	IOMUX_PAD_CTRL(KEY_ROW4__GPIO4_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_CH1_RELAY_OUT	IMX_GPIO_NR(4, 23)
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLDN_OUTPUT),	/* CN6 */
+
+#define GP_CH2_16V		IMX_GPIO_NR(4, 31)
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLDN_OUTPUT),
+#define GP_CH2_48V		IMX_GPIO_NR(4, 11)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO4_IO11, WEAK_PULLDN_OUTPUT),
+#define GP_CH2_RELAY_OUT	IMX_GPIO_NR(4, 21)
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLDN_OUTPUT),	/* CN3 */
+
+
+#define GP_LED1			IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, WEAK_PULLDN_OUTPUT),
+
+	/* Hog Test points */
+#define GP_TP71			IMX_GPIO_NR(1, 25)
+	IOMUX_PAD_CTRL(ENET_CRS_DV__GPIO1_IO25, WEAK_PULLUP),
+#define GP_TP74			IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_TP86			IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+#define GP_TP87			IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+#define GP_TP88			IMX_GPIO_NR(4, 25)
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+#define GP_TP95			IMX_GPIO_NR(2, 30)
+	IOMUX_PAD_CTRL(EIM_EB2__GPIO2_IO30, WEAK_PULLUP),
+#define GP_TP96			IMX_GPIO_NR(5, 0)
+	IOMUX_PAD_CTRL(EIM_WAIT__GPIO5_IO00, WEAK_PULLUP),
+#define GP_TP100		IMX_GPIO_NR(4, 10)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO4_IO10, WEAK_PULLUP),
+#define GP_TP_R65		IMX_GPIO_NR(1, 30)
+	IOMUX_PAD_CTRL(ENET_TXD0__GPIO1_IO30, WEAK_PULLDN),
+#define GP_TP_R66		IMX_GPIO_NR(1, 29)
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN),
+
+	/* i2c1_sgtl5000 A */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_CODEC_A_G1		IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(EIM_DA1__GPIO3_IO01, WEAK_PULLUP_OUTPUT),
+#define GP_CODEC_A_G2		IMX_GPIO_NR(3, 0)
+	IOMUX_PAD_CTRL(EIM_DA0__GPIO3_IO00, WEAK_PULLUP_OUTPUT),
+#define GP_CODEC_A_MUTE_N	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_A_SHTDN_N	IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(EIM_DA3__GPIO3_IO03, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_A_FS1		IMX_GPIO_NR(5, 8)
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_A_FS2		IMX_GPIO_NR(5, 7)
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_CODEC_A_MIC_DET	IMX_GPIO_NR(5, 12)
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+
+	/* i2c1_sgtl5000 B */
+#define GP_CODEC_B_G1		IMX_GPIO_NR(4, 19)
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP_OUTPUT),
+#define GP_CODEC_B_G2		IMX_GPIO_NR(4, 18)
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP_OUTPUT),
+#define GP_CODEC_B_MUTE_N	IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_B_SHTDN_N	IMX_GPIO_NR(1, 15)
+	IOMUX_PAD_CTRL(SD2_DAT0__GPIO1_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_B_FS1		IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLDN_OUTPUT),
+#define GP_CODEC_B_FS2		IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLDN_OUTPUT),
+#define GPIRQ_CODEC_B_MIC_DET	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+	/* This output from CPU to max9709 B */
+#define GP_CODEC_B_SYNC		IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN_OUTPUT),
+	/* This is an input from max9709 B, goes to max7909 A */
+#define GP_CODEC_B_SYNC_CHAIN	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLDN_OUTPUT),
+
+	/* i2c2 ov5640 mipi Camera controls */
+	IOMUX_PAD_CTRL(GPIO_3__CCM_CLKO2, OUTPUT_40OHM),	/* mclk */
+#define GP_OV5640_MIPI_POWER_DOWN IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+#define GP_OV5640_MIPI_RESET	IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN),
+
+	/* i2c3 J7 */
+#define GP_I2C3_J7_RESET	IMX_GPIO_NR(1, 4)
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLUP),
+#define GPIRQ_I2C3_J7		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO_9__GPIO1_IO09, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLDN),
+#define GP_PCIE_DISABLE		IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLDN),
+
+	/* PWM4 - Backlight on LVDS connector: J5, pin 35 */
+#define GP_BACKLIGHT_LVDS	IMX_GPIO_NR(1, 18)
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLDN_OUTPUT),
+/* 0 is 8 bit */
+#define GP_LVDS_J5_PIN36	IMX_GPIO_NR(2, 23)
+	IOMUX_PAD_CTRL(EIM_CS0__GPIO2_IO23, WEAK_PULLDN_OUTPUT),
+
+	/* reg_usbotg_vbus */
+#define GP_REG_USBOTG		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* UART3 (J30) */
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* USBH1 */
+	IOMUX_PAD_CTRL(EIM_D30__USB_H1_OC, WEAK_PULLUP),
+
+	/* USBOTG */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC3_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP),
+
+	/* USDHC4 - emmc */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC4_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC4_PAD_CTRL),
+#define GP_EMMC_RESET		IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		return 0;
+	gpio_set_value(GP_REG_USBOTG, on);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS :
+	       (bus == 1 && cs == 1) ? GP_ECSPI2_CS1 : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_set_value(GP_BACKLIGHT_LVDS, enable);
+	gpio_set_value(GP_LVDS_J5_PIN36, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* ft5x06 */
+	VD_AUO_B101EW05(LVDS, fbp_detect_i2c, 2, 0x38),
+	VD_HANNSTAR7(LVDS, NULL, 2, 0x38),
+	VD_LG1280_800(LVDS, NULL, 2, 0x38),
+	VD_DT070BTFT(LVDS, NULL, 2, 0x38),
+	VD_WSVGA(LVDS, NULL, 2, 0x38),
+	VD_TM070JDHG30(LVDS, NULL, 2, 0x38),
+
+	/* ili210x */
+	VD_AMP1024_600(LVDS, fbp_detect_i2c, 2, 0x41),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+	VD_LG9_7(LVDS, NULL, 2, 0x04),
+
+	VD_SHARP_LQ101K1LY04(LVDS, NULL, 0, 0x00),
+	VD_WXGA(LVDS, NULL, 0, 0x00),
+	VD_LD070WSVGA(LVDS, NULL, 0, 0x00),
+	VD_WVGA(LVDS, NULL, 0, 0x00),
+	VD_AA065VE11(LVDS, NULL, 0, 0x00),
+	VD_VGA(LVDS, NULL, 0, 0x00),
+
+	/* uses both lvds connectors */
+	VD_1080P60(LVDS, NULL, 0, 0x00),
+	VD_1080P60_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	GP_CH1_16V,
+	GP_CH1_48V,
+	GP_CH1_RELAY_OUT,
+	GP_CH2_16V,
+	GP_CH2_48V,
+	GP_CH2_RELAY_OUT,
+	GP_LED1,
+	GP_CODEC_A_MUTE_N,
+	GP_CODEC_A_SHTDN_N,
+	GP_CODEC_A_FS1,
+	GP_CODEC_A_FS2,
+	GP_CODEC_B_MUTE_N,
+	GP_CODEC_B_SHTDN_N,
+	GP_CODEC_B_FS1,
+	GP_CODEC_B_FS2,
+	GP_CODEC_B_SYNC,
+	GP_OV5640_MIPI_RESET,	/* camera reset */
+	GP_I2C3_J7_RESET,
+	GP_PCIE_RESET,
+	GP_BACKLIGHT_LVDS,
+	GP_LVDS_J5_PIN36,
+	GP_REG_USBOTG,		/* disable USB otg power */
+	GP_EMMC_RESET,		/* hold in reset */
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+	GP_ECSPI2_CS1,
+	GP_CODEC_A_G1,
+	GP_CODEC_A_G2,
+	GP_CODEC_B_G1,
+	GP_CODEC_B_G2,
+	GP_OV5640_MIPI_POWER_DOWN,	/* camera power down */
+};
+
+static const unsigned short gpios_in[] = {
+	GPIRQ_ENET_PHY,
+	GP_5V_STATUS,
+	GP_48V_STATUS,
+	GP_CH1_INPUT,
+	GP_CH1_16V_FAULT,
+	GP_CH1_48V_FAULT,
+	GP_CH2_INPUT,
+	GP_CH2_16V_FAULT,
+	GP_CH2_48V_FAULT,
+	GP_TP71,
+	GP_TP74,
+	GP_TP86,
+	GP_TP87,
+	GP_TP88,
+	GP_TP95,
+	GP_TP96,
+	GP_TP100,
+	GP_TP_R65,
+	GP_TP_R66,
+	GPIRQ_CODEC_A_MIC_DET,
+	GPIRQ_CODEC_B_MIC_DET,
+	GP_CODEC_B_SYNC_CHAIN,
+	GPIRQ_I2C3_J7,
+	GP_PCIE_DISABLE,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+#ifdef CONFIG_CMD_FBPANEL
+	gpio_set_value(GP_I2C3_J7_RESET, 1);
+#endif
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+void board_late_specific_init(void)
+{
+	gpio_set_value(GP_I2C3_J7_RESET, 0);
+}
+
+const struct button_key board_buttons[] = {
+	{"tp71",	GP_TP71,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},	/* 8-bit eMMC */
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/usd_mr2_q1g.cfg u-boot-imx6/board/boundary/usd_mr2/usd_mr2_q1g.cfg
--- u-boot-2017.07/board/boundary/usd_mr2/usd_mr2_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/usd_mr2_q1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* ? board sample */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x427a0318
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x02740266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x430e031e
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x030a0258
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x41353a46
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3d373247
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x373b4033
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4335483c
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x000c0015
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00140011
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x000a001c
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00040014
+#define WALAT   0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/usd_mr2/usd_mr2_q2g.cfg u-boot-imx6/board/boundary/usd_mr2/usd_mr2_q2g.cfg
--- u-boot-2017.07/board/boundary/usd_mr2/usd_mr2_q2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/usd_mr2/usd_mr2_q2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x43100320
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x030a027d
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x03150326
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x03100258
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x42333842
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x3d383244
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x373a3c31
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4230443b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0012001b
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x001d0015
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00100022
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000d001b
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* This configuration not yet produced */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/utc/Kconfig u-boot-imx6/board/boundary/utc/Kconfig
--- u-boot-2017.07/board/boundary/utc/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/utc/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_UTC
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "utc"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "utc"
+
+config ENV_WLMAC
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/utc/MAINTAINERS u-boot-imx6/board/boundary/utc/MAINTAINERS
--- u-boot-2017.07/board/boundary/utc/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/utc/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+UTC BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/utc/
+F:	include/configs/utc.h
+F:	configs/utc_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/utc/Makefile u-boot-imx6/board/boundary/utc/Makefile
--- u-boot-2017.07/board/boundary/utc/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/utc/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2012-2013, Guennadi Liakhovetski <lg@denx.de>
+# (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
+# Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := utc.o
diff -Nru u-boot-2017.07/board/boundary/utc/utc.c u-boot-imx6/board/boundary/utc/utc.c
--- u-boot-2017.07/board/boundary/utc/utc.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/utc/utc.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <splash.h>
+#include <input.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define BUTTON_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* bt_rfkill */
+#define GP_BT_RFKILL_RESET	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP),
+
+	/* ENET pads that don't change for PHY reset */
+	IOMUX_PAD_CTRL(ENET_MDIO__ENET_MDIO, PAD_CTRL_ENET_MDIO),
+	IOMUX_PAD_CTRL(ENET_MDC__ENET_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(RGMII_TXC__RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD0__RGMII_TD0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD1__RGMII_TD1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD2__RGMII_TD2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TD3__RGMII_TD3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII_TX_CTL__RGMII_TX_CTL, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(ENET_REF_CLK__ENET_TX_CLK, PAD_CTRL_ENET_TX),
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+	IOMUX_PAD_CTRL(ENET_RXD0__GPIO1_IO27, WEAK_PULLUP),
+
+	/* gpio_Keys - Button assignments for J14 */
+#define GP_GPIOKEY_BACK		IMX_GPIO_NR(2, 2)
+	IOMUX_PAD_CTRL(NANDF_D2__GPIO2_IO02, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_HOME		IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(NANDF_D4__GPIO2_IO04, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_GPIOKEY_POWER	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_DOWN	IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+#define GP_GPIOKEY_VOL_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* PWM1 - Backlight on RGB connector: J15 */
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLUP),
+#define GP_BACKLIGHT_RGB IMX_GPIO_NR(1, 21)
+
+	/* PWM4 - Backlight on LVDS connector: J6 */
+	IOMUX_PAD_CTRL(SD1_CMD__GPIO1_IO18, WEAK_PULLUP),
+#define GP_BACKLIGHT_LVDS IMX_GPIO_NR(1, 18)
+
+	/* reg_wlan_en */
+#define GP_REG_WLAN_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN),
+
+	/* UART1 */
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+
+	/* UART2 */
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN),
+
+	/* USDHC2 - TiWi wl1271 */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+	/* USDHC3 - sdcard */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD		IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00 , WEAK_PULLUP),
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+
+	/* wl1271 */
+#define GPIRQ_WL1271_WL		IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(NANDF_CS1__GPIO6_IO14, WEAK_PULLDN),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static iomux_v3_cfg_t const rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000 */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 Camera, MIPI */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, J15 - RGB connector */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : -1;
+}
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lvds(const struct display_info_t *di, int enable)
+{
+	gpio_direction_output(GP_BACKLIGHT_LVDS, enable);
+}
+
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_BACKLIGHT_RGB, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* egalax_ts */
+	VD_HANNSTAR(LVDS, fbp_detect_i2c, 2, 0x04),
+
+	/* ft5x06 */
+	VD_WSVGA(LVDS, fbp_detect_i2c, 2, 0x38),
+
+	/* tsc2004 */
+	VD_CLAA_WVGA(LCD, fbp_detect_i2c, 2, 0x48),
+	VD_QVGA(LCD, NULL, 2, 0x48),
+
+	VD_WXGA_J(LVDS, NULL, 0, 0x00),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_RGMII_PHY_RESET,
+	/* Disable wifi */
+	GP_REG_WLAN_EN,
+	GP_BT_RFKILL_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,	/* SS1 of spi nor */
+};
+
+static const unsigned short gpios_in[] = {
+	GP_BACKLIGHT_LVDS,
+	GP_BACKLIGHT_RGB,
+	GPIRQ_WL1271_WL,
+	GP_USDHC3_CD,
+	GP_GPIOKEY_BACK,
+	GP_GPIOKEY_HOME,
+	GP_GPIOKEY_MENU,
+	GP_GPIOKEY_POWER,
+	GP_GPIOKEY_VOL_UP,
+	GP_GPIOKEY_VOL_DOWN,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"back",	GP_GPIOKEY_BACK,	'B', 1},
+	{"home",	GP_GPIOKEY_HOME,	'H', 1},
+	{"menu",	GP_GPIOKEY_MENU,	'M', 1},
+	{"search",	GP_GPIOKEY_POWER,	'S', 1},
+	{"volup",	GP_GPIOKEY_VOL_UP,	'V', 1},
+	{"voldown",	GP_GPIOKEY_VOL_DOWN,	'v', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
diff -Nru u-boot-2017.07/board/boundary/utc/utc_q1g.cfg u-boot-imx6/board/boundary/utc/utc_q1g.cfg
--- u-boot-2017.07/board/boundary/utc/utc_q1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/utc/utc_q1g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42720306
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026F0266
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x4273030A
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02740240
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x45393B3E
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x403A3747
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x40434541
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x473E4A3B
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0011000E
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x000E001B
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x00190015
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x00070018
+#define WALAT	0
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* H5TC2G63FFR-PBA */
+/* MT41K128M16JT-125 IT:K */
+#include "../common/mx6/1066mhz_128mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/vp/Kconfig u-boot-imx6/board/boundary/vp/Kconfig
--- u-boot-2017.07/board/boundary/vp/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/vp/Kconfig	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,24 @@
+if TARGET_VP
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "vp"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "vp"
+
+config BOARD_LATE_SPECIFIC_INIT
+	bool
+	default	y
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/vp/MAINTAINERS u-boot-imx6/board/boundary/vp/MAINTAINERS
--- u-boot-2017.07/board/boundary/vp/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/vp/MAINTAINERS	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+NITROGEN6_MAX BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/vp/
+F:	include/configs/vp.h
+F:	configs/vp_defconfig
+
diff -Nru u-boot-2017.07/board/boundary/vp/Makefile u-boot-imx6/board/boundary/vp/Makefile
--- u-boot-2017.07/board/boundary/vp/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/vp/Makefile	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,7 @@
+#
+# Copyright (C) 2014, Boundary Devices <info@boundarydevices.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := vp.o
diff -Nru u-boot-2017.07/board/boundary/vp/vp2g.cfg u-boot-imx6/board/boundary/vp/vp2g.cfg
--- u-boot-2017.07/board/boundary/vp/vp2g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/vp/vp2g.cfg	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM      spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+/* turn on power */
+DATA 4, 0x020e0734, 0x30b0
+
+/* turn off backlight */
+DATA 4, 0x020e0344, 5
+DATA 4, 0x020e072c, 0x30b0
+
+/* NC YET */
+#define MX6_MMDC_P0_MPDGCTRL0_VAL	0x42740304
+#define MX6_MMDC_P0_MPDGCTRL1_VAL	0x026e0265
+#define MX6_MMDC_P1_MPDGCTRL0_VAL	0x02750306
+#define MX6_MMDC_P1_MPDGCTRL1_VAL	0x02720244
+#define MX6_MMDC_P0_MPRDDLCTL_VAL	0x463d4041
+#define MX6_MMDC_P1_MPRDDLCTL_VAL	0x42413c47
+#define MX6_MMDC_P0_MPWRDLCTL_VAL	0x37414441
+#define MX6_MMDC_P1_MPWRDLCTL_VAL	0x4633473b
+#define MX6_MMDC_P0_MPWLDECTRL0_VAL	0x0025001f
+#define MX6_MMDC_P0_MPWLDECTRL1_VAL	0x00290027
+#define MX6_MMDC_P1_MPWLDECTRL0_VAL	0x001f002b
+#define MX6_MMDC_P1_MPWLDECTRL1_VAL	0x000f0029
+#define WALAT	1
+
+#include "../common/mx6/ddr-setup.cfg"
+#define RANK 0
+#define BUS_WIDTH 64
+/* BOM removed, not supported */
+#include "../common/mx6/1066mhz_256mx16.cfg"
+#include "../common/mx6/clocks.cfg"
diff -Nru u-boot-2017.07/board/boundary/vp/vp.c u-boot-imx6/board/boundary/vp/vp.c
--- u-boot-2017.07/board/boundary/vp/vp.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/vp/vp.c	2018-08-27 21:35:36.954138317 +0300
@@ -0,0 +1,546 @@
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/sys_proto.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/fbpanel.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/spi.h>
+#include <div64.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+#include <input.h>
+#include <splash.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define CEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define RGB_PAD_CTRL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm | \
+	PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC_PAD_CTRL	(USDHC_CLK_PAD_CTRL | PAD_CTL_PUS_47K_UP)
+
+/*
+ *
+ */
+static const iomux_v3_cfg_t init_pads[] = {
+	/* Main power on, High shuts down system */
+#define GP_MAIN_POWER_EN	IMX_GPIO_NR(1, 19)
+	IOMUX_PAD_CTRL(SD1_DAT2__GPIO1_IO19, WEAK_PULLDN),
+#define GP_LED_BLUE		IMX_GPIO_NR(2, 24)
+	IOMUX_PAD_CTRL(EIM_CS1__GPIO2_IO24, WEAK_PULLDN),
+
+	/* AUDMUX */
+	IOMUX_PAD_CTRL(CSI0_DAT7__AUD3_RXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT4__AUD3_TXC, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT5__AUD3_TXD, AUD_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT6__AUD3_TXFS, AUD_PAD_CTRL),
+
+	/* ECSPI1 */
+	IOMUX_PAD_CTRL(EIM_D17__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D18__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D16__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_CS1	IMX_GPIO_NR(3, 19)
+	IOMUX_PAD_CTRL(EIM_D19__GPIO3_IO19, WEAK_PULLUP), /* SS1 */
+
+	/* GPIO_KEYS */
+#define GP_MAIN_POWER_BUTTON	IMX_GPIO_NR(1, 2)
+	IOMUX_PAD_CTRL(GPIO_2__GPIO1_IO02, WEAK_PULLUP),
+#define GP_MENU		IMX_GPIO_NR(2, 1)
+	IOMUX_PAD_CTRL(NANDF_D1__GPIO2_IO01, BUTTON_PAD_CTRL),
+#define GP_BACK		IMX_GPIO_NR(4, 5)
+	IOMUX_PAD_CTRL(GPIO_19__GPIO4_IO05, BUTTON_PAD_CTRL),
+	/* Labeled Search (mapped to Power under Android) */
+#define GP_SEARCH	IMX_GPIO_NR(2, 3)
+	IOMUX_PAD_CTRL(NANDF_D3__GPIO2_IO03, BUTTON_PAD_CTRL),
+#define GP_VOLUME_UP	IMX_GPIO_NR(7, 13)
+	IOMUX_PAD_CTRL(GPIO_18__GPIO7_IO13, BUTTON_PAD_CTRL),
+
+	/* 2 momentary switches */
+#define GP_INPUT1		IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(KEY_COL1__GPIO4_IO08, WEAK_PULLUP),	/* SW3 gpio */
+#define GP_INPUT2		IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO4_IO09, WEAK_PULLUP),	/* SW2 gpio */
+
+	/* HDMI */
+	IOMUX_PAD_CTRL(EIM_A25__HDMI_TX_CEC_LINE, CEC_PAD_CTRL),
+
+	/* I2C3MUX */
+#define GP_I2C3_PCIE_EN		IMX_GPIO_NR(2, 25)
+	IOMUX_PAD_CTRL(EIM_OE__GPIO2_IO25, WEAK_PULLDN_OUTPUT),
+#define GP_I2C3_MAX77818_EN	IMX_GPIO_NR(3, 2)
+	IOMUX_PAD_CTRL(EIM_DA2__GPIO3_IO02, WEAK_PULLDN_OUTPUT),
+
+	/* I2C3 MAX77818 */
+#define GP_MAX77818_INOKB	IMX_GPIO_NR(3, 4)	/* INOKB, WCHG_VALID_INT */
+	IOMUX_PAD_CTRL(EIM_DA4__GPIO3_IO04, WEAK_PULLUP),
+#define GP_MAX77818_WCINOKB	IMX_GPIO_NR(3, 5)	/* WCINOKB, WCHG_INT */
+	IOMUX_PAD_CTRL(EIM_DA5__GPIO3_IO05, WEAK_PULLUP),
+#define GP_MAX77818_INTB	IMX_GPIO_NR(3, 6)	/* INTB, CHG_INT */
+	IOMUX_PAD_CTRL(EIM_DA6__GPIO3_IO06, WEAK_PULLUP),
+
+	/* I2C3 touchscreen connector(J55) */
+#define GP_TOUCH_RESET		IMX_GPIO_NR(2, 22)
+	IOMUX_PAD_CTRL(EIM_A16__GPIO2_IO22, WEAK_PULLDN_OUTPUT),
+#define GP_TOUCH_IRQ		IMX_GPIO_NR(2, 27)
+	IOMUX_PAD_CTRL(EIM_LBA__GPIO2_IO27, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET		IMX_GPIO_NR(6, 31)
+	IOMUX_PAD_CTRL(EIM_BCLK__GPIO6_IO31, WEAK_PULLDN_OUTPUT),
+
+	/* PWM1: Backlight on RGB connector */
+#define GP_RGB_BACKLIGHT	 IMX_GPIO_NR(1, 21)
+	IOMUX_PAD_CTRL(SD1_DAT3__GPIO1_IO21, WEAK_PULLDN_OUTPUT),
+
+	/* rtc - i2c1 */
+#define GP_RTC_RV4162_IRQ	IMX_GPIO_NR(4, 6)
+	IOMUX_PAD_CTRL(KEY_COL0__GPIO4_IO06, WEAK_PULLUP),
+
+
+	/* SGTL5000 */
+	IOMUX_PAD_CTRL(GPIO_0__CCM_CLKO1, OUTPUT_40OHM),	/* SGTL5000 sys_mclk */
+#define GP_SGTL5000_MUTE	IMX_GPIO_NR(1, 29)		/* Low is muted */
+	IOMUX_PAD_CTRL(ENET_TXD1__GPIO1_IO29, WEAK_PULLDN_OUTPUT),
+#define GP_HEADPHONE_DET	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(KEY_ROW0__GPIO4_IO07, WEAK_PULLUP),
+#define GP_LINE_IN_JACK_DETECT	IMX_GPIO_NR(1, 17)
+	IOMUX_PAD_CTRL(SD1_DAT1__GPIO1_IO17, WEAK_PULLUP),
+#define GP_MIC_DETECT	IMX_GPIO_NR(7, 8)
+	IOMUX_PAD_CTRL(SD3_RST__GPIO7_IO08, WEAK_PULLUP),
+
+	/* UART1  */
+	IOMUX_PAD_CTRL(SD3_DAT7__UART1_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT6__UART1_RX_DATA, UART_PAD_CTRL),
+
+	/* UART2 for debug */
+#ifndef CONFIG_SILENT_UART
+	IOMUX_PAD_CTRL(EIM_D26__UART2_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__UART2_RX_DATA, UART_PAD_CTRL),
+#else
+	IOMUX_PAD_CTRL(EIM_D26__GPIO3_IO26, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D27__GPIO3_IO27, UART_PAD_CTRL),
+#endif
+	/* UART3 - Broadcom Bluetooth*/
+	IOMUX_PAD_CTRL(EIM_D24__UART3_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D25__UART3_RX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D23__UART3_CTS_B, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(EIM_D31__UART3_RTS_B, UART_PAD_CTRL),
+
+	/* UART4 - GPS */
+	IOMUX_PAD_CTRL(CSI0_DAT12__UART4_TX_DATA, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(CSI0_DAT13__UART4_RX_DATA, UART_PAD_CTRL),
+#define GP_GPS_RESET		IMX_GPIO_NR(6, 0)
+	IOMUX_PAD_CTRL(CSI0_DAT14__GPIO6_IO00, WEAK_PULLDN_OUTPUT),
+#define GP_GPS_IRQ		IMX_GPIO_NR(6, 1)
+	IOMUX_PAD_CTRL(CSI0_DAT15__GPIO6_IO01, WEAK_PULLUP),
+#define GP_GPS_HEARTBEAT	IMX_GPIO_NR(6, 2)
+	IOMUX_PAD_CTRL(CSI0_DAT16__GPIO6_IO02, WEAK_PULLUP),
+
+	/* USBH1 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
+	IOMUX_PAD_CTRL(GPIO_17__GPIO7_IO12, WEAK_PULLDN_OUTPUT),	/* USB Hub Reset for USB2512 4 port hub */
+#define GP_USB_DN1_PWR_EN	IMX_GPIO_NR(1, 4)		/* low is off */
+	IOMUX_PAD_CTRL(GPIO_4__GPIO1_IO04, WEAK_PULLDN_OUTPUT),
+#define GP_5V_EN		IMX_GPIO_NR(1, 7)		/* usb and hdmi 5v*/
+	IOMUX_PAD_CTRL(GPIO_7__GPIO1_IO07, WEAK_PULLDN_OUTPUT),
+	/*
+	 * port1 - DN1 power controlled by GPIO_4 on J6
+	 * port2 - usb power controlled by hub on J7
+	 * port3 - usb power always on, on J1 and PCIe
+	 */
+
+	/* USBOTG - J3 */
+	IOMUX_PAD_CTRL(GPIO_1__USB_OTG_ID, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(KEY_COL4__USB_OTG_OC, WEAK_PULLUP),
+#define GP_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+	IOMUX_PAD_CTRL(EIM_D22__GPIO3_IO22, WEAK_PULLDN_OUTPUT),
+
+	/* USDHC2:  Broadcom Wifi */
+	IOMUX_PAD_CTRL(SD2_CLK__SD2_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__SD2_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT0__SD2_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT1__SD2_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT2__SD2_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DAT3__SD2_DATA3, USDHC_PAD_CTRL),
+
+#define GP_BRM_BT_RESET		IMX_GPIO_NR(6, 8)
+	IOMUX_PAD_CTRL(NANDF_ALE__GPIO6_IO08, WEAK_PULLDN_OUTPUT),
+#define GP_BRM_BT_EN		IMX_GPIO_NR(6, 15)
+	IOMUX_PAD_CTRL(NANDF_CS2__GPIO6_IO15, WEAK_PULLDN_OUTPUT),
+#define GP_BRM_BT_WAKE_IRQ	IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(NANDF_D7__GPIO2_IO07, WEAK_PULLUP),
+#define GP_BRM_BT_WAKEUP	IMX_GPIO_NR(6, 16)
+	IOMUX_PAD_CTRL(NANDF_CS3__GPIO6_IO16, WEAK_PULLDN),
+
+#define GP_BRM_WL_WAKE_IRQ	IMX_GPIO_NR(6, 11)
+	IOMUX_PAD_CTRL(NANDF_CS0__GPIO6_IO11, WEAK_PULLDN),
+#define GP_BRM_CLOCK_REQUEST	IMX_GPIO_NR(6, 9)
+	IOMUX_PAD_CTRL(NANDF_WP_B__GPIO6_IO09, WEAK_PULLUP),
+#define GP_BRM_WL_EN		IMX_GPIO_NR(6, 7)
+	IOMUX_PAD_CTRL(NANDF_CLE__GPIO6_IO07, WEAK_PULLDN_OUTPUT),
+//	IOMUX_PAD_CTRL(SD1_CLK__OSC32K_32K_OUT, OUTPUT_40OHM),	/* slow clock */
+
+	/* USDHC3 - micro sd */
+	IOMUX_PAD_CTRL(SD3_CLK__SD3_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__SD3_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT0__SD3_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT1__SD3_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT2__SD3_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DAT3__SD3_DATA3, USDHC_PAD_CTRL),
+#define GP_USDHC3_CD	IMX_GPIO_NR(7, 0)
+	IOMUX_PAD_CTRL(SD3_DAT5__GPIO7_IO00, WEAK_PULLUP), /* CD */
+
+	/* USDHC4 - eMMC */
+	IOMUX_PAD_CTRL(SD4_CLK__SD4_CLK, USDHC_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__SD4_CMD, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT0__SD4_DATA0, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT1__SD4_DATA1, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT2__SD4_DATA2, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT3__SD4_DATA3, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT4__SD4_DATA4, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT5__SD4_DATA5, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT6__SD4_DATA6, USDHC_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DAT7__SD4_DATA7, USDHC_PAD_CTRL),
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(NANDF_D6__GPIO2_IO06, WEAK_PULLDN_OUTPUT),
+};
+
+#ifdef CONFIG_CMD_FBPANEL
+static const iomux_v3_cfg_t rgb_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__IPU1_DI0_DISP_CLK, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DI0_PIN15__IPU1_DI0_PIN15, RGB_PAD_CTRL),	/* DRDY */
+	IOMUX_PAD_CTRL(DI0_PIN2__IPU1_DI0_PIN02, RGB_PAD_CTRL),		/* HSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN3__IPU1_DI0_PIN03, RGB_PAD_CTRL),		/* VSYNC */
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, RGB_PAD_CTRL),		/* Contrast */
+	IOMUX_PAD_CTRL(DISP0_DAT0__IPU1_DISP0_DATA00, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT1__IPU1_DISP0_DATA01, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT2__IPU1_DISP0_DATA02, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT3__IPU1_DISP0_DATA03, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT4__IPU1_DISP0_DATA04, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT5__IPU1_DISP0_DATA05, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT6__IPU1_DISP0_DATA06, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT7__IPU1_DISP0_DATA07, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT8__IPU1_DISP0_DATA08, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT9__IPU1_DISP0_DATA09, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT10__IPU1_DISP0_DATA10, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT11__IPU1_DISP0_DATA11, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT12__IPU1_DISP0_DATA12, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT13__IPU1_DISP0_DATA13, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT14__IPU1_DISP0_DATA14, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT15__IPU1_DISP0_DATA15, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT16__IPU1_DISP0_DATA16, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT17__IPU1_DISP0_DATA17, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT18__IPU1_DISP0_DATA18, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT19__IPU1_DISP0_DATA19, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT20__IPU1_DISP0_DATA20, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT21__IPU1_DISP0_DATA21, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT22__IPU1_DISP0_DATA22, RGB_PAD_CTRL),
+	IOMUX_PAD_CTRL(DISP0_DAT23__IPU1_DISP0_DATA23, RGB_PAD_CTRL),
+};
+#endif
+
+static const iomux_v3_cfg_t rgb_gpio_pads[] = {
+	IOMUX_PAD_CTRL(DI0_DISP_CLK__GPIO4_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN15__GPIO4_IO17, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN2__GPIO4_IO18, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN3__GPIO4_IO19, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DI0_PIN4__GPIO4_IO20, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT0__GPIO4_IO21, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT1__GPIO4_IO22, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT2__GPIO4_IO23, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT3__GPIO4_IO24, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT4__GPIO4_IO25, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT5__GPIO4_IO26, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT6__GPIO4_IO27, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT7__GPIO4_IO28, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT8__GPIO4_IO29, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT9__GPIO4_IO30, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT10__GPIO4_IO31, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT11__GPIO5_IO05, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT12__GPIO5_IO06, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT13__GPIO5_IO07, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT14__GPIO5_IO08, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT15__GPIO5_IO09, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT16__GPIO5_IO10, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT17__GPIO5_IO11, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT18__GPIO5_IO12, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT19__GPIO5_IO13, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT20__GPIO5_IO14, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT21__GPIO5_IO15, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT22__GPIO5_IO16, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(DISP0_DAT23__GPIO5_IO17, WEAK_PULLUP),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	/* I2C1, SGTL5000, RTC(rv4162) */
+	I2C_PADS_INFO_ENTRY(I2C1, EIM_D21, 3, 21, EIM_D28, 3, 28, I2C_PAD_CTRL),
+	/* I2C2 - hdmi */
+	I2C_PADS_INFO_ENTRY(I2C2, KEY_COL3, 4, 12, KEY_ROW3, 4, 13, I2C_PAD_CTRL),
+	/* I2C3, Charger, PCIe */
+	I2C_PADS_INFO_ENTRY(I2C3, GPIO_5, 1, 05, GPIO_16, 7, 11, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_USB_EHCI_MX6
+static void charge_from_usb(int enable)
+{
+	u8 val8 = enable ? 0x27 : 7;
+	u8 orig_i2c_bus = i2c_get_bus_num();
+
+	i2c_set_bus_num(2);
+	i2c_write(0x69, 0xc3, 1, &val8, 1);
+	i2c_set_bus_num(orig_i2c_bus);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	if (port) {
+		/* Reset USB hub */
+		gpio_direction_output(GP_USB_HUB_RESET, 0);
+		mdelay(2);
+		gpio_set_value(GP_USB_HUB_RESET, 1);
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	int gp = port ? GP_USB_DN1_PWR_EN : GP_USB_OTG_PWR;
+
+	if (!port && on)
+		charge_from_usb(0);
+	gpio_set_value(gp, on);
+	if (!port && !on)
+		charge_from_usb(1);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC3_CD},
+	{.esdhc_base = USDHC4_BASE_ADDR, .bus_width = 8,
+			.gp_reset = GP_EMMC_RESET},
+};
+#endif
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_CS1 : -1;
+}
+
+#endif
+
+#ifdef CONFIG_CMD_FBPANEL
+void board_enable_lcd(const struct display_info_t *di, int enable)
+{
+	if (enable)
+		SETUP_IOMUX_PADS(rgb_pads);
+	else
+		SETUP_IOMUX_PADS(rgb_gpio_pads);
+	gpio_direction_output(GP_RGB_BACKLIGHT, enable);
+}
+
+static const struct display_info_t displays[] = {
+	/* hdmi */
+	VD_1280_720M_60(HDMI, fbp_detect_i2c, 1, 0x50),
+	VD_1920_1080M_60(HDMI, NULL, 1, 0x50),
+	VD_1024_768M_60(HDMI, NULL, 1, 0x50),
+
+	/* tsc2004 */
+	VD_OKAYA_480_272(LCD, fbp_detect_i2c, 2, 0x48),
+};
+#define display_cnt	ARRAY_SIZE(displays)
+#else
+#define displays	NULL
+#define display_cnt	0
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_MAIN_POWER_EN,
+	GP_RGB_BACKLIGHT,
+	GP_BRM_WL_EN,		/* disable wireless */
+	GP_BRM_BT_EN,	 	/* disable bluetooth */
+	GP_SGTL5000_MUTE,	/* MUTE */
+	GP_LED_BLUE,
+	GP_TOUCH_RESET,
+	GP_PCIE_RESET,
+	GP_I2C3_PCIE_EN,
+	GP_GPS_RESET,
+	GP_USB_HUB_RESET,
+	GP_USB_DN1_PWR_EN,
+	GP_USB_OTG_PWR,		/* disable USB otg power */
+	GP_BRM_BT_RESET,
+	GP_BRM_BT_EN,
+	GP_BRM_WL_EN,
+	GP_EMMC_RESET,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_CS1,
+	GP_I2C3_MAX77818_EN,
+};
+
+static const unsigned short gpios_out_high2[] = {
+	GP_5V_EN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_HEADPHONE_DET,
+	GP_LINE_IN_JACK_DETECT,
+	GP_MIC_DETECT,
+	GP_MENU,
+	GP_BACK,
+	GP_SEARCH,
+	GP_VOLUME_UP,
+	GP_INPUT1,
+	GP_INPUT2,
+	GP_BRM_WL_WAKE_IRQ,
+	GP_TOUCH_IRQ,
+	GP_RTC_RV4162_IRQ,
+	GP_MAIN_POWER_BUTTON,
+	GP_MAX77818_INOKB,
+	GP_MAX77818_WCINOKB,
+	GP_MAX77818_INTB,
+	GP_GPS_IRQ,
+	GP_GPS_HEARTBEAT,
+	GP_BRM_BT_WAKE_IRQ,
+	GP_BRM_BT_WAKEUP,
+	GP_BRM_WL_WAKE_IRQ,
+	GP_BRM_CLOCK_REQUEST,
+	GP_USDHC3_CD,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	SETUP_IOMUX_PADS(rgb_gpio_pads);
+	return 0;
+}
+
+void board_poweroff(void)
+{
+	struct snvs_regs *snvs = (struct snvs_regs *)(SNVS_BASE_ADDR);
+
+	/* Doing both gpio1:19 and pmic_req makes the board not turn on again */
+//	gpio_set_value(GP_MAIN_POWER_EN, 1);
+	writel(0x60, &snvs->lpcr);
+	mdelay(500);
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, IOMUXC_GPR1_OTG_ID_GPIO1,
+			displays, display_cnt, 0);
+
+	set_gpios(gpios_out_high2, ARRAY_SIZE(gpios_out_high2), 1);
+	return 0;
+}
+
+static unsigned long long us_to_tick(unsigned long long usec)
+{
+        usec = usec * get_tbclk() + 999999;
+        do_div(usec, 1000000);
+
+        return usec;
+}
+
+void board_late_specific_init(void)
+{
+	unsigned long long stop = get_ticks() + us_to_tick(800000);
+	int reason = *(int *)(CONFIG_RESET_CAUSE_ADDR + 4);
+
+	/* return if not power-on reset */
+	if ((reason != 0x01) && (reason != 0x11))
+		return;
+
+	while (get_ticks() < stop) {
+		int ret = gpio_get_value(GP_MAIN_POWER_BUTTON);
+		if (ret) {
+			printf("On button not held\n");
+			board_poweroff();
+		}
+		mdelay(10);
+	}
+}
+
+const struct button_key board_buttons[] = {
+	{"input1",	GP_INPUT1,	'1', 1},
+	{"input2",	GP_INPUT2,	'2', 1},
+	{"power",	GP_MAIN_POWER_BUTTON,	'P', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"mmc0",	MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"mmc1",	MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,		0},
+};
+#endif
+
+static int _do_poweroff(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	board_poweroff();
+	return 0;
+}
+
+U_BOOT_CMD(
+	poweroff, 70, 0, _do_poweroff,
+	"power down board",
+	""
+);
diff -Nru u-boot-2017.07/board/boundary/ys/Kconfig u-boot-imx6/board/boundary/ys/Kconfig
--- u-boot-2017.07/board/boundary/ys/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/Kconfig	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,20 @@
+if TARGET_YS
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_BOARD
+	default "ys"
+
+config SYS_VENDOR
+	default "boundary"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "ys"
+
+source "board/boundary/common/Kconfig"
+
+endif
diff -Nru u-boot-2017.07/board/boundary/ys/MAINTAINERS u-boot-imx6/board/boundary/ys/MAINTAINERS
--- u-boot-2017.07/board/boundary/ys/MAINTAINERS	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/MAINTAINERS	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,6 @@
+YS BOARD
+M:	Troy Kisky <troy.kisky@boundarydevices.com>
+S:	Maintained
+F:	board/boundary/ys/
+F:	include/configs/ys.h
+F:	configs/ys_defconfig
diff -Nru u-boot-2017.07/board/boundary/ys/Makefile u-boot-imx6/board/boundary/ys/Makefile
--- u-boot-2017.07/board/boundary/ys/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/Makefile	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,6 @@
+# (C) Copyright 2017 Boundary Devices, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := ys.o
diff -Nru u-boot-2017.07/board/boundary/ys/ys_1g.cfg u-boot-imx6/board/boundary/ys/ys_1g.cfg
--- u-boot-2017.07/board/boundary/ys/ys_1g.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/ys_1g.cfg	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2017 Boundary Devices, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/crm_regs.h"
+
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+BOOT_FROM	spi
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* enable cko1 as 32k for slow clock */
+DATA 4, CCM_CCOSR, 0x0000008e
+
+/* Enable all clocks */
+DATA 4, CCM_CCGR0, 0xffffffff
+DATA 4, CCM_CCGR1, 0xffffffff
+DATA 4, CCM_CCGR2, 0xffffffff
+DATA 4, CCM_CCGR3, 0xffffffff
+DATA 4, CCM_CCGR4, 0xffffffff
+DATA 4, CCM_CCGR5, 0xffffffff
+DATA 4, CCM_CCGR6, 0xffffffff
+DATA 4, CCM_CCGR7, 0xffffffff
+
+/* IOMUX - DDR IO Type */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000c0000
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+
+/* Clock */
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00000030
+
+/* Address */
+DATA 4, MX6_IOM_DRAM_CAS, 0x00000020
+DATA 4, MX6_IOM_DRAM_RAS, 0x00000020
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000020
+
+/* Control */
+DATA 4, MX6_IOM_DRAM_RESET, 0x00000020
+
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00000020
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00000020
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000020
+
+/* Data Strobe */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000028
+
+/* Data */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00000028
+
+/* Calibrations - ZQ */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+
+/* Calibration settings */
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x41380128
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x0124011C
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x3E3E4246
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x34363838
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001D001E
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001A0013
+
+/* Read data bit delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+
+/* Complete calibration by forced measurement */
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+
+/* MMDC init - DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002d
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x676b52f3
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb66d8b63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00011740
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026d2
+DATA 4, MX6_MMDC_P0_MDOR, 0x006b1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556d
+
+DATA 4, MX6_MMDC_P0_MDASP, 0x0000005f
+DATA 4, MX6_MMDC_P0_MDCTL, 0x84190000
+
+/* Initialize MT41K256M16HA-125 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x05208030	/* MR0 */
+/* DDR device ZQ calibration */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+
+/* Final DDR setup, before operation start */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00000800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00011117
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
diff -Nru u-boot-2017.07/board/boundary/ys/ys_512m.cfg u-boot-imx6/board/boundary/ys/ys_512m.cfg
--- u-boot-2017.07/board/boundary/ys/ys_512m.cfg	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/ys_512m.cfg	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2017 Boundary Devices, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/* MT41K128M16JT-125 IT:K */
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/crm_regs.h"
+
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+BOOT_FROM	spi
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* enable cko1 as 32k for slow clock */
+DATA 4, CCM_CCOSR, 0x0000008e
+
+/* Enable all clocks */
+DATA 4, CCM_CCGR0, 0xffffffff
+DATA 4, CCM_CCGR1, 0xffffffff
+DATA 4, CCM_CCGR2, 0xffffffff
+DATA 4, CCM_CCGR3, 0xffffffff
+DATA 4, CCM_CCGR4, 0xffffffff
+DATA 4, CCM_CCGR5, 0xffffffff
+DATA 4, CCM_CCGR6, 0xffffffff
+DATA 4, CCM_CCGR7, 0xffffffff
+
+/* IOMUX - DDR IO Type */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000c0000
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+
+/* Clock */
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00000030
+
+/* Address */
+DATA 4, MX6_IOM_DRAM_CAS, 0x00000020
+DATA 4, MX6_IOM_DRAM_RAS, 0x00000020
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000020
+
+/* Control */
+DATA 4, MX6_IOM_DRAM_RESET, 0x00000020
+
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00000020
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00000020
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000020
+
+/* Data Strobe */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000028
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000028
+
+/* Data */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000028
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00000028
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00000028
+
+/* Calibrations - ZQ */
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xa1390003
+
+/*
+ * Calibration settings - 4 board sample
+ * 00:19:b8:03:11:24
+ * 00:19:b8:03:17:2a
+ * 00:19:b8:03:17:2c
+ * 00:19:b8:03:17:2e
+ */
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x41400133
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x01310126
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x42434547
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x38383b36
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001c0019
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0016000f
+
+/* Read data bit delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+
+/* Complete calibration by forced measurement */
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+
+/*
+ * Initialize MT41K128M16HA-125
+ * 14 row + 3 bank + 10 col + 0 rank + 2 width = 29 = 512 MB
+ * tRCD 13125 ps
+ * tRP 13125 ps
+ * tCL 13125 ps
+ * 396M DDR clock = .396G = 2525.2ps/clocks
+ * 13125ps / 2525.2ps/clocks = 5.198 clocks
+ */
+
+/* MMDC init - DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002d
+
+/*
+ * tRFC:0x3f: 64(0x40) clocks		(160000/2525.2)
+ * tXS:0x43: 68(0x44) clocks		(170000/2525.2)
+ * tXP:b'010': 3 clocks			(7500/2525.2)
+ * tXPDLL:b'1001': 10(0xa) clocks	(24000/2525.2)
+ * tFAW:b'01010': 11(0x0b) clocks	(27000/2525.2)
+ * tCL:b'0011': 6 clocks		(13125/2525.2)
+ */
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x3f4352a3
+/*
+ * tRCD:b'101': 6 clocks		(13125/2525.2)
+ * tRP:b'101': 6 clocks			(13125/2525.2)
+ * tRC:b'10100': 21(0x15) clocks	(50625/2525.2)
+ * tRAS:b'01110': 15(0x0f) clocks	(37500/2525.2)
+ * tRPA:b'1': 7 clocks			(tRP[+1]) 6
+ * b'000'
+ * tWR:b'101': 6 clocks			(15000/2525.2)
+ * tMRD:b'1011': 12(0xc) clocks		(min 4 clocks)4
+ * b'00'
+ * tCWL:b'011': 5 clocks		(tCL-1)
+ */
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xb68e8b63
+/*
+ * b'0000000'
+ * tDLLK:0x1ff(9 bits), 512(0x200) clocks (Jedec for DDR3)
+ * b'0000000'
+ * tRTP:b'011': 4 clocks		(7500/2525.2), min 4
+ * tWTR:same bank b'011': 4 clocks	(7500/2525.2), min 4
+ * tRRD:b'011': 4 clocks		(5000/2525.2), min 4
+ */
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01ff00db
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00011740
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
+/*
+ * RTW_SAME: 2 cycles,
+ * WTR_DIFF: 3 cycles,
+ * WTW_DIFF: 3 cycles,
+ * RTW_DIFF: 2 cycles,
+ * RTR_DIFF: 2 cycles
+ */
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026d2
+/*
+ * tXPR:0x43: 68(0x44) cycles,	(170000/2525.2), min 5
+ * SDE_to_RST:0x10: 14 cycles, (Jedec)
+ * RST_to_CKE:0x23: 33 cycles	(Jedec)
+ */
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556d
+
+/* end of CS0 US 0xa0000000-1  */
+DATA 4, MX6_MMDC_P0_MDASP, 0x0000004f
+/* row:14 bits */
+DATA 4, MX6_MMDC_P0_MDCTL, 0x83190000
+
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032	/* MR2 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033	/* MR3 */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031	/* MR1 */
+/*
+ * b'1' - dll on
+ * b'010' - tWR 6 clocks
+ * b'1' - dll reset
+ * b'0'
+ * b'01000' - CAS 6
+ * b'00' Fixed BC4
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x15208030	/* MR0 */
+
+/* DDR device ZQ calibration */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+
+/* Final DDR setup, before operation start */
+/*
+ * Need 8192 cycles in 64ms, or 128K/sec, 4/ sec/32k
+ * b'01' - 32 Khz
+ * b'011' - 4 refreshes
+ */
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
diff -Nru u-boot-2017.07/board/boundary/ys/ys.c u-boot-imx6/board/boundary/ys/ys.c
--- u-boot-2017.07/board/boundary/ys/ys.c	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/board/boundary/ys/ys.c	2018-08-27 21:35:36.957471634 +0300
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2017 Boundary Devices, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include "../common/bd_common.h"
+#include "../common/padctrl.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define AUD_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define CSI_PAD_CTL	PAD_CTL_DSE_120ohm
+
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_ODE)
+
+#define LCDIF_PAD_CTL	PAD_CTL_DSE_120ohm
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC2_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define USDHC3_PAD_CTRL (PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST | PAD_CTL_LVE)
+
+/* External pullup to 1.8V, input (release), out low(asserted) */
+#define USDHC3_PAD_CTRL_RST (PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SRE_SLOW)
+
+#define USDHC_CLK_PAD_CTRL (PAD_CTL_SPEED_LOW | \
+	PAD_CTL_DSE_80ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+static const iomux_v3_cfg_t init_pads[] = {
+	/* ECSPI1 (serial nor eeprom) */
+	IOMUX_PAD_CTRL(KEY_COL1__ECSPI1_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW0__ECSPI1_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_COL0__ECSPI1_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI1_NOR_CS	IMX_GPIO_NR(2, 16)
+	IOMUX_PAD_CTRL(KEY_ROW1__GPIO2_IO_16, WEAK_PULLUP),
+
+	/* ECSPI2 */
+	IOMUX_PAD_CTRL(SD4_CLK__ECSPI2_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_CMD__ECSPI2_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA1__ECSPI2_SCLK, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA3__ECSPI2_RDY, SPI_PAD_CTRL),
+#define GP_ECSPI2_CS	IMX_GPIO_NR(6, 14)
+	IOMUX_PAD_CTRL(SD4_DATA0__GPIO6_IO_14, WEAK_PULLUP),
+
+	/* ECSPI3 */
+	IOMUX_PAD_CTRL(SD4_DATA6__ECSPI3_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA5__ECSPI3_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD4_DATA4__ECSPI3_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI3_CS	IMX_GPIO_NR(6, 21)
+	IOMUX_PAD_CTRL(SD4_DATA7__GPIO6_IO_21, WEAK_PULLUP),
+
+	/* ECSPI5 */
+	IOMUX_PAD_CTRL(QSPI1A_SS1_B__ECSPI5_MISO, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(QSPI1A_DQS__ECSPI5_MOSI, SPI_PAD_CTRL),
+	IOMUX_PAD_CTRL(QSPI1B_SS1_B__ECSPI5_SCLK, SPI_PAD_CTRL),
+#define GP_ECSPI5_CS	IMX_GPIO_NR(4, 28)
+	IOMUX_PAD_CTRL(QSPI1B_DQS__GPIO4_IO_28, SPI_PAD_CTRL),
+
+	/* enet phy */
+	IOMUX_PAD_CTRL(ENET1_MDC__ENET1_MDC, PAD_CTRL_ENET_MDC),
+	IOMUX_PAD_CTRL(ENET1_MDIO__ENET1_MDIO, PAD_CTRL_ENET_MDIO),
+
+	/* fec1 */
+	IOMUX_PAD_CTRL(RGMII1_TD0__ENET1_TX_DATA_0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD1__ENET1_TX_DATA_1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD2__ENET1_TX_DATA_2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TD3__ENET1_TX_DATA_3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TXC__ENET1_RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII1_TX_CTL__ENET1_TX_EN, PAD_CTRL_ENET_TX),
+	/* AR8035 PHY Reset */
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(2, 7)
+	IOMUX_PAD_CTRL(ENET2_CRS__GPIO2_IO_7, WEAK_PULLUP),
+#define GP_RGMII_PHY_INT	IMX_GPIO_NR(2, 4)
+	IOMUX_PAD_CTRL(ENET1_RX_CLK__GPIO2_IO_4, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET1_TX_CLK__GPIO2_IO_5, WEAK_PULLUP),
+
+	/* fec2 */
+	IOMUX_PAD_CTRL(RGMII2_TD0__ENET2_TX_DATA_0, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD1__ENET2_TX_DATA_1, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD2__ENET2_TX_DATA_2, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TD3__ENET2_TX_DATA_3, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TXC__ENET2_RGMII_TXC, PAD_CTRL_ENET_TX),
+	IOMUX_PAD_CTRL(RGMII2_TX_CTL__ENET2_TX_EN, PAD_CTRL_ENET_TX),
+	/* AR8035 PHY Reset */
+#define GP_RGMII2_PHY_RESET	IMX_GPIO_NR(2, 6)
+	IOMUX_PAD_CTRL(ENET2_COL__GPIO2_IO_6, WEAK_PULLUP),
+#define GP_RGMII2_PHY_INT	IMX_GPIO_NR(2, 8)
+	IOMUX_PAD_CTRL(ENET2_RX_CLK__GPIO2_IO_8, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(ENET2_TX_CLK__GPIO2_IO_9, WEAK_PULLUP),
+
+	/* hogs - GPIO */
+#define GP_TERM_ON_OFF		IMX_GPIO_NR(1, 13)
+	IOMUX_PAD_CTRL(GPIO1_IO13__GPIO1_IO_13, WEAK_PULLDN_OUTPUT),
+#define GP_485_TERM_CTRL	IMX_GPIO_NR(3, 1)
+	IOMUX_PAD_CTRL(LCD1_DATA00__GPIO3_IO_1, WEAK_PULLDN_OUTPUT),
+#define GP_RESET_DSP_N		IMX_GPIO_NR(3, 3)
+	IOMUX_PAD_CTRL(LCD1_DATA02__GPIO3_IO_3, WEAK_PULLUP_OUTPUT),
+#define GP_485_DIR		IMX_GPIO_NR(3, 4)
+	IOMUX_PAD_CTRL(LCD1_DATA03__GPIO3_IO_4, WEAK_PULLDN_OUTPUT),
+#define GP_PWR_SYNC		IMX_GPIO_NR(3, 6)
+	IOMUX_PAD_CTRL(LCD1_DATA05__GPIO3_IO_6, WEAK_PULLDN_OUTPUT),
+#define GP_SERVICE_LED		IMX_GPIO_NR(3, 7)
+	IOMUX_PAD_CTRL(LCD1_DATA06__GPIO3_IO_7, WEAK_PULLDN_OUTPUT),
+#define GP_NETWORK_LED		IMX_GPIO_NR(3, 9)
+	IOMUX_PAD_CTRL(LCD1_DATA08__GPIO3_IO_9, WEAK_PULLDN_OUTPUT),
+#define GP_POWER_OK_VDSP	IMX_GPIO_NR(3, 10)
+	IOMUX_PAD_CTRL(LCD1_DATA09__GPIO3_IO_10, WEAK_PULLDN_OUTPUT),
+#define GP_SYSTEM_LED		IMX_GPIO_NR(3, 11)
+	IOMUX_PAD_CTRL(LCD1_DATA10__GPIO3_IO_11, WEAK_PULLDN_OUTPUT),
+#define GP_CUST_START		IMX_GPIO_NR(3, 12)
+	IOMUX_PAD_CTRL(LCD1_DATA11__GPIO3_IO_12, WEAK_PULLDN_OUTPUT),
+
+	/* hogs - Test points */
+#define GP_TP51			IMX_GPIO_NR(4, 24)
+	IOMUX_PAD_CTRL(QSPI1B_DATA0__GPIO4_IO_24, WEAK_PULLUP),
+#define GP_TP83			IMX_GPIO_NR(4, 29)
+	IOMUX_PAD_CTRL(QSPI1B_SCLK__GPIO4_IO_29, WEAK_PULLUP),
+#define GP_TP92			IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(QSPI1A_SS0_B__GPIO4_IO_22, WEAK_PULLUP),
+
+	/* i2c1 - rtc RV4162 irq */
+#define GPIRQ_RTC_RV4162	IMX_GPIO_NR(4, 30)
+	IOMUX_PAD_CTRL(QSPI1B_SS0_B__GPIO4_IO_30, WEAK_PULLUP),
+
+	/* PCIe */
+#define GP_PCIE_RESET	IMX_GPIO_NR(4, 7)
+	IOMUX_PAD_CTRL(NAND_DATA03__GPIO4_IO_7, WEAK_PULLUP),
+#define GP_PCIE_DISABLE	IMX_GPIO_NR(4, 8)
+	IOMUX_PAD_CTRL(NAND_DATA04__GPIO4_IO_8, WEAK_PULLUP),
+#define GP_PCIE_WAKE	IMX_GPIO_NR(4, 9)
+	IOMUX_PAD_CTRL(NAND_DATA05__GPIO4_IO_9, WEAK_PULLUP),
+
+	/* uart1 */
+	IOMUX_PAD_CTRL(GPIO1_IO04__UART1_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO05__UART1_RX, UART_PAD_CTRL),
+
+	/* uart2 */
+	IOMUX_PAD_CTRL(GPIO1_IO06__UART2_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(GPIO1_IO07__UART2_RX, UART_PAD_CTRL),
+
+	/* uart3 */
+	IOMUX_PAD_CTRL(NAND_DATA07__UART3_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(NAND_DATA06__UART3_RX, UART_PAD_CTRL),
+
+	/* uart5 */
+	IOMUX_PAD_CTRL(KEY_COL3__UART5_TX, UART_PAD_CTRL),
+	IOMUX_PAD_CTRL(KEY_ROW3__UART5_RX, UART_PAD_CTRL),
+#define GP_RS485_RXEN		IMX_GPIO_NR(4, 22)
+	IOMUX_PAD_CTRL(GPIO1_IO12__GPIO1_IO_12, WEAK_PULLUP),
+
+	/* USB OTG1 */
+	IOMUX_PAD_CTRL(GPIO1_IO08__USB_OTG1_OC, WEAK_PULLUP),
+	IOMUX_PAD_CTRL(GPIO1_IO10__ANATOP_OTG1_ID, WEAK_PULLUP),
+#define GP_USB_OTG1_PWR		IMX_GPIO_NR(1, 9)
+	IOMUX_PAD_CTRL(GPIO1_IO09__GPIO1_IO_9, WEAK_PULLDN_OUTPUT),
+
+	/* USB OTG2 */
+#define GP_USB_HUB_RESET	IMX_GPIO_NR(4, 26)
+	IOMUX_PAD_CTRL(QSPI1B_DATA2__GPIO4_IO_26, OUTPUT_40OHM),
+#define GP_USB_HOST_PWR_EN	IMX_GPIO_NR(1, 11)
+	IOMUX_PAD_CTRL(GPIO1_IO11__GPIO1_IO_11, OUTPUT_40OHM),
+
+	/* usdhc2 - micro SD */
+	IOMUX_PAD_CTRL(SD2_CLK__USDHC2_CLK, USDHC2_CLK_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_CMD__USDHC2_CMD, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA0__USDHC2_DATA0, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA1__USDHC2_DATA1, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA2__USDHC2_DATA2, USDHC2_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD2_DATA3__USDHC2_DATA3, USDHC2_PAD_CTRL),
+#define GP_USDHC2_CD	IMX_GPIO_NR(2, 12)
+	IOMUX_PAD_CTRL(KEY_COL2__GPIO2_IO_12, WEAK_PULLUP),
+
+	/* usdhc3 - eMMC */
+	IOMUX_PAD_CTRL(SD3_CLK__USDHC3_CLK, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_CMD__USDHC3_CMD, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA0__USDHC3_DATA0, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA1__USDHC3_DATA1, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA2__USDHC3_DATA2, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA3__USDHC3_DATA3, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA4__USDHC3_DATA4, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA5__USDHC3_DATA5, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA6__USDHC3_DATA6, USDHC3_PAD_CTRL),
+	IOMUX_PAD_CTRL(SD3_DATA7__USDHC3_DATA7, USDHC3_PAD_CTRL),
+	/* External pullup to 1.8V, input (release), out low(asserted) */
+#define GP_EMMC_RESET	IMX_GPIO_NR(2, 17)
+	IOMUX_PAD_CTRL(KEY_ROW2__GPIO2_IO_17, USDHC3_PAD_CTRL_RST),
+};
+
+static const struct i2c_pads_info i2c_pads[] = {
+	I2C_PADS_INFO_ENTRY(I2C1, GPIO1_IO00, 1, 0, GPIO1_IO01, 1, 1, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C2, GPIO1_IO02, 1, 2, GPIO1_IO03, 1, 3, I2C_PAD_CTRL),
+	I2C_PADS_INFO_ENTRY(I2C3, KEY_COL4, 2, 14, KEY_ROW4, 2, 19, I2C_PAD_CTRL),
+};
+#define I2C_BUS_CNT	3
+
+#ifdef CONFIG_MXC_SPI
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? GP_ECSPI1_NOR_CS : (cs >> 8) ? (cs >> 8) : -1;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+			port * 4);
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	/* Reset USB hub */
+	gpio_direction_output(GP_USB_HUB_RESET, 0);
+	mdelay(2);
+	gpio_set_value(GP_USB_HUB_RESET, 1);
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	if (port)
+		gpio_set_value(GP_USB_HOST_PWR_EN, on);
+	else
+		gpio_set_value(GP_USB_OTG1_PWR, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg board_usdhc_cfg[] = {
+	{.esdhc_base = USDHC2_BASE_ADDR, .bus_width = 4,
+			.gp_cd = GP_USDHC2_CD},
+	{.esdhc_base = USDHC3_BASE_ADDR, .bus_width = 8,
+			.flags = CFG_FORCE_1P8V},
+};
+#endif
+
+static const unsigned short gpios_out_low[] = {
+	GP_485_DIR,
+	GP_485_TERM_CTRL,
+	GP_CUST_START,
+	GP_NETWORK_LED,
+	GP_PCIE_RESET,
+	GP_POWER_OK_VDSP,
+	GP_PWR_SYNC,
+	GP_RGMII_PHY_RESET,
+	GP_RGMII2_PHY_RESET,
+	GP_SERVICE_LED,
+	GP_SYSTEM_LED,
+	GP_TERM_ON_OFF,
+	GP_USB_HUB_RESET,
+	GP_USB_OTG1_PWR,
+	GP_USB_HOST_PWR_EN,
+};
+
+static const unsigned short gpios_out_high[] = {
+	GP_ECSPI1_NOR_CS,
+	GP_ECSPI2_CS,
+	GP_ECSPI3_CS,
+	GP_ECSPI5_CS,
+	GP_RESET_DSP_N,
+	GP_RS485_RXEN,
+};
+
+static const unsigned short gpios_in[] = {
+	GP_RGMII_PHY_INT,
+	GP_RGMII2_PHY_INT,
+	GP_USDHC2_CD,
+	GP_TP51,
+	GP_TP83,
+	GP_TP92,
+	GPIRQ_RTC_RV4162,
+	GP_PCIE_WAKE,
+	GP_PCIE_DISABLE,
+	GP_EMMC_RESET,
+};
+
+int board_early_init_f(void)
+{
+	set_gpios_in(gpios_in, ARRAY_SIZE(gpios_in));
+	set_gpios(gpios_out_high, ARRAY_SIZE(gpios_out_high), 1);
+	set_gpios(gpios_out_low, ARRAY_SIZE(gpios_out_low), 0);
+	SETUP_IOMUX_PADS(init_pads);
+	return 0;
+}
+
+int board_init(void)
+{
+	common_board_init(i2c_pads, I2C_BUS_CNT, 0, NULL, 0, 0);
+	return 0;
+}
+
+const struct button_key board_buttons[] = {
+	{"tp51",	GP_TP51,	't', 1},
+	{NULL, 0, 0, 0},
+};
+
+#ifdef CONFIG_CMD_BMODE
+const struct boot_mode board_boot_modes[] = {
+	{"mmc0", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"mmc1", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL, 0},
+};
+#endif
diff -Nru u-boot-2017.07/boundary_insert u-boot-imx6/boundary_insert
--- u-boot-2017.07/boundary_insert	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/boundary_insert	2018-08-27 21:35:37.187470541 +0300
@@ -0,0 +1,76 @@
+#!/bin/bash
+# syntax ./boundary_insert CONFIG_1 CONFIG_2 ... CONFIG_n
+
+insert_configs=$*;
+boards=`ls -d board/boundary/* | sed 's.board/boundary/..'`;
+
+numboards=0;
+numsuccess=0;
+numfailures=0;
+skipped=0;
+for board in ${boards} ; do
+	update_cnt=0;
+	already_there=0;
+	if [ -e board/boundary/${board}/Kconfig ] ; then
+		target=`grep TARGET_ board/boundary/${board}/Kconfig | sed 's.if ..'`;
+		defconfigs=`git grep -w CONFIG_${target} configs/ | sed 's.configs/..'| sed 's/_defconfig:.*$//'`;
+	else
+		defconfigs="";
+	fi
+	board_cfgs=":"
+	for defconfig in ${defconfigs} ; do
+		cfgs=""
+		for insert_config in ${insert_configs} ; do
+			cnt=`sed -n "/${insert_config}=/=" configs/${defconfig}_defconfig`
+			if [ "${cnt}" != "" ] ; then
+				already_there=`expr $already_there + 1`;
+			else
+				cfgs="${cfgs} ${insert_config}"
+			fi
+		done
+
+		if [ "${cfgs}" != "" ] ; then
+			make ${defconfig}_defconfig;
+			for insert_config in ${cfgs} ; do
+				echo "${insert_config}=y" >>.config;
+			done
+			make savedefconfig;
+			diff -q defconfig configs/${defconfig}_defconfig;
+			if [ $? -eq 0 ] ; then
+				already_there=`expr $already_there + 1`;
+			else
+				if [ $? -eq 1 ] ; then
+					cp defconfig configs/${defconfig}_defconfig;
+					echo updated ${defconfig}_defconfig;
+					git update-index configs/${defconfig}_defconfig;
+					update_cnt=`expr $update_cnt + 1`;
+					for insert_config in ${cfgs} ; do
+						if [ `expr "${board_cfgs}" : "[A-Z0-9_:]*:${insert_config}:"` -eq 0 ] ; then
+							cnt=`sed -n "/${insert_config}=/=" configs/${defconfig}_defconfig`
+							if [ "${cnt}" != "" ] ; then
+								board_cfgs="${board_cfgs}:${insert_config}:"
+							fi
+						fi
+					done
+				else
+					numfailures=`expr $numfailures + 1`;
+					echo -e "\n\n\n!!!!!!!! insert failure for ${defconfig}_defconfig !!!!!!!!!!!!\n\n";
+					read line;
+				fi
+			fi
+		fi
+	done
+	if [ ${update_cnt} != "0" ] ; then
+		echo "${board}: ${update_cnt} defconfigs updated, ${already_there} already there";
+		numsuccess=`expr $numsuccess + 1`;
+		if [ ${board_cfgs} != ":" ] ; then
+			git c -m"${board}: add ${board_cfgs//::/ } to defconfigs";
+		else
+			git c -m"${board}: reorder defconfigs";
+		fi
+	else
+		skipped=`expr $skipped + 1`;
+	fi
+	numboards=`expr $numboards + 1`;
+done
+echo "\n\ninsert for ${numboards} boards. ${numsuccess} succeeded and ${numfailures} failed, ${skipped} skipped";
diff -Nru u-boot-2017.07/cmd/bootz.c u-boot-imx6/cmd/bootz.c
--- u-boot-2017.07/cmd/bootz.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/cmd/bootz.c	2018-08-27 21:35:37.187470541 +0300
@@ -62,6 +62,9 @@
 {
 	int ret;
 
+#ifdef CONFIG_SYS_BOOT_BOARD_POWER_CHECK
+	board_power_check();
+#endif
 	/* Consume 'bootz' */
 	argc--; argv++;
 
diff -Nru u-boot-2017.07/cmd/fdt.c u-boot-imx6/cmd/fdt.c
--- u-boot-2017.07/cmd/fdt.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/cmd/fdt.c	2018-08-27 21:35:37.190803859 +0300
@@ -256,7 +256,7 @@
 		char *pathp;		/* path */
 		char *prop;		/* property */
 		int  nodeoffset;	/* node offset from libfdt */
-		static char data[SCRATCHPAD];	/* storage for the property */
+		static char data[SCRATCHPAD] __aligned(4);
 		const void *ptmp;
 		int  len;		/* new length of the property */
 		int  ret;		/* return value */
diff -Nru u-boot-2017.07/cmd/fuse.c u-boot-imx6/cmd/fuse.c
--- u-boot-2017.07/cmd/fuse.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/cmd/fuse.c	2018-08-27 21:35:37.190803859 +0300
@@ -63,14 +63,19 @@
 
 		printf("Reading bank %u:\n", bank);
 		for (i = 0; i < cnt; i++, word++) {
+			char name[16];
+			char vbuf[16];
 			if (!(i % 4))
-				printf("\nWord 0x%.8x:", word);
+				printf("\nWord 0x%.8x: ", word);
 
 			ret = fuse_read(bank, word, &val);
 			if (ret)
 				goto err;
 
-			printf(" %.8x", val);
+			snprintf(name, sizeof(name), "fuse_read_val%x", i);
+			snprintf(vbuf, sizeof(vbuf), "%.8x", val);
+			setenv(name, vbuf);
+			puts(vbuf);
 		}
 		putc('\n');
 	} else if (!strcmp(op, "sense")) {
diff -Nru u-boot-2017.07/cmd/i2c.c u-boot-imx6/cmd/i2c.c
--- u-boot-2017.07/cmd/i2c.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/cmd/i2c.c	2018-08-27 21:35:37.190803859 +0300
@@ -1816,12 +1816,9 @@
 		printf("Current bus is %d\n", bus_no);
 	} else {
 		bus_no = simple_strtoul(argv[1], NULL, 10);
-#if defined(CONFIG_SYS_I2C)
-		if (bus_no >= CONFIG_SYS_NUM_I2C_BUSES) {
-			printf("Invalid bus %d\n", bus_no);
+		if (!i2c_get_adapter(bus_no))
 			return -1;
-		}
-#endif
+
 		printf("Setting bus to %d\n", bus_no);
 #ifdef CONFIG_DM_I2C
 		ret = cmd_i2c_set_bus_num(bus_no);
diff -Nru u-boot-2017.07/common/image-sparse.c u-boot-imx6/common/image-sparse.c
--- u-boot-2017.07/common/image-sparse.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/common/image-sparse.c	2018-08-27 21:35:37.207470446 +0300
@@ -66,6 +66,7 @@
 	chunk_header_t *chunk_header;
 	uint32_t total_blocks = 0;
 	int fill_buf_num_blks;
+	int dcache_enabled = dcache_status();
 	int i;
 	int j;
 
@@ -107,6 +108,10 @@
 
 	puts("Flashing Sparse Image\n");
 
+	/* Disable data cache since chunks might not be aligned */
+	if (dcache_enabled)
+		dcache_disable();
+
 	/* Start processing chunks */
 	blk = info->start;
 	for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
@@ -251,6 +256,10 @@
 		}
 	}
 
+	/* Re-enable data cache it in case it was in the first place */
+	if (dcache_enabled)
+		dcache_enable();
+
 	debug("Wrote %d blocks, expected to write %d blocks\n",
 	      total_blocks, sparse_header->total_blks);
 	printf("........ wrote %u bytes to '%s'\n", bytes_written, part_name);
diff -Nru u-boot-2017.07/common/splash_source.c u-boot-imx6/common/splash_source.c
--- u-boot-2017.07/common/splash_source.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/common/splash_source.c	2018-08-27 21:35:37.210803763 +0300
@@ -95,7 +95,26 @@
 		return res;
 
 	bmp_hdr = (struct bmp_header *)bmp_load_addr;
-	bmp_size = le32_to_cpu(bmp_hdr->file_size);
+
+	if ((bmp_hdr->signature[0] == 'B') &&
+	      (bmp_hdr->signature[1] == 'M')) {
+		bmp_size = le32_to_cpu(bmp_hdr->file_size);
+	} else if ((bmp_hdr->signature[0] == 0x1f) &&
+			      (bmp_hdr->signature[1] == 0x8b)) {
+		char *sz = getenv("splashsize");
+
+		bmp_size = 0;
+		if (sz)
+			bmp_size = simple_strtoul(sz, 0, 16);
+		if (!bmp_size) {
+			printf("Error: specify env splashsize\n");
+			return -EINVAL;
+		}
+	} else {
+		printf("Error: unrecognized splash file type %02x %02x\n",
+			bmp_hdr->signature[0], bmp_hdr->signature[1]);
+		return -EINVAL;
+	}
 
 	if (bmp_load_addr + bmp_size >= gd->start_addr_sp)
 		goto splash_address_too_high;
diff -Nru u-boot-2017.07/common/usb_hub.c u-boot-imx6/common/usb_hub.c
--- u-boot-2017.07/common/usb_hub.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/common/usb_hub.c	2018-08-27 21:35:37.210803763 +0300
@@ -141,7 +141,7 @@
 	 * Do a minimum delay of the larger value of 100ms or pgood_delay
 	 * so that the power can stablize before the devices are queried
 	 */
-	hub->query_delay = get_timer(0) + max(100, (int)pgood_delay);
+	hub->query_delay = max(100, (int)pgood_delay);
 
 	/*
 	 * Record the power-on timeout here. The max. delay (timeout)
@@ -366,7 +366,7 @@
 	return ret;
 }
 
-static int usb_scan_port(struct usb_device_scan *usb_scan)
+static int usb_scan_port(struct usb_device_scan *usb_scan, unsigned long start)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
 	unsigned short portstatus;
@@ -384,21 +384,13 @@
 	 * Don't talk to the device before the query delay is expired.
 	 * This is needed for voltages to stabalize.
 	 */
-	if (get_timer(0) < hub->query_delay)
+	if (get_timer(start) < hub->query_delay)
 		return 0;
 
 	ret = usb_get_port_status(dev, i + 1, portsts);
 	if (ret < 0) {
 		debug("get_port_status failed\n");
-		if (get_timer(0) >= hub->connect_timeout) {
-			debug("devnum=%d port=%d: timeout\n",
-			      dev->devnum, i + 1);
-			/* Remove this device from scanning list */
-			list_del(&usb_scan->list);
-			free(usb_scan);
-			return 0;
-		}
-		return 0;
+		goto check_timeout;
 	}
 
 	portstatus = le16_to_cpu(portsts->wPortStatus);
@@ -406,21 +398,13 @@
 	debug("Port %d Status %X Change %X\n", i + 1, portstatus, portchange);
 
 	/* No connection change happened, wait a bit more. */
-	if (!(portchange & USB_PORT_STAT_C_CONNECTION)) {
-		if (get_timer(0) >= hub->connect_timeout) {
-			debug("devnum=%d port=%d: timeout\n",
-			      dev->devnum, i + 1);
-			/* Remove this device from scanning list */
-			list_del(&usb_scan->list);
-			free(usb_scan);
-			return 0;
-		}
-		return 0;
-	}
+	if (!(portchange & USB_PORT_STAT_C_CONNECTION))
+		goto check_timeout;
+
 
 	/* Test if the connection came up, and if not exit */
 	if (!(portstatus & USB_PORT_STAT_CONNECTION))
-		return 0;
+		goto check_timeout;
 
 	/* A new USB device is ready at this point */
 	debug("devnum=%d port=%d: USB dev found\n", dev->devnum, i + 1);
@@ -489,6 +473,16 @@
 	free(usb_scan);
 
 	return 0;
+check_timeout:
+	if (get_timer(start) >= hub->connect_timeout) {
+		debug("devnum=%d port=%d: timeout\n",
+		      dev->devnum, i + 1);
+		/* Remove this device from scanning list */
+		list_del(&usb_scan->list);
+		free(usb_scan);
+		return 0;
+	}
+	return 0;
 }
 
 static int usb_device_list_scan(void)
@@ -497,6 +491,7 @@
 	struct usb_device_scan *tmp;
 	static int running;
 	int ret = 0;
+	unsigned long start;
 
 	/* Only run this loop once for each controller */
 	if (running)
@@ -504,16 +499,18 @@
 
 	running = 1;
 
+	start = get_timer(0);
 	while (1) {
 		/* We're done, once the list is empty again */
 		if (list_empty(&usb_scan_list))
 			goto out;
 
+		mdelay(1);
 		list_for_each_entry_safe(usb_scan, tmp, &usb_scan_list, list) {
 			int ret;
 
 			/* Scan this port */
-			ret = usb_scan_port(usb_scan);
+			ret = usb_scan_port(usb_scan, start);
 			if (ret)
 				goto out;
 		}
diff -Nru u-boot-2017.07/configs/acl_q2g_defconfig u-boot-imx6/configs/acl_q2g_defconfig
--- u-boot-2017.07/configs/acl_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/acl_q2g_defconfig	2018-08-27 21:35:37.240803621 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ACL=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/acl/acl2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"acl_q2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/acl_s512m_defconfig u-boot-imx6/configs/acl_s512m_defconfig
--- u-boot-2017.07/configs/acl_s512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/acl_s512m_defconfig	2018-08-27 21:35:37.240803621 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ACL=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/acl/acl512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"acl_s512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/a_defconfig u-boot-imx6/configs/a_defconfig
--- u-boot-2017.07/configs/a_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/a_defconfig	2018-08-27 21:35:37.240803621 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_A=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/a/a_s512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"a\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ap_q2g_defconfig u-boot-imx6/configs/ap_q2g_defconfig
--- u-boot-2017.07/configs/ap_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ap_q2g_defconfig	2018-08-27 21:35:37.244136938 +0300
@@ -0,0 +1,50 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_AP=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ap/ap_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"ap_q2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ash2_defconfig u-boot-imx6/configs/ash2_defconfig
--- u-boot-2017.07/configs/ash2_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ash2_defconfig	2018-08-27 21:35:37.244136938 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ASH2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ash2/ash2.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"ash2\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ash_defconfig u-boot-imx6/configs/ash_defconfig
--- u-boot-2017.07/configs/ash_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ash_defconfig	2018-08-27 21:35:37.244136938 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_ASH=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ash/ash.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"ash\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/bt2_2g_defconfig u-boot-imx6/configs/bt2_2g_defconfig
--- u-boot-2017.07/configs/bt2_2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/bt2_2g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_BT2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/bt2/bt2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"bt2_2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/bt2_4g_defconfig u-boot-imx6/configs/bt2_4g_defconfig
--- u-boot-2017.07/configs/bt2_4g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/bt2_4g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_BT2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/bt2/bt4g.cfg,MX6Q,DDR_MB=3840,DEFCONFIG=\"bt2_4g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/bt2g_defconfig u-boot-imx6/configs/bt2g_defconfig
--- u-boot-2017.07/configs/bt2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/bt2g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_BT=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/bt/bt2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"bt2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/bt4g_defconfig u-boot-imx6/configs/bt4g_defconfig
--- u-boot-2017.07/configs/bt4g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/bt4g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_BT=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/bt/bt4g.cfg,MX6Q,DDR_MB=3840,DEFCONFIG=\"bt4g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cad_defconfig u-boot-imx6/configs/cad_defconfig
--- u-boot-2017.07/configs/cad_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cad_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_CAD=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cad/cad.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"cad\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cid_2g_defconfig u-boot-imx6/configs/cid_2g_defconfig
--- u-boot-2017.07/configs/cid_2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cid_2g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,47 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TAMPER=y
+CONFIG_TARGET_CID=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cid/cid_q2g.cfg,MX6Q,DDR_MB=2048,GREEN_HIGH,DEFCONFIG=\"cid_2g\""
+CONFIG_BOOTDELAY=0
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cid2_q2g_defconfig u-boot-imx6/configs/cid2_q2g_defconfig
--- u-boot-2017.07/configs/cid2_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cid2_q2g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,47 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TAMPER=y
+CONFIG_TARGET_CID=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cid/cid_q2g.cfg,MX6Q,DDR_MB=2048,BOARD_TYPE=\"cid2\",DEFCONFIG=\"cid2_q2g\""
+CONFIG_BOOTDELAY=0
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cid_tab_q2g_defconfig u-boot-imx6/configs/cid_tab_q2g_defconfig
--- u-boot-2017.07/configs/cid_tab_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cid_tab_q2g_defconfig	2018-08-27 21:35:37.247470256 +0300
@@ -0,0 +1,49 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TAMPER=y
+CONFIG_TARGET_CID_TAB=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cid_tab/cid_tab_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"cid_tab_q2g\""
+CONFIG_BOOTDELAY=0
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cnt1g_defconfig u-boot-imx6/configs/cnt1g_defconfig
--- u-boot-2017.07/configs/cnt1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cnt1g_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_CNT=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cnt/cnt1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"cnt1g\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cnt2g_defconfig u-boot-imx6/configs/cnt2g_defconfig
--- u-boot-2017.07/configs/cnt2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cnt2g_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_CNT=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cnt/cnt2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"cnt2g\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cob2_q1g_defconfig u-boot-imx6/configs/cob2_q1g_defconfig
--- u-boot-2017.07/configs/cob2_q1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cob2_q1g_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_COB2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cob2/cob2_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"cob2_q1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/cob_defconfig u-boot-imx6/configs/cob_defconfig
--- u-boot-2017.07/configs/cob_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/cob_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_COB=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/cob/cob.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"cob\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/dash_defconfig u-boot-imx6/configs/dash_defconfig
--- u-boot-2017.07/configs/dash_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/dash_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_DASH=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/dash/dash_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"dash\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/eo_defconfig u-boot-imx6/configs/eo_defconfig
--- u-boot-2017.07/configs/eo_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/eo_defconfig	2018-08-27 21:35:37.250803573 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_EO=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/eo/eo.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"eo\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/eo_duallite_defconfig u-boot-imx6/configs/eo_duallite_defconfig
--- u-boot-2017.07/configs/eo_duallite_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/eo_duallite_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_EO=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/eo/eo_duallite.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"eo_duallite\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/h4_defconfig u-boot-imx6/configs/h4_defconfig
--- u-boot-2017.07/configs/h4_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/h4_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_H4=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/h4/h4.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"h4\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hl_1g_defconfig u-boot-imx6/configs/hl_1g_defconfig
--- u-boot-2017.07/configs/hl_1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hl_1g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_HL=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/hl/hl_1g.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"hl_1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hp_defconfig u-boot-imx6/configs/hp_defconfig
--- u-boot-2017.07/configs/hp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hp_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_HP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/hp/hp.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"hp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hp_q1g_defconfig u-boot-imx6/configs/hp_q1g_defconfig
--- u-boot-2017.07/configs/hp_q1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hp_q1g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_HP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/hp/hp_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"hp_q1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hp_s512m_defconfig u-boot-imx6/configs/hp_s512m_defconfig
--- u-boot-2017.07/configs/hp_s512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hp_s512m_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_HP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/hp/hp_s512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"hp_s512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hquad2g_defconfig u-boot-imx6/configs/hquad2g_defconfig
--- u-boot-2017.07/configs/hquad2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hquad2g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_H=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/h/hquad2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"hquad2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/hsolo1g_defconfig u-boot-imx6/configs/hsolo1g_defconfig
--- u-boot-2017.07/configs/hsolo1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/hsolo1g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_H=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/h/hsolo1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"hsolo1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/insp2g_defconfig u-boot-imx6/configs/insp2g_defconfig
--- u-boot-2017.07/configs/insp2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/insp2g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_INSP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/insp/insp2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"insp2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/insp_defconfig u-boot-imx6/configs/insp_defconfig
--- u-boot-2017.07/configs/insp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/insp_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_INSP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/insp/insp1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"insp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ioc_defconfig u-boot-imx6/configs/ioc_defconfig
--- u-boot-2017.07/configs/ioc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ioc_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_IOC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ioc/ioc.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"ioc\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/jlm_1g_defconfig u-boot-imx6/configs/jlm_1g_defconfig
--- u-boot-2017.07/configs/jlm_1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/jlm_1g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_JLM=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/jlm/jlm_1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"jlm_1g\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/jlm_2g_defconfig u-boot-imx6/configs/jlm_2g_defconfig
--- u-boot-2017.07/configs/jlm_2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/jlm_2g_defconfig	2018-08-27 21:35:37.254136891 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_JLM=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/jlm/jlm_2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"jlm_2g\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ls_defconfig u-boot-imx6/configs/ls_defconfig
--- u-boot-2017.07/configs/ls_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ls_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_LS=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ls/ls2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"ls\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/lshore_dl_defconfig u-boot-imx6/configs/lshore_dl_defconfig
--- u-boot-2017.07/configs/lshore_dl_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/lshore_dl_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_LSHORE=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/lshore/lshore_dl.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"lshore_dl\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/lshore_solo_defconfig u-boot-imx6/configs/lshore_solo_defconfig
--- u-boot-2017.07/configs/lshore_solo_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/lshore_solo_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_LSHORE=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/lshore/lshore_solo.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"lshore_solo\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ltch_q2g_defconfig u-boot-imx6/configs/ltch_q2g_defconfig
--- u-boot-2017.07/configs/ltch_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ltch_q2g_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,50 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_LTCH=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ltch/ltch_q2g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"ltch_q2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mcsquad_defconfig u-boot-imx6/configs/mcsquad_defconfig
--- u-boot-2017.07/configs/mcsquad_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mcsquad_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MCS=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mcs/mcsquad.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"mcsquad\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mcssolo1g_64bit_defconfig u-boot-imx6/configs/mcssolo1g_64bit_defconfig
--- u-boot-2017.07/configs/mcssolo1g_64bit_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mcssolo1g_64bit_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MCS=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mcs/mcssolo1g_64bit.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"mcssolo1g_64bit\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mcssolo_defconfig u-boot-imx6/configs/mcssolo_defconfig
--- u-boot-2017.07/configs/mcssolo_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mcssolo_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MCS=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mcs/mcssolo.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"mcssolo\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/med_defconfig u-boot-imx6/configs/med_defconfig
--- u-boot-2017.07/configs/med_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/med_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MED=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/med/med_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"med\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mtp2g_defconfig u-boot-imx6/configs/mtp2g_defconfig
--- u-boot-2017.07/configs/mtp2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mtp2g_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MTP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mtp/mtp2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"mtp2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mtp2g_qp_defconfig u-boot-imx6/configs/mtp2g_qp_defconfig
--- u-boot-2017.07/configs/mtp2g_qp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mtp2g_qp_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MTP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mtp/mtp2g.cfg,MX6Q,MX6QP,DDR_MB=2048,DEFCONFIG=\"mtp2g_qp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mtp_defconfig u-boot-imx6/configs/mtp_defconfig
--- u-boot-2017.07/configs/mtp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mtp_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MTP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mtp/mtp.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"mtp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mtp_qp_defconfig u-boot-imx6/configs/mtp_qp_defconfig
--- u-boot-2017.07/configs/mtp_qp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mtp_qp_defconfig	2018-08-27 21:35:37.257470208 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MTP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mtp/mtp.cfg,MX6Q,MX6QP,DDR_MB=1024,DEFCONFIG=\"mtp_qp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/mx6qsabrelite_defconfig u-boot-imx6/configs/mx6qsabrelite_defconfig
--- u-boot-2017.07/configs/mx6qsabrelite_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/mx6qsabrelite_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024,SABRELITE"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024,SABRELITE,DEFCONFIG=\"mx6qsabrelite\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,8 +30,13 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
 CONFIG_DM=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_DM_THERMAL=y
 CONFIG_USB=y
diff -Nru u-boot-2017.07/configs/mx6_r_defconfig u-boot-imx6/configs/mx6_r_defconfig
--- u-boot-2017.07/configs/mx6_r_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/mx6_r_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_MX6_R=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/mx6_r/mx6_r_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"mx6_r\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/neol_q2g_defconfig u-boot-imx6/configs/neol_q2g_defconfig
--- u-boot-2017.07/configs/neol_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/neol_q2g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NEOL=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/neol/neol_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"neol_q2g\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nit6xlite1g_defconfig u-boot-imx6/configs/nit6xlite1g_defconfig
--- u-boot-2017.07/configs/nit6xlite1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nit6xlite1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NIT6XLITE=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nit6xlite/nit6xlite1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"nit6xlite1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nit6xlite_defconfig u-boot-imx6/configs/nit6xlite_defconfig
--- u-boot-2017.07/configs/nit6xlite_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nit6xlite_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NIT6XLITE=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nit6xlite/nit6xlite.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"nit6xlite\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_e_256m_defconfig u-boot-imx6/configs/nitrogen51_e_256m_defconfig
--- u-boot-2017.07/configs/nitrogen51_e_256m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_e_256m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_E=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_e/nitrogen51_e.cfg,MX51,DDR_MB=256,DEFCONFIG=\"nitrogen51_e_256m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_e_512m_defconfig u-boot-imx6/configs/nitrogen51_e_512m_defconfig
--- u-boot-2017.07/configs/nitrogen51_e_512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_e_512m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_E=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_e/nitrogen51_e.cfg,MX51,DDR_MB=512,DEFCONFIG=\"nitrogen51_e_512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_e_rev0_256m_defconfig u-boot-imx6/configs/nitrogen51_e_rev0_256m_defconfig
--- u-boot-2017.07/configs/nitrogen51_e_rev0_256m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_e_rev0_256m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_E=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_e/nitrogen51_e.cfg,MX51,DDR_MB=256,DEFCONFIG=\"nitrogen51_e_rev0_256m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_ATMEL=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_e_rev0_512m_defconfig u-boot-imx6/configs/nitrogen51_e_rev0_512m_defconfig
--- u-boot-2017.07/configs/nitrogen51_e_rev0_512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_e_rev0_512m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_E=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_e/nitrogen51_e.cfg,MX51,DDR_MB=512,DEFCONFIG=\"nitrogen51_e_rev0_512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_ATMEL=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_vm_256m_defconfig u-boot-imx6/configs/nitrogen51_vm_256m_defconfig
--- u-boot-2017.07/configs/nitrogen51_vm_256m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_vm_256m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_VM=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_vm/nitrogen51_vm.cfg,MX51,DDR_MB=256,DEFCONFIG=\"nitrogen51_vm_256m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen51_vm_512m_defconfig u-boot-imx6/configs/nitrogen51_vm_512m_defconfig
--- u-boot-2017.07/configs/nitrogen51_vm_512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen51_vm_512m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX5=y
+CONFIG_TARGET_NITROGEN51_VM=y
+CONFIG_VIDEO=y
+# CONFIG_CMD_BMODE is not set
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen51_vm/nitrogen51_vm.cfg,MX51,DDR_MB=512,DEFCONFIG=\"nitrogen51_vm_512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6dl2g_defconfig u-boot-imx6/configs/nitrogen6dl2g_defconfig
--- u-boot-2017.07/configs/nitrogen6dl2g_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6dl2g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl2g.cfg,MX6DL,DDR_MB=2048"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl2g.cfg,MX6DL,DDR_MB=2048,DEFCONFIG=\"nitrogen6dl2g\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6dl_defconfig u-boot-imx6/configs/nitrogen6dl_defconfig
--- u-boot-2017.07/configs/nitrogen6dl_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6dl_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"nitrogen6dl\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6_lum_dl1_defconfig u-boot-imx6/configs/nitrogen6_lum_dl1_defconfig
--- u-boot-2017.07/configs/nitrogen6_lum_dl1_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_lum_dl1_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,50 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6X=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024,BOARD_TYPE=\"nitrogen6x\",DEFCONFIG=\"nitrogen6_lum_dl1\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_max_4gr0_defconfig u-boot-imx6/configs/nitrogen6_max_4gr0_defconfig
--- u-boot-2017.07/configs/nitrogen6_max_4gr0_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_max_4gr0_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_MAX=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_max/nitrogen6_max_4gr0.cfg,MX6Q,DDR_MB=3840,DEFCONFIG=\"nitrogen6_max_4gr0\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_max_defconfig u-boot-imx6/configs/nitrogen6_max_defconfig
--- u-boot-2017.07/configs/nitrogen6_max_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_max_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_MAX=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_max/nitrogen6_max4g.cfg,MX6Q,DDR_MB=3840,DEFCONFIG=\"nitrogen6_max\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_max_dl2g_defconfig u-boot-imx6/configs/nitrogen6_max_dl2g_defconfig
--- u-boot-2017.07/configs/nitrogen6_max_dl2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_max_dl2g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_MAX=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_max/nitrogen6_max_dl2g.cfg,MX6DL,DDR_MB=2048,DEFCONFIG=\"nitrogen6_max_dl2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_max_dl4g_defconfig u-boot-imx6/configs/nitrogen6_max_dl4g_defconfig
--- u-boot-2017.07/configs/nitrogen6_max_dl4g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_max_dl4g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_MAX=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_max/nitrogen6_max_dl4g.cfg,MX6DL,DDR_MB=3840,DEFCONFIG=\"nitrogen6_max_dl4g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6q2g_defconfig u-boot-imx6/configs/nitrogen6q2g_defconfig
--- u-boot-2017.07/configs/nitrogen6q2g_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q2g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q2g.cfg,MX6Q,DDR_MB=2048"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"nitrogen6q2g\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6q_defconfig u-boot-imx6/configs/nitrogen6q_defconfig
--- u-boot-2017.07/configs/nitrogen6q_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"nitrogen6q\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6q_fl_defconfig u-boot-imx6/configs/nitrogen6q_fl_defconfig
--- u-boot-2017.07/configs/nitrogen6q_fl_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q_fl_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,50 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6X=y
+CONFIG_VIDEO=y
+CONFIG_CMD_HDMIDETECT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024,BOARD_TYPE=\"nitrogen6x_fl\",DEFCONFIG=\"nitrogen6q_fl\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6qp_max_defconfig u-boot-imx6/configs/nitrogen6qp_max_defconfig
--- u-boot-2017.07/configs/nitrogen6qp_max_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6qp_max_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_MAX=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_max/nitrogen6_max4g.cfg,MX6Q,MX6QP,DDR_MB=3840,DEFCONFIG=\"nitrogen6qp_max\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6qp_som2_4g_defconfig u-boot-imx6/configs/nitrogen6qp_som2_4g_defconfig
--- u-boot-2017.07/configs/nitrogen6qp_som2_4g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6qp_som2_4g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg,MX6Q,MX6QP,DDR_MB=3840,DEFCONFIG=\"nitrogen6qp_som2_4g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6q_som2_1g_defconfig u-boot-imx6/configs/nitrogen6q_som2_1g_defconfig
--- u-boot-2017.07/configs/nitrogen6q_som2_1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q_som2_1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"nitrogen6q_som2_1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6q_som2_2g_defconfig u-boot-imx6/configs/nitrogen6q_som2_2g_defconfig
--- u-boot-2017.07/configs/nitrogen6q_som2_2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q_som2_2g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"nitrogen6q_som2_2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6q_som2_4g_defconfig u-boot-imx6/configs/nitrogen6q_som2_4g_defconfig
--- u-boot-2017.07/configs/nitrogen6q_som2_4g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6q_som2_4g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_q4g.cfg,MX6Q,DDR_MB=3840,DEFCONFIG=\"nitrogen6q_som2_4g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6s1g_defconfig u-boot-imx6/configs/nitrogen6s1g_defconfig
--- u-boot-2017.07/configs/nitrogen6s1g_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6s1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s1g.cfg,MX6S,DDR_MB=1024"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"nitrogen6s1g\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6_scm_defconfig u-boot-imx6/configs/nitrogen6_scm_defconfig
--- u-boot-2017.07/configs/nitrogen6_scm_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_scm_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,49 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SCM=y
+CONFIG_VIDEO=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_scm/nitrogen6_scm.cfg,MX6SX,DDR_MB=512,DEFCONFIG=\"nitrogen6_scm\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_ISSI=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6s_defconfig u-boot-imx6/configs/nitrogen6s_defconfig
--- u-boot-2017.07/configs/nitrogen6s_defconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6s_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -3,7 +3,7 @@
 CONFIG_TARGET_NITROGEN6X=y
 CONFIG_VIDEO=y
 CONFIG_CMD_HDMIDETECT=y
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s.cfg,MX6S,DDR_MB=512"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"nitrogen6s\""
 CONFIG_BOOTDELAY=3
 CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
 # CONFIG_SYS_STDIO_DEREGISTER is not set
@@ -30,7 +30,12 @@
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_FAT=y
 CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
 CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_SST=y
 CONFIG_USB=y
 CONFIG_USB_STORAGE=y
diff -Nru u-boot-2017.07/configs/nitrogen6_som2_dl1g_defconfig u-boot-imx6/configs/nitrogen6_som2_dl1g_defconfig
--- u-boot-2017.07/configs/nitrogen6_som2_dl1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_som2_dl1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_dl1g.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"nitrogen6_som2_dl1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_som2_s1g_defconfig u-boot-imx6/configs/nitrogen6_som2_s1g_defconfig
--- u-boot-2017.07/configs/nitrogen6_som2_s1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_som2_s1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_s1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"nitrogen6_som2_s1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_som2_s512m_defconfig u-boot-imx6/configs/nitrogen6_som2_s512m_defconfig
--- u-boot-2017.07/configs/nitrogen6_som2_s512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_som2_s512m_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_SOM2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_som2/nitrogen6_som2_s512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"nitrogen6_som2_s512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6sx_defconfig u-boot-imx6/configs/nitrogen6sx_defconfig
--- u-boot-2017.07/configs/nitrogen6sx_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6sx_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6SX=y
+CONFIG_VIDEO=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6sx/imximage.cfg,MX6SX,DDR_MB=1024,DEFCONFIG=\"nitrogen6sx\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_vm1g_defconfig u-boot-imx6/configs/nitrogen6_vm1g_defconfig
--- u-boot-2017.07/configs/nitrogen6_vm1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_vm1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_VM=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"nitrogen6_vm1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_vm_defconfig u-boot-imx6/configs/nitrogen6_vm_defconfig
--- u-boot-2017.07/configs/nitrogen6_vm_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_vm_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NITROGEN6_VM=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_vm/nitrogen6_vm.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"nitrogen6_vm\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen6_vm-pt1g_defconfig u-boot-imx6/configs/nitrogen6_vm-pt1g_defconfig
--- u-boot-2017.07/configs/nitrogen6_vm-pt1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen6_vm-pt1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,49 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_DEFAULT_HITACHI_HVGA=y
+CONFIG_TARGET_NITROGEN6_VM=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen6_vm/nitrogen6_vm1g.cfg,MX6S,DDR_MB=1024,MXC_UART_BASE=UART1_BASE,BOARD_TYPE=\"nitrogen6_vm-pt\",DEFCONFIG=\"nitrogen6_vm-pt1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nitrogen7_defconfig u-boot-imx6/configs/nitrogen7_defconfig
--- u-boot-2017.07/configs/nitrogen7_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nitrogen7_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,53 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_TARGET_NITROGEN7=y
+CONFIG_VIDEO=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nitrogen7/nitrogen7.cfg,MX7D,DDR_MB=1024,DEFCONFIG=\"nitrogen7\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_MXC_USB_OTG_HACTIVE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nw2_defconfig u-boot-imx6/configs/nw2_defconfig
--- u-boot-2017.07/configs/nw2_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nw2_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NW=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nw/nw.cfg,MX6Q,DDR_MB=1024,REV2,BOARD_TYPE=\"nw2\",DEFCONFIG=\"nw2\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/nw_defconfig u-boot-imx6/configs/nw_defconfig
--- u-boot-2017.07/configs/nw_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/nw_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_NW=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/nw/nw.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"nw\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ocquad_defconfig u-boot-imx6/configs/ocquad_defconfig
--- u-boot-2017.07/configs/ocquad_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ocquad_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_OC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/oc/oc_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"ocquad\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ocsolo1g_defconfig u-boot-imx6/configs/ocsolo1g_defconfig
--- u-boot-2017.07/configs/ocsolo1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ocsolo1g_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_OC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/oc/oc_s1g.cfg,MX6S,DDR_MB=1024,DEFCONFIG=\"ocsolo1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ocsolo_defconfig u-boot-imx6/configs/ocsolo_defconfig
--- u-boot-2017.07/configs/ocsolo_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ocsolo_defconfig	2018-08-27 21:35:37.260803526 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_OC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/oc/oc_s512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"ocsolo\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/per_defconfig u-boot-imx6/configs/per_defconfig
--- u-boot-2017.07/configs/per_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/per_defconfig	2018-08-27 21:35:37.264136844 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_PER=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/per/per.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"per\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/rc_defconfig u-boot-imx6/configs/rc_defconfig
--- u-boot-2017.07/configs/rc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/rc_defconfig	2018-08-27 21:35:37.264136844 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_RC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/rc/rc1g.cfg,MX6DL,DDR_MB=1024,DEFCONFIG=\"rc\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/s_defconfig u-boot-imx6/configs/s_defconfig
--- u-boot-2017.07/configs/s_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/s_defconfig	2018-08-27 21:35:37.264136844 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_S=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/s/s_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"s\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ses_q2g_defconfig u-boot-imx6/configs/ses_q2g_defconfig
--- u-boot-2017.07/configs/ses_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ses_q2g_defconfig	2018-08-27 21:35:37.264136844 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_SES=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ses/ses_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"ses_q2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/snap_defconfig u-boot-imx6/configs/snap_defconfig
--- u-boot-2017.07/configs/snap_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/snap_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_SNAP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/snap/snap2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"snap\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/sp_defconfig u-boot-imx6/configs/sp_defconfig
--- u-boot-2017.07/configs/sp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/sp_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_SP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/sp/sp_s512m.cfg,MX6S,DDR_MB=512,DEFCONFIG=\"sp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ta_defconfig u-boot-imx6/configs/ta_defconfig
--- u-boot-2017.07/configs/ta_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ta_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_TA=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ta/ta1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"ta\""
+CONFIG_BOOTDELAY=1
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/usd_defconfig u-boot-imx6/configs/usd_defconfig
--- u-boot-2017.07/configs/usd_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/usd_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_USD=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/usd/usd.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"usd\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/usd_mr2_q1g_defconfig u-boot-imx6/configs/usd_mr2_q1g_defconfig
--- u-boot-2017.07/configs/usd_mr2_q1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/usd_mr2_q1g_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_USD_MR2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/usd_mr2/usd_mr2_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"usd_mr2_q1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/usd_mr2_q2g_defconfig u-boot-imx6/configs/usd_mr2_q2g_defconfig
--- u-boot-2017.07/configs/usd_mr2_q2g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/usd_mr2_q2g_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_USD_MR2=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/usd_mr2/usd_mr2_q2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"usd_mr2_q2g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/utc_defconfig u-boot-imx6/configs/utc_defconfig
--- u-boot-2017.07/configs/utc_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/utc_defconfig	2018-08-27 21:35:37.267470161 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_UTC=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/utc/utc_q1g.cfg,MX6Q,DDR_MB=1024,DEFCONFIG=\"utc\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/vp_defconfig u-boot-imx6/configs/vp_defconfig
--- u-boot-2017.07/configs/vp_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/vp_defconfig	2018-08-27 21:35:37.270803479 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_VP=y
+CONFIG_VIDEO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/vp/vp2g.cfg,MX6Q,DDR_MB=2048,DEFCONFIG=\"vp\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+# CONFIG_VIDEO_SW_CURSOR is not set
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ys_1g_defconfig u-boot-imx6/configs/ys_1g_defconfig
--- u-boot-2017.07/configs/ys_1g_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ys_1g_defconfig	2018-08-27 21:35:37.270803479 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_YS=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ys/ys_1g.cfg,MX6SX,DEFCONFIG=\"ys_1g\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/configs/ys_512m_defconfig u-boot-imx6/configs/ys_512m_defconfig
--- u-boot-2017.07/configs/ys_512m_defconfig	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/configs/ys_512m_defconfig	2018-08-27 21:35:37.270803479 +0300
@@ -0,0 +1,48 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_YS=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/boundary/ys/ys_512m.cfg,MX6SX,DEFCONFIG=\"ys_512m\""
+CONFIG_BOOTDELAY=3
+CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MEMTEST=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_G_DNL_MANUFACTURER="Boundary"
+CONFIG_G_DNL_VENDOR_NUM=0x0525
+CONFIG_G_DNL_PRODUCT_NUM=0xa4a5
+CONFIG_OF_LIBFDT=y
diff -Nru u-boot-2017.07/copy_upgrade.sh u-boot-imx6/copy_upgrade.sh
--- u-boot-2017.07/copy_upgrade.sh	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/copy_upgrade.sh	2018-08-27 21:35:37.270803479 +0300
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+if [ $# -lt 1 ]; then
+	echo "Error, missing a parameter:"
+	echo "$0 <mount_path>"
+	exit 1
+fi
+
+./tools/mkimage -A arm -O linux -T script -C none \
+	-a 0 -e 0 -n "update script" \
+	-d board/boundary/nitrogen6x/6x_upgrade.txt 6x_upgrade
+
+./tools/mkimage -A arm -O linux -T script -C none \
+	-a 0 -e 0 -n "update script" \
+	-d board/boundary/bootscripts/upgrade.txt upgrade.scr
+
+uboot_defconfig=`grep CONFIG_DEFCONFIG include/config.h|sed -e 's/#define CONFIG_DEFCONFIG[^"]\{1,\}"\([^"]\{1,\}\)"/\1/'`
+
+cp u-boot.imx u-boot.$uboot_defconfig
+mv -v -t $1/ u-boot.$uboot_defconfig 6x_upgrade upgrade.scr
diff -Nru u-boot-2017.07/drivers/block/ahci.c u-boot-imx6/drivers/block/ahci.c
--- u-boot-2017.07/drivers/block/ahci.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/block/ahci.c	2018-08-27 21:35:37.294136701 +0300
@@ -41,7 +41,7 @@
 
 /* Maximum timeouts for each event */
 #define WAIT_MS_SPINUP	20000
-#define WAIT_MS_DATAIO	10000
+#define WAIT_MS_DATAIO	20000
 #define WAIT_MS_FLUSH	5000
 #define WAIT_MS_LINKUP	200
 
diff -Nru u-boot-2017.07/drivers/block/dwc_ahsata.c u-boot-imx6/drivers/block/dwc_ahsata.c
--- u-boot-2017.07/drivers/block/dwc_ahsata.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/block/dwc_ahsata.c	2018-08-27 21:35:37.294136701 +0300
@@ -484,7 +484,7 @@
 		(struct sata_port_regs *)pp->port_mmio;
 	u32 port_status;
 	u32 mem;
-	int timeout = 10000000;
+	int timeout = 20000000;
 
 	debug("Enter start port: %d\n", port);
 	port_status = readl(&(port_mmio->ssts));
diff -Nru u-boot-2017.07/drivers/i2c/i2c_core.c u-boot-imx6/drivers/i2c/i2c_core.c
--- u-boot-2017.07/drivers/i2c/i2c_core.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/i2c/i2c_core.c	2018-08-27 21:35:37.390802908 +0300
@@ -11,25 +11,42 @@
 #include <common.h>
 #include <i2c.h>
 
-struct i2c_adapter *i2c_get_adapter(int index)
+struct i2c_adapter *i2c_get_adapter(int bus)
 {
-	struct i2c_adapter *i2c_adap_p = ll_entry_start(struct i2c_adapter,
-						i2c);
-	int max = ll_entry_count(struct i2c_adapter, i2c);
-	int i;
+	struct i2c_adapter *i2cp = ll_entry_start(struct i2c_adapter, i2c);
 
-	if (index >= max) {
-		printf("Error, wrong i2c adapter %d max %d possible\n",
-		       index, max);
-		return i2c_adap_p;
+	bus = I2C_ADAPTER(bus);
+#ifndef CONFIG_SYS_I2C_DIRECT_BUS
+	if (bus >= CONFIG_SYS_NUM_I2C_BUSES) {
+		printf("Invalid bus %d, max is %d\n", bus,
+				CONFIG_SYS_NUM_I2C_BUSES - 1);
+		return NULL;
 	}
-	if (index == 0)
-		return i2c_adap_p;
+#endif
+
+#ifdef CONFIG_SYS_I2C_MASK
+	if (!(BIT(bus) & CONFIG_SYS_I2C_MASK)) {
+		printf("Invalid bus %d\n", bus);
+		return NULL;
+	}
+#else
+	{
+		int max = ll_entry_count(struct i2c_adapter, i2c);
+		if (bus >= max) {
+			printf("Error, wrong i2c adapter %d max %d possible\n",
+					bus, max);
+			return NULL;
+		}
+	}
+#endif
+	return i2cp + bus;
+}
 
-	for (i = 0; i < index; i++)
-		i2c_adap_p++;
+struct i2c_adapter *i2c_get_adapter_valid(int bus)
+{
+	struct i2c_adapter *i2cp = i2c_get_adapter(bus);
 
-	return i2c_adap_p;
+	return i2cp ? i2cp : ll_entry_start(struct i2c_adapter, i2c);
 }
 
 #if !defined(CONFIG_SYS_I2C_DIRECT_BUS)
@@ -236,22 +253,11 @@
  */
 int i2c_set_bus_num(unsigned int bus)
 {
-	int max;
-
 	if ((bus == I2C_BUS) && (I2C_ADAP->init_done > 0))
 		return 0;
 
-#ifndef CONFIG_SYS_I2C_DIRECT_BUS
-	if (bus >= CONFIG_SYS_NUM_I2C_BUSES)
+	if (!i2c_get_adapter(bus))
 		return -1;
-#endif
-
-	max = ll_entry_count(struct i2c_adapter, i2c);
-	if (I2C_ADAPTER(bus) >= max) {
-		printf("Error, wrong i2c adapter %d max %d possible\n",
-		       I2C_ADAPTER(bus), max);
-		return -2;
-	}
 
 #ifndef CONFIG_SYS_I2C_DIRECT_BUS
 	i2c_mux_disconnect_all();
diff -Nru u-boot-2017.07/drivers/i2c/mxc_i2c.c u-boot-imx6/drivers/i2c/mxc_i2c.c
--- u-boot-2017.07/drivers/i2c/mxc_i2c.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/i2c/mxc_i2c.c	2018-08-27 21:35:37.394136226 +0300
@@ -634,7 +634,7 @@
 	__attribute__((weak, alias("__enable_i2c_clk")));
 
 void bus_i2c_init(int index, int speed, int unused,
-		  int (*idle_bus_fn)(void *p), void *idle_bus_data)
+		  int (*idle_bus_fn)(const void *p), const void *idle_bus_data)
 {
 	int ret;
 
diff -Nru u-boot-2017.07/drivers/mmc/fsl_esdhc.c u-boot-imx6/drivers/mmc/fsl_esdhc.c
--- u-boot-2017.07/drivers/mmc/fsl_esdhc.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mmc/fsl_esdhc.c	2018-08-27 21:35:37.404136178 +0300
@@ -96,18 +96,16 @@
  * @wp_gpio: gpio for write protection
  */
 struct fsl_esdhc_priv {
-	struct fsl_esdhc *esdhc_regs;
-	unsigned int sdhc_clk;
-	unsigned int bus_width;
+	struct fsl_esdhc_cfg c;
 	struct mmc_config cfg;
 	struct mmc *mmc;
 	struct udevice *dev;
 	int non_removable;
-	int wp_enable;
 #ifdef CONFIG_DM_GPIO
 	struct gpio_desc cd_gpio;
 	struct gpio_desc wp_gpio;
 #endif
+	int sysctrl_inita_needed;
 };
 
 /* Return the XFERTYP flags for a given command and data packet */
@@ -157,7 +155,7 @@
 esdhc_pio_read_write(struct mmc *mmc, struct mmc_data *data)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 	uint blocks;
 	char *buffer;
 	uint databuf;
@@ -219,7 +217,7 @@
 {
 	int timeout;
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 #if defined(CONFIG_FSL_LAYERSCAPE) || defined(CONFIG_S32V234)
 	dma_addr_t addr;
 #endif
@@ -251,14 +249,15 @@
 #endif
 		if (wml_value > WML_WR_WML_MAX)
 			wml_value = WML_WR_WML_MAX_VAL;
-		if (priv->wp_enable) {
+#ifndef CONFIG_SYS_FSL_ESDHC_GPIO_WP
+		if (priv->c.wp_enable) {
 			if ((esdhc_read32(&regs->prsstat) &
 			    PRSSTAT_WPSPL) == 0) {
 				printf("\nThe SD card is locked. Can not write to a locked card.\n\n");
 				return -ETIMEDOUT;
 			}
 		}
-
+#endif
 		esdhc_clrsetbits32(&regs->wml, WML_WR_WML_MASK,
 					wml_value << 16);
 #ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
@@ -353,7 +352,7 @@
 	uint	xfertyp;
 	uint	irqstat;
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_ESDHC111
 	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
@@ -378,6 +377,18 @@
 	 * resolve timing issues with some cards
 	 */
 	udelay(1000);
+	if (priv->sysctrl_inita_needed) {
+		unsigned long start;
+
+		/* send 80 clocks before 1st command */
+		priv->sysctrl_inita_needed = 0;
+		esdhc_setbits32(&regs->sysctl, SYSCTL_INITA);
+		start = get_timer(0);
+		while (esdhc_read32(&regs->sysctl) & SYSCTL_INITA) {
+			if (get_timer(start) >= 10)
+				break;
+		}
+	}
 
 	/* Set up for a data transfer if we have one */
 	if (data) {
@@ -418,6 +429,7 @@
 	}
 
 	if (irqstat & IRQSTAT_CTOE) {
+		printf("timeout irqstat=%x\n", irqstat);
 		err = -ETIMEDOUT;
 		goto out;
 	}
@@ -474,6 +486,11 @@
 
 			if (irqstat & IRQSTAT_DTOE) {
 				err = -ETIMEDOUT;
+#ifdef ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE
+				printf("timeout.. irqstat=%x\n", irqstat);
+#else
+				printf("timeout.. irqstat=%x, do you need ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE\n", irqstat);
+#endif
 				goto out;
 			}
 
@@ -529,8 +546,8 @@
 #endif
 	int ddr_pre_div = mmc->ddr_mode ? 2 : 1;
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
-	int sdhc_clk = priv->sdhc_clk;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
+	int sdhc_clk = priv->c.sdhc_clk;
 	uint clk;
 
 	if (clock < mmc->cfg->f_min)
@@ -569,7 +586,7 @@
 static void esdhc_clock_control(struct mmc *mmc, bool enable)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 	u32 value;
 	u32 time_out;
 
@@ -598,7 +615,7 @@
 static int esdhc_set_ios(struct mmc *mmc)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 
 #ifdef CONFIG_FSL_ESDHC_USE_PERIPHERAL_CLK
 	/* Select to use peripheral clock */
@@ -623,12 +640,15 @@
 static int esdhc_init(struct mmc *mmc)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 	int timeout = 1000;
+#if defined(CONFIG_FSL_USDHC)
+	unsigned vendorspec = VENDORSPEC_INIT;
+#endif
 
 	/* Reset the entire host controller */
 	esdhc_setbits32(&regs->sysctl, SYSCTL_RSTA);
-
+	priv->sysctrl_inita_needed = 1;
 	/* Wait until the controller is available */
 	while ((esdhc_read32(&regs->sysctl) & SYSCTL_RSTA) && --timeout)
 		udelay(1000);
@@ -641,7 +661,9 @@
 	esdhc_write32(&regs->clktunectrlstatus, 0x0);
 
 	/* Put VEND_SPEC to default value */
-	esdhc_write32(&regs->vendorspec, VENDORSPEC_INIT);
+	if (priv->c.flags & CFG_FORCE_1P8V)
+		vendorspec |= ESDHC_VENDORSPEC_VSELECT;
+	esdhc_write32(&regs->vendorspec, vendorspec);
 
 	/* Disable DLL_CTRL delay line */
 	esdhc_write32(&regs->dllctrl, 0x0);
@@ -680,7 +702,7 @@
 static int esdhc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_priv *priv = mmc->priv;
-	struct fsl_esdhc *regs = priv->esdhc_regs;
+	struct fsl_esdhc *regs = priv->c.esdhc_regs;
 	int timeout = 1000;
 
 #ifdef CONFIG_ESDHC_DETECT_QUIRK
@@ -733,10 +755,13 @@
 	if (!priv)
 		return -EINVAL;
 
-	regs = priv->esdhc_regs;
+	regs = priv->c.esdhc_regs;
 
 	/* First reset the eSDHC controller */
+	priv->sysctrl_inita_needed = 1;
 	esdhc_reset(regs);
+	if (priv->c.flags & CFG_FORCE_1P8V)
+		esdhc_setbits32(&regs->vendorspec, ESDHC_VENDORSPEC_VSELECT);
 
 #ifndef CONFIG_FSL_USDHC
 	esdhc_setbits32(&regs->sysctl, SYSCTL_PEREN | SYSCTL_HCKEN
@@ -781,9 +806,9 @@
 		return -1;
 	}
 
-	if (priv->bus_width == 8)
+	if (priv->c.bus_width == 8)
 		priv->cfg.host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
-	else if (priv->bus_width == 4)
+	else if (priv->c.bus_width == 4)
 		priv->cfg.host_caps = MMC_MODE_4BIT;
 
 	priv->cfg.host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
@@ -791,10 +816,10 @@
 	priv->cfg.host_caps |= MMC_MODE_DDR_52MHz;
 #endif
 
-	if (priv->bus_width > 0) {
-		if (priv->bus_width < 8)
+	if (priv->c.bus_width > 0) {
+		if (priv->c.bus_width < 8)
 			priv->cfg.host_caps &= ~MMC_MODE_8BIT;
-		if (priv->bus_width < 4)
+		if (priv->c.bus_width < 4)
 			priv->cfg.host_caps &= ~MMC_MODE_4BIT;
 	}
 
@@ -807,7 +832,7 @@
 #endif
 
 	priv->cfg.f_min = 400000;
-	priv->cfg.f_max = min(priv->sdhc_clk, (u32)52000000);
+	priv->cfg.f_max = min(priv->c.sdhc_clk, (u32)52000000);
 
 	priv->cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
 
@@ -827,11 +852,8 @@
 	if (!cfg || !priv)
 		return -EINVAL;
 
-	priv->esdhc_regs = (struct fsl_esdhc *)(unsigned long)(cfg->esdhc_base);
-	priv->bus_width = cfg->max_bus_width;
-	priv->sdhc_clk = cfg->sdhc_clk;
-	priv->wp_enable  = cfg->wp_enable;
-
+	priv->c = *cfg;
+	priv->c.esdhc_regs = (struct fsl_esdhc *)(unsigned long)(cfg->esdhc_base);
 	return 0;
 };
 
@@ -970,16 +992,16 @@
 	if (addr == FDT_ADDR_T_NONE)
 		return -EINVAL;
 
-	priv->esdhc_regs = (struct fsl_esdhc *)addr;
+	priv->c.esdhc_regs = (struct fsl_esdhc *)addr;
 	priv->dev = dev;
 
 	val = fdtdec_get_int(fdt, node, "bus-width", -1);
 	if (val == 8)
-		priv->bus_width = 8;
+		priv->c.bus_width = 8;
 	else if (val == 4)
-		priv->bus_width = 4;
+		priv->c.bus_width = 4;
 	else
-		priv->bus_width = 1;
+		priv->c.bus_width = 1;
 
 	if (fdt_get_property(fdt, node, "non-removable", NULL)) {
 		priv->non_removable = 1;
@@ -991,13 +1013,13 @@
 #endif
 	}
 
-	priv->wp_enable = 1;
+	priv->c.wp_enable = 1;
 
 #ifdef CONFIG_DM_GPIO
 	ret = gpio_request_by_name_nodev(offset_to_ofnode(node), "wp-gpios", 0,
 					 &priv->wp_gpio, GPIOD_IS_IN);
 	if (ret)
-		priv->wp_enable = 0;
+		priv->c.wp_enable = 0;
 #endif
 	/*
 	 * TODO:
@@ -1021,8 +1043,8 @@
 
 	init_clk_usdhc(dev->seq);
 
-	priv->sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK + dev->seq);
-	if (priv->sdhc_clk <= 0) {
+	priv->c.sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK + dev->seq);
+	if (priv->c.sdhc_clk <= 0) {
 		dev_err(dev, "Unable to get clk for %s\n", dev->name);
 		return -EINVAL;
 	}
diff -Nru u-boot-2017.07/drivers/mmc/mmc.c u-boot-imx6/drivers/mmc/mmc.c
--- u-boot-2017.07/drivers/mmc/mmc.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mmc/mmc.c	2018-08-27 21:35:37.407469495 +0300
@@ -257,7 +257,27 @@
 			return 0;
 		}
 	}
+#ifdef CONFIG_MMC_TRACE
+	{
+		int cnt = blkcnt;
+		unsigned *p = dst;
 
+		while (cnt--) {
+			int rem = mmc->read_bl_len;
+			int offset = 0;
+
+			printf("Block 0x%lx\n", start++);
+			while (rem > 0) {
+				printf("%03x: %08x %08x %08x %08x  %08x %08x %08x %08x\n",
+						offset, p[0], p[1], p[2], p[3],
+						p[4], p[5], p[6], p[7]);
+				rem -= 32;
+				offset += 32;
+				p += 8;
+			}
+		}
+	}
+#endif
 	return blkcnt;
 }
 
diff -Nru u-boot-2017.07/drivers/mtd/spi/Kconfig u-boot-imx6/drivers/mtd/spi/Kconfig
--- u-boot-2017.07/drivers/mtd/spi/Kconfig	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mtd/spi/Kconfig	2018-08-27 21:35:37.417469448 +0300
@@ -66,6 +66,11 @@
 	help
 	  Add support for various GigaDevice SPI flash chips (GD25xxx)
 
+config SPI_FLASH_ISSI
+	bool "ISSI SPI flash support"
+	help
+	  Add support for various ISSI SPI flash chips (IS25xxx)
+
 config SPI_FLASH_MACRONIX
 	bool "Macronix SPI flash support"
 	help
diff -Nru u-boot-2017.07/drivers/mtd/spi/sf_internal.h u-boot-imx6/drivers/mtd/spi/sf_internal.h
--- u-boot-2017.07/drivers/mtd/spi/sf_internal.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mtd/spi/sf_internal.h	2018-08-27 21:35:37.420802765 +0300
@@ -39,6 +39,7 @@
 #define SPI_FLASH_CFI_MFR_ATMEL		0x1f
 
 /* Erase commands */
+#define CMD_ERASE_2K			0x50
 #define CMD_ERASE_4K			0x20
 #define CMD_ERASE_CHIP			0xc7
 #define CMD_ERASE_64K			0xd8
@@ -46,6 +47,10 @@
 /* Write commands */
 #define CMD_WRITE_STATUS		0x01
 #define CMD_PAGE_PROGRAM		0x02
+/* 0x84 followed by 3byte offset into buffer */
+#define CMD_BUFFER1_WRITE		0x84
+/* 0x88 followed by 2 byte page #, and 1 dummy byte */
+#define CMD_BUFFER1_PROGRAM		0x88
 #define CMD_WRITE_DISABLE		0x04
 #define CMD_WRITE_ENABLE		0x06
 #define CMD_QUAD_PAGE_PROGRAM		0x32
@@ -60,6 +65,7 @@
 #define CMD_READ_ID			0x9f
 #define CMD_READ_STATUS			0x05
 #define CMD_READ_STATUS1		0x35
+#define CMD_READ_STATUS2		0xd7
 #define CMD_READ_CONFIG			0x35
 #define CMD_FLAG_STATUS			0x70
 
@@ -76,6 +82,7 @@
 #define STATUS_QEB_WINSPAN		BIT(1)
 #define STATUS_QEB_MXIC			BIT(6)
 #define STATUS_PEC			BIT(7)
+#define STATUS2_READY			BIT(7)
 #define SR_BP0				BIT(2)  /* Block protect 0 */
 #define SR_BP1				BIT(3)  /* Block protect 1 */
 #define SR_BP2				BIT(4)  /* Block protect 2 */
@@ -131,6 +138,8 @@
 #define RD_DUAL			BIT(5)	/* use Dual Read */
 #define RD_QUADIO		BIT(6)	/* use Quad IO Read */
 #define RD_DUALIO		BIT(7)	/* use Dual IO Read */
+#define ATMEL_REGS		BIT(8)
+#define SECT_2K			BIT(9)	/* CMD_ERASE_2K works */
 #define RD_FULL			(RD_QUAD | RD_DUAL | RD_QUADIO | RD_DUALIO)
 };
 
diff -Nru u-boot-2017.07/drivers/mtd/spi/sf-uclass.c u-boot-imx6/drivers/mtd/spi/sf-uclass.c
--- u-boot-2017.07/drivers/mtd/spi/sf-uclass.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mtd/spi/sf-uclass.c	2018-08-27 21:35:37.417469448 +0300
@@ -13,6 +13,12 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_SPI_FLASH_DATAFLASH
+#define SPI_DRIVER "spi_dataflash"
+#else
+#define SPI_DRIVER "spi_flash_std"
+#endif
+
 int spi_flash_read_dm(struct udevice *dev, u32 offset, size_t len, void *buf)
 {
 	return sf_get_ops(dev)->read(dev, offset, len, buf);
@@ -67,7 +73,7 @@
 	str = strdup(name);
 #endif
 	ret = spi_get_bus_and_cs(busnum, cs, max_hz, spi_mode,
-				  "spi_flash_std", str, &bus, &slave);
+				 SPI_DRIVER, str, &bus, &slave);
 	if (ret)
 		return ret;
 
diff -Nru u-boot-2017.07/drivers/mtd/spi/spi_flash.c u-boot-imx6/drivers/mtd/spi/spi_flash.c
--- u-boot-2017.07/drivers/mtd/spi/spi_flash.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mtd/spi/spi_flash.c	2018-08-27 21:35:37.420802765 +0300
@@ -33,15 +33,12 @@
 static int read_sr(struct spi_flash *flash, u8 *rs)
 {
 	int ret;
-	u8 cmd;
 
-	cmd = CMD_READ_STATUS;
-	ret = spi_flash_read_common(flash, &cmd, 1, rs, 1);
+	ret = spi_flash_read_common(flash, &flash->status_cmd, 1, rs, 1);
 	if (ret < 0) {
 		debug("SF: fail to read status register\n");
 		return ret;
 	}
-
 	return 0;
 }
 
@@ -195,8 +192,7 @@
 	ret = read_sr(flash, &sr);
 	if (ret < 0)
 		return ret;
-
-	return !(sr & STATUS_WIP);
+	return (sr & flash->status_ready_mask) == flash->status_ready_level;
 }
 
 static int spi_flash_fsr_ready(struct spi_flash *flash)
@@ -400,6 +396,50 @@
 	return ret;
 }
 
+#ifdef CONFIG_SPI_FLASH_ATMEL
+int spi_flash_cmd_write_ops_atmel(struct spi_flash *flash, u32 offset,
+		size_t len, const void *buf)
+{
+	unsigned long byte_addr, page_size;
+	size_t actual;
+	u8 cmd[4];
+	int ret = -1;
+
+	page_size = flash->page_size;
+
+	byte_addr = offset % page_size;
+	if (byte_addr)
+		return -EINVAL;
+
+	for (actual = 0; actual < len; actual += page_size) {
+		cmd[0] = CMD_BUFFER1_WRITE;
+		cmd[1] = 0;
+		cmd[2] = 0;
+		cmd[3] = 0;
+		ret = spi_flash_write_common(flash, cmd, sizeof(cmd),
+					buf + actual, page_size);
+		if (ret < 0) {
+			debug("SF: write failed\n");
+			break;
+		}
+
+		cmd[0] = CMD_BUFFER1_PROGRAM;
+		spi_flash_addr(offset, cmd);
+
+		ret = spi_flash_write_common(flash, cmd, sizeof(cmd),
+					buf + actual, page_size);
+		if (ret < 0) {
+			debug("SF: write failed\n");
+			break;
+		}
+
+		offset += page_size;
+	}
+
+	return ret;
+}
+#endif
+
 int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 		size_t cmd_len, void *data, size_t data_len)
 {
@@ -947,11 +987,6 @@
 	if (IS_ERR_OR_NULL(info))
 		return -ENOENT;
 
-	/* Flash powers up read-only, so clear BP# bits */
-	if (JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_ATMEL ||
-	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_MACRONIX ||
-	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_SST)
-		write_sr(flash, 0);
 
 	flash->name = info->name;
 	flash->memory_map = spi->memory_map;
@@ -969,6 +1004,19 @@
 			flash->write = sst_write_wp;
 	}
 #endif
+
+	flash->status_cmd = CMD_READ_STATUS;
+	flash->status_ready_mask = STATUS_WIP;
+	flash->status_ready_level = 0;
+
+#ifdef CONFIG_SPI_FLASH_ATMEL
+	if (info->flags & ATMEL_REGS) {
+		flash->write = spi_flash_cmd_write_ops_atmel;
+		flash->status_cmd = CMD_READ_STATUS2;
+		flash->status_ready_mask = STATUS2_READY;
+		flash->status_ready_level = STATUS2_READY;
+	}
+#endif
 	flash->erase = spi_flash_cmd_erase_ops;
 	flash->read = spi_flash_cmd_read_ops;
 #endif
@@ -1010,6 +1058,9 @@
 	if (info->flags & SECT_4K) {
 		flash->erase_cmd = CMD_ERASE_4K;
 		flash->erase_size = 4096 << flash->shift;
+	} else if (info->flags & SECT_2K) {
+		flash->erase_cmd = CMD_ERASE_2K;
+		flash->erase_size = 2048 << flash->shift;
 	} else
 #endif
 	{
@@ -1036,6 +1087,12 @@
 		/* Go for default supported write cmd */
 		flash->write_cmd = CMD_PAGE_PROGRAM;
 
+	/* Flash powers up read-only, so clear BP# bits */
+	if (JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_ATMEL ||
+	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_MACRONIX ||
+	    JEDEC_MFR(info) == SPI_FLASH_CFI_MFR_SST)
+		write_sr(flash, 0);
+
 	/* Set the quad enable bit - only for quad commands */
 	if ((flash->read_cmd == CMD_READ_QUAD_OUTPUT_FAST) ||
 	    (flash->read_cmd == CMD_READ_QUAD_IO_FAST) ||
@@ -1088,6 +1145,7 @@
 #endif
 
 #ifndef CONFIG_SPL_BUILD
+	setenv("sfname", flash->name);
 	printf("SF: Detected %s with page size ", flash->name);
 	print_size(flash->page_size, ", erase size ");
 	print_size(flash->erase_size, ", total ");
diff -Nru u-boot-2017.07/drivers/mtd/spi/spi_flash_ids.c u-boot-imx6/drivers/mtd/spi/spi_flash_ids.c
--- u-boot-2017.07/drivers/mtd/spi/spi_flash_ids.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/mtd/spi/spi_flash_ids.c	2018-08-27 21:35:37.420802765 +0300
@@ -47,7 +47,7 @@
 #ifdef CONFIG_SPI_FLASH_ATMEL		/* ATMEL */
 	{"at45db011d",	   INFO(0x1f2200, 0x0, 64 * 1024,     4, SECT_4K) },
 	{"at45db021d",	   INFO(0x1f2300, 0x0, 64 * 1024,     8, SECT_4K) },
-	{"at45db041d",	   INFO(0x1f2400, 0x0, 64 * 1024,     8, SECT_4K) },
+	{"at45db041d",	   INFO(0x1f2400, 0x0, 64 * 1024,     8, SECT_2K | ATMEL_REGS) },
 	{"at45db081d",	   INFO(0x1f2500, 0x0, 64 * 1024,    16, SECT_4K) },
 	{"at45db161d",	   INFO(0x1f2600, 0x0, 64 * 1024,    32, SECT_4K) },
 	{"at45db321d",	   INFO(0x1f2700, 0x0, 64 * 1024,    64, SECT_4K) },
@@ -63,6 +63,7 @@
 	{"en25s64",	   INFO(0x1c3817, 0x0, 64 * 1024,   128, 0) },
 #endif
 #ifdef CONFIG_SPI_FLASH_GIGADEVICE	/* GIGADEVICE */
+	{"gd25q16c",	   INFO(0xc84015, 0x0, 64 * 1024,    32, SECT_4K) },
 	{"gd25q64b",	   INFO(0xc84017, 0x0, 64 * 1024,   128, SECT_4K) },
 	{"gd25lq32",	   INFO(0xc86016, 0x0, 64 * 1024,    64, SECT_4K) },
 #endif
@@ -70,6 +71,10 @@
 	{"is25lp032",	   INFO(0x9d6016, 0x0, 64 * 1024,    64, 0) },
 	{"is25lp064",	   INFO(0x9d6017, 0x0, 64 * 1024,   128, 0) },
 	{"is25lp128",	   INFO(0x9d6018, 0x0, 64 * 1024,   256, 0) },
+
+	{"is25wp032",	   INFO(0x9d7016, 0x0, 64 * 1024,    64, SECT_4K) },
+	{"is25wp064",	   INFO(0x9d7017, 0x0, 64 * 1024,   128, SECT_4K) },
+	{"is25wp128",	   INFO(0x9d7018, 0x0, 64 * 1024,   256, SECT_4K) },
 #endif
 #ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
 	{"mx25l2006e",	   INFO(0xc22012, 0x0, 64 * 1024,     4, 0) },
@@ -90,12 +95,13 @@
 	{"s25fl016a",	   INFO(0x010214, 0x0, 64 * 1024,    32, 0) },
 	{"s25fl032a",	   INFO(0x010215, 0x0, 64 * 1024,    64, 0) },
 	{"s25fl064a",	   INFO(0x010216, 0x0, 64 * 1024,   128, 0) },
-	{"s25fl116k",	   INFO(0x014015, 0x0, 64 * 1024,   128, 0) },
+	{"s25fl116k",	   INFO(0x014015, 0x0, 64 * 1024,   128, SECT_4K) },
 	{"s25fl164k",	   INFO(0x014017, 0x0140,  64 * 1024,   128, 0) },
 	{"s25fl128p_256k", INFO(0x012018, 0x0300, 256 * 1024,    64, RD_FULL | WR_QPP) },
 	{"s25fl128p_64k",  INFO(0x012018, 0x0301,  64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"s25fl032p",	   INFO(0x010215, 0x4d00,  64 * 1024,    64, RD_FULL | WR_QPP) },
 	{"s25fl064p",	   INFO(0x010216, 0x4d00,  64 * 1024,   128, RD_FULL | WR_QPP) },
+	{"s25fl064l",	   INFO(0x016017, 0x0,  64 * 1024,   128, RD_FULL | WR_QPP | SECT_4K) },
 	{"s25fl128s_256k", INFO(0x012018, 0x4d00, 256 * 1024,    64, RD_FULL | WR_QPP) },
 	{"s25fl128s_64k",  INFO(0x012018, 0x4d01,  64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"s25fl256s_256k", INFO(0x010219, 0x4d00, 256 * 1024,   128, RD_FULL | WR_QPP) },
diff -Nru u-boot-2017.07/drivers/net/phy/atheros.c u-boot-imx6/drivers/net/phy/atheros.c
--- u-boot-2017.07/drivers/net/phy/atheros.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/net/phy/atheros.c	2018-08-27 21:35:37.437469353 +0300
@@ -7,6 +7,7 @@
  * author Andy Fleming
  */
 #include <phy.h>
+#include <common.h>
 
 #define AR803x_PHY_DEBUG_ADDR_REG	0x1d
 #define AR803x_PHY_DEBUG_DATA_REG	0x1e
@@ -54,6 +55,8 @@
 
 static int ar8035_config(struct phy_device *phydev)
 {
+	unsigned ctrl1000 = 0;
+	unsigned features = phydev->drv->features;
 	int regval;
 
 	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x0007);
@@ -82,8 +85,15 @@
 		phy_write(phydev, MDIO_DEVAD_NONE, 0x1E, 0x8000);
 	}
 
-	phydev->supported = phydev->drv->features;
-
+	if (getenv("disable_giga"))
+		features &= ~(SUPPORTED_1000baseT_Half |
+				SUPPORTED_1000baseT_Full);
+	if (features & SUPPORTED_1000baseT_Half)
+		ctrl1000 |= ADVERTISE_1000HALF;
+	if (features & SUPPORTED_1000baseT_Full)
+		ctrl1000 |= ADVERTISE_1000FULL;
+	phydev->advertising = phydev->supported = features;
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, ctrl1000);
 	genphy_config_aneg(phydev);
 	genphy_restart_aneg(phydev);
 
diff -Nru u-boot-2017.07/drivers/net/phy/phy.c u-boot-imx6/drivers/net/phy/phy.c
--- u-boot-2017.07/drivers/net/phy/phy.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/net/phy/phy.c	2018-08-27 21:35:37.440802671 +0300
@@ -770,7 +770,7 @@
 	}
 #endif
 
-	if (phy_write(phydev, devad, MII_BMCR, BMCR_RESET) < 0) {
+	if (phy_write(phydev, devad, MII_BMCR, BMCR_RESET|BMCR_ANENABLE) < 0) {
 		debug("PHY reset failed\n");
 		return -1;
 	}
diff -Nru u-boot-2017.07/drivers/spi/fsl_qspi.c u-boot-imx6/drivers/spi/fsl_qspi.c
--- u-boot-2017.07/drivers/spi/fsl_qspi.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/spi/fsl_qspi.c	2018-08-27 21:35:37.554135465 +0300
@@ -6,6 +6,7 @@
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
+#include <asm/arch/clock.h>
 #include <common.h>
 #include <malloc.h>
 #include <spi.h>
@@ -27,6 +28,7 @@
 
 #define OFFSET_BITS_MASK	GENMASK(23, 0)
 
+#define FLASH_STATUS_BUSY	0x01
 #define FLASH_STATUS_WEL	0x02
 
 /* SEQID */
@@ -38,16 +40,25 @@
 #define SEQID_PP		6
 #define SEQID_RDID		7
 #define SEQID_BE_4K		8
+
 #ifdef CONFIG_SPI_FLASH_BAR
 #define SEQID_BRRD		9
 #define SEQID_BRWR		10
 #define SEQID_RDEAR		11
 #define SEQID_WREAR		12
+#else
+#define SEQID_WRITE_STATUS	9
+#define SEQID_SST_AAI_WP	10
+#define SEQID_SST_AAI_WP_CONT	11
+#define SEQID_WRITE_DISABLE	12
 #endif
 #define SEQID_WRAR		13
 #define SEQID_RDAR		14
 
 /* QSPI CMD */
+#define QSPI_CMD_WRITE_STATUS	0x01	/* Write status register */
+#define QSPI_CMD_WRITE_DISABLE	0x04	/* exit autoinc write */
+#define QSPI_CMD_SST_AAI_WP	0xad	/* Auto Address Incr Word Program(sst specific) */
 #define QSPI_CMD_PP		0x02	/* Page program (up to 256 bytes) */
 #define QSPI_CMD_RDSR		0x05	/* Read status register */
 #define QSPI_CMD_WREN		0x06	/* Write enable */
@@ -112,7 +123,7 @@
  * @flags: Flags for QSPI QSPI_FLAG_...
  * @bus_clk: QSPI input clk frequency
  * @speed_hz: Default SCK frequency
- * @cur_seqid: current LUT table sequence id
+ * @cur_cmd: current command
  * @sf_addr: flash access offset
  * @amba_base: Base address of QSPI memory mapping of every CS
  * @amba_total_size: size of QSPI memory mapping
@@ -125,13 +136,15 @@
 	u32 flags;
 	u32 bus_clk;
 	u32 speed_hz;
-	u32 cur_seqid;
+	u32 cur_cmd;
+	u32 prev_cmd;
 	u32 sf_addr;
 	u32 amba_base[FSL_QSPI_MAX_CHIPSELECT_NUM];
 	u32 amba_total_size;
 	u32 cur_amba_base;
 	u32 flash_num;
 	u32 num_chipselect;
+	u32 aai_mode;
 	struct fsl_qspi_regs *regs;
 };
 
@@ -165,190 +178,185 @@
 #endif
 }
 
-static void qspi_set_lut(struct fsl_qspi_priv *priv)
+struct lut_entry
 {
-	struct fsl_qspi_regs *regs = priv->regs;
-	u32 lut_base;
-
-	/* Unlock the LUT */
-	qspi_write32(priv->flags, &regs->lutkey, LUT_KEY_VALUE);
-	qspi_write32(priv->flags, &regs->lckcr, QSPI_LCKCR_UNLOCK);
-
-	/* Write Enable */
-	lut_base = SEQID_WREN * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_WREN) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Fast Read */
-	lut_base = SEQID_FAST_READ * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_FAST_READ) | PAD0(LUT_PAD1) |
-		     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_FAST_READ) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_FAST_READ_4B) |
-			     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) |
-			     OPRND1(ADDR32BIT) | PAD1(LUT_PAD1) |
-			     INSTR1(LUT_ADDR));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(8) | PAD0(LUT_PAD1) | INSTR0(LUT_DUMMY) |
-		     OPRND1(RX_BUFFER_SIZE) | PAD1(LUT_PAD1) |
-		     INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Read Status */
-	lut_base = SEQID_RDSR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDSR) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Erase a sector */
-	lut_base = SEQID_SE * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_SE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_SE) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_SE_4B) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Erase the whole chip */
-	lut_base = SEQID_CHIP_ERASE * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_CHIP_ERASE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* Page Program */
-	lut_base = SEQID_PP * 4;
-#ifdef CONFIG_SPI_FLASH_BAR
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_PP) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-#else
-	if (FSL_QSPI_FLASH_SIZE  <= SZ_16M)
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_PP) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	else
-		qspi_write32(priv->flags, &regs->lut[lut_base],
-			     OPRND0(QSPI_CMD_PP_4B) | PAD0(LUT_PAD1) |
-			     INSTR0(LUT_CMD) | OPRND1(ADDR32BIT) |
-			     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
+	u32 entry[4];
+};
+static struct lut_entry lut_table[] = {
+/* Write Enable */
+[SEQID_WREN] = {
+		{ LUT0(LUT_CMD, QSPI_CMD_WREN, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* Fast Read */
+[SEQID_FAST_READ] = {
+		{
+#if defined(CONFIG_SPI_FLASH_BAR) || (FSL_QSPI_FLASH_SIZE <= SZ_16M)
+		LUT0(LUT_CMD, QSPI_CMD_FAST_READ, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+#else
+		LUT0(LUT_CMD, QSPI_CMD_FAST_READ_4B, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR32BIT, LUT_PAD1),
+#endif
+		LUT0(LUT_DUMMY, 8, LUT_PAD1) |
+		LUT1(LUT_READ, RX_BUFFER_SIZE, LUT_PAD1),
+		0, 0 }
+	},
+/* Read Status */
+[SEQID_RDSR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_RDSR, LUT_PAD1) |
+		LUT1(LUT_READ, 1, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* Erase a sector */
+[SEQID_SE] = {
+		{
+#if defined(CONFIG_SPI_FLASH_BAR) || (FSL_QSPI_FLASH_SIZE <= SZ_16M)
+		LUT0(LUT_CMD, QSPI_CMD_SE, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+#else
+		LUT0(LUT_CMD, QSPI_CMD_SE_4B, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR32BIT, LUT_PAD1),
+#endif
+		0, 0, 0 }
+	},
+/* Erase the whole chip */
+[SEQID_CHIP_ERASE] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_CHIP_ERASE, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* Page Program */
+[SEQID_PP] = {
+		{
+#if defined(CONFIG_SPI_FLASH_BAR) || (FSL_QSPI_FLASH_SIZE <= SZ_16M)
+		LUT0(LUT_CMD, QSPI_CMD_PP, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+#else
+		LUT0(LUT_CMD, QSPI_CMD_PP_4B, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR32BIT, LUT_PAD1),
 #endif
 #ifdef CONFIG_MX6SX
-	/*
-	 * To MX6SX, OPRND0(TX_BUFFER_SIZE) can not work correctly.
-	 * So, Use IDATSZ in IPCR to determine the size and here set 0.
-	 */
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], OPRND0(0) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
+		/*
+		 * For MX6SX, TX_BUFFER_SIZE (0x200 is > 0xff) can not work correctly.
+		 * So, Use IDATSZ in IPCR to determine the size and here set 0.
+		 */
+		LUT0(LUT_WRITE, 0, LUT_PAD1),
 #else
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(TX_BUFFER_SIZE) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
-#endif
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* READ ID */
-	lut_base = SEQID_RDID * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDID) |
-		PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(8) |
-		PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 2], 0);
-	qspi_write32(priv->flags, &regs->lut[lut_base + 3], 0);
-
-	/* SUB SECTOR 4K ERASE */
-	lut_base = SEQID_BE_4K * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BE_4K) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-
+		LUT0(LUT_WRITE, TX_BUFFER_SIZE, LUT_PAD1),
+#endif
+		0, 0 }
+	},
+/* READ ID */
+[SEQID_RDID] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_RDID, LUT_PAD1) |
+		LUT1(LUT_READ, 8, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* SUB SECTOR 4K ERASE */
+[SEQID_BE_4K] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_BE_4K, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+		0, 0, 0 }
+	},
 #ifdef CONFIG_SPI_FLASH_BAR
 	/*
 	 * BRRD BRWR RDEAR WREAR are all supported, because it is hard to
 	 * dynamically check whether to set BRRD BRWR or RDEAR WREAR during
 	 * initialization.
 	 */
-	lut_base = SEQID_BRRD * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BRRD) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-
-	lut_base = SEQID_BRWR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_BRWR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_WRITE));
-
-	lut_base = SEQID_RDEAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_RDEAR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_READ));
-
-	lut_base = SEQID_WREAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base], OPRND0(QSPI_CMD_WREAR) |
-		     PAD0(LUT_PAD1) | INSTR0(LUT_CMD) | OPRND1(1) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_WRITE));
-#endif
+[SEQID_BRRD] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_BRRD, LUT_PAD1) |
+		LUT1(LUT_READ, 1, LUT_PAD1),
+		0, 0, 0 }
+	},
+[SEQID_BRWR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_BRWR, LUT_PAD1) |
+		LUT1(LUT_WRITE, 1, LUT_PAD1),
+		0, 0, 0 }
+	},
+[SEQID_RDEAR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_RDEAR, LUT_PAD1) |
+		LUT1(LUT_READ, 1, LUT_PAD1),
+		0, 0, 0 }
+	},
+[SEQID_WREAR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_WREAR, LUT_PAD1) |
+		LUT1(LUT_WRITE, 1, LUT_PAD1),
+		0, 0, 0 }
+},
+#else
+/* Write Status */
+[SEQID_WRITE_STATUS] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_WRITE_STATUS, LUT_PAD1) |
+		LUT1(LUT_WRITE, 1, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* SST_AAI_WP start */
+[SEQID_SST_AAI_WP] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_SST_AAI_WP, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+		LUT0(LUT_WRITE, 2, LUT_PAD1),
+		0, 0 }
+	},
+/* SST_AAI_WP continue */
+[SEQID_SST_AAI_WP_CONT] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_SST_AAI_WP, LUT_PAD1) |
+		LUT1(LUT_WRITE, 2, LUT_PAD1),
+		0, 0, 0 }
+	},
+/* WRITE_DISABLE */
+[SEQID_WRITE_DISABLE] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_WRITE_DISABLE, LUT_PAD1),
+		0, 0, 0 }
+	},
+#endif
+[SEQID_WRAR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_WRAR, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+		LUT0(LUT_WRITE, 1, LUT_PAD1),
+		0, 0 }
+	},
+[SEQID_RDAR] = {
+		{
+		LUT0(LUT_CMD, QSPI_CMD_RDAR, LUT_PAD1) |
+		LUT1(LUT_ADDR, ADDR24BIT, LUT_PAD1),
+		LUT0(LUT_DUMMY, 8, LUT_PAD1) |
+		LUT1(LUT_READ, 1, LUT_PAD1),
+		0, 0 }
+	},
+};
 
-	/*
-	 * Read any device register.
-	 * Used for Spansion S25FS-S family flash only.
-	 */
-	lut_base = SEQID_RDAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_RDAR) | PAD0(LUT_PAD1) |
-		     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(8) | PAD0(LUT_PAD1) | INSTR0(LUT_DUMMY) |
-		     OPRND1(1) | PAD1(LUT_PAD1) |
-		     INSTR1(LUT_READ));
+static void qspi_set_lut(struct fsl_qspi_priv *priv)
+{
+	struct fsl_qspi_regs *regs = priv->regs;
+	struct lut_entry *e = lut_table;
+	int i;
 
-	/*
-	 * Write any device register.
-	 * Used for Spansion S25FS-S family flash only.
-	 */
-	lut_base = SEQID_WRAR * 4;
-	qspi_write32(priv->flags, &regs->lut[lut_base],
-		     OPRND0(QSPI_CMD_WRAR) | PAD0(LUT_PAD1) |
-		     INSTR0(LUT_CMD) | OPRND1(ADDR24BIT) |
-		     PAD1(LUT_PAD1) | INSTR1(LUT_ADDR));
-	qspi_write32(priv->flags, &regs->lut[lut_base + 1],
-		     OPRND0(1) | PAD0(LUT_PAD1) | INSTR0(LUT_WRITE));
+	/* Unlock the LUT */
+	qspi_write32(priv->flags, &regs->lutkey, LUT_KEY_VALUE);
+	qspi_write32(priv->flags, &regs->lckcr, QSPI_LCKCR_UNLOCK);
+
+	for (i = 0; i < ARRAY_SIZE(lut_table); i++, e++) {
+		u32 *p = &regs->lut[i * 4];
+
+		qspi_write32(priv->flags, &p[0], e->entry[0]);
+		qspi_write32(priv->flags, &p[1], e->entry[1]);
+		qspi_write32(priv->flags, &p[2], e->entry[2]);
+		qspi_write32(priv->flags, &p[3], e->entry[3]);
+	}
 
 	/* Lock the LUT */
 	qspi_write32(priv->flags, &regs->lutkey, LUT_KEY_VALUE);
@@ -465,6 +473,75 @@
 }
 #endif
 
+static void qspi_start_transaction_tx(struct fsl_qspi_priv *priv, int seqid, int len)
+{
+	struct fsl_qspi_regs *regs = priv->regs;
+
+//	if ((seqid != SEQID_SST_AAI_WP_CONT) || (len != 2))
+//		if ((seqid != SEQID_RDSR) || (len != 0))
+			debug("%s:cmd=%02x, seqid=%02x, len=%x sfar=%x\n", __func__,
+				priv->cur_cmd, seqid, len,
+				priv->sf_addr + priv->cur_amba_base);
+
+	qspi_write32(priv->flags, &regs->sfar,
+			priv->sf_addr + priv->cur_amba_base);
+
+	qspi_write32(priv->flags, &regs->ipcr,
+			(seqid << QSPI_IPCR_SEQID_SHIFT) | len);
+
+	/* Wait previous command complete */
+	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
+		;
+}
+
+static void qspi_start_transaction(struct fsl_qspi_priv *priv, int seqid, int len)
+{
+	struct fsl_qspi_regs *regs = priv->regs;
+
+	qspi_write32(priv->flags, &regs->mcr,
+		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	qspi_start_transaction_tx(priv, seqid, len);
+}
+
+static u32 qspi_rx_single_entry(struct fsl_qspi_priv *priv)
+{
+	u32 data;
+	struct fsl_qspi_regs *regs = priv->regs;
+
+	do {
+		data = qspi_read32(priv->flags, &regs->rbsr);
+	} while (!(data & QSPI_RBSR_RDBFL_MASK));
+
+	data = qspi_read32(priv->flags, &regs->rbdr[0]);
+	data = qspi_endian_xchg(data);
+	return data;
+}
+
+static u32 wait_for_idle(struct fsl_qspi_priv *priv)
+{
+	u32 status_reg;
+
+	do {
+		qspi_start_transaction(priv, SEQID_RDSR, 1);
+		status_reg = qspi_rx_single_entry(priv);
+	} while ((status_reg & FLASH_STATUS_BUSY));
+
+	return status_reg;
+}
+
+static void qspi_send_cmd(struct fsl_qspi_priv *priv, int seq)
+{
+	struct fsl_qspi_regs *regs = priv->regs;
+	u32 mcr_reg = qspi_read32(priv->flags, &regs->mcr);
+
+	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
+
+	qspi_start_transaction(priv, seq, 0);
+
+	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
+}
+
 #ifdef CONFIG_SPI_FLASH_BAR
 /* Bank register read/write, EAR register read/write */
 static void qspi_op_rdbank(struct fsl_qspi_priv *priv, u8 *rxbuf, u32 len)
@@ -473,37 +550,17 @@
 	u32 reg, mcr_reg, data, seqid;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
 
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
 
-	if (priv->cur_seqid == QSPI_CMD_BRRD)
+	if (priv->cur_cmd == QSPI_CMD_BRRD)
 		seqid = SEQID_BRRD;
 	else
 		seqid = SEQID_RDEAR;
 
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (seqid << QSPI_IPCR_SEQID_SHIFT) | len);
-
-	/* Wait previous command complete */
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
-	while (1) {
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			data = qspi_read32(priv->flags, &regs->rbdr[0]);
-			data = qspi_endian_xchg(data);
-			memcpy(rxbuf, &data, len);
-			qspi_write32(priv->flags, &regs->mcr,
-				     qspi_read32(priv->flags, &regs->mcr) |
-				     QSPI_MCR_CLR_RXF_MASK);
-			break;
-		}
-	}
+	qspi_start_transaction(priv, seqid, len);
+	data = qspi_rx_single_entry(priv);
+	memcpy(rxbuf, &data, len);
 
 	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
 }
@@ -516,17 +573,9 @@
 	int i;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
 
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
-
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_RDID << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
+	qspi_start_transaction(priv, SEQID_RDID, len);
 
 	i = 0;
 	while ((RX_BUFFER_SIZE >= len) && (len > 0)) {
@@ -551,54 +600,41 @@
 	struct fsl_qspi_regs *regs = priv->regs;
 	u32 mcr_reg, data;
 	int i, size;
-	u32 to_or_from;
 	u32 seqid;
 
-	if (priv->cur_seqid == QSPI_CMD_RDAR)
+	if (priv->cur_cmd == QSPI_CMD_RDAR)
 		seqid = SEQID_RDAR;
 	else
 		seqid = SEQID_FAST_READ;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
 
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-
 	while (len > 0) {
 		WATCHDOG_RESET();
-
-		qspi_write32(priv->flags, &regs->sfar, to_or_from);
-
 		size = (len > RX_BUFFER_SIZE) ?
 			RX_BUFFER_SIZE : len;
 
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (seqid << QSPI_IPCR_SEQID_SHIFT) |
-			     size);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
+		qspi_start_transaction(priv, seqid, size);
 
-		to_or_from += size;
+		priv->sf_addr += size;
 		len -= size;
 
 		i = 0;
 		while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
-			data = qspi_read32(priv->flags, &regs->rbdr[i]);
-			data = qspi_endian_xchg(data);
-			if (size < 4)
-				memcpy(rxbuf, &data, size);
-			else
-				memcpy(rxbuf, &data, 4);
-			rxbuf++;
-			size -= 4;
-			i++;
+			data = qspi_read32(priv->flags, &regs->rbsr);
+			if (data & QSPI_RBSR_RDBFL_MASK) {
+				data = qspi_read32(priv->flags, &regs->rbdr[i]);
+				data = qspi_endian_xchg(data);
+				if (size < 4)
+					memcpy(rxbuf, &data, size);
+				else
+					memcpy(rxbuf, &data, 4);
+				rxbuf++;
+				size -= 4;
+				i++;
+			}
 		}
-		qspi_write32(priv->flags, &regs->mcr,
-			     qspi_read32(priv->flags, &regs->mcr) |
-			     QSPI_MCR_CLR_RXF_MASK);
 	}
 
 	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
@@ -607,78 +643,64 @@
 static void qspi_op_write(struct fsl_qspi_priv *priv, u8 *txbuf, u32 len)
 {
 	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, data, reg, status_reg, seqid;
+	u32 mcr_reg, data, status_reg, seqid;
 	int i, size, tx_size;
-	u32 to_or_from = 0;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
-
-	status_reg = 0;
-	while ((status_reg & FLASH_STATUS_WEL) != FLASH_STATUS_WEL) {
-		WATCHDOG_RESET();
-
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
-
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 1);
-		while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-			;
-
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			status_reg = qspi_read32(priv->flags, &regs->rbdr[0]);
-			status_reg = qspi_endian_xchg(status_reg);
-		}
-		qspi_write32(priv->flags, &regs->mcr,
-			     qspi_read32(priv->flags, &regs->mcr) |
-			     QSPI_MCR_CLR_RXF_MASK);
-	}
+	WATCHDOG_RESET();
 
 	/* Default is page programming */
 	seqid = SEQID_PP;
-	if (priv->cur_seqid == QSPI_CMD_WRAR)
+	if (priv->cur_cmd == QSPI_CMD_WRAR)
 		seqid = SEQID_WRAR;
 #ifdef CONFIG_SPI_FLASH_BAR
-	if (priv->cur_seqid == QSPI_CMD_BRWR)
+	if (priv->cur_cmd == QSPI_CMD_BRWR)
 		seqid = SEQID_BRWR;
-	else if (priv->cur_seqid == QSPI_CMD_WREAR)
+	else if (priv->cur_cmd == QSPI_CMD_WREAR)
 		seqid = SEQID_WREAR;
+#else
+	if (priv->cur_cmd == QSPI_CMD_SST_AAI_WP) {
+		seqid = priv->aai_mode ? SEQID_SST_AAI_WP_CONT : SEQID_SST_AAI_WP;
+		priv->aai_mode = 1;
+	} else if (priv->cur_cmd == QSPI_CMD_WRITE_STATUS) {
+		seqid = SEQID_WRITE_STATUS;
+	}
 #endif
 
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-
-	qspi_write32(priv->flags, &regs->sfar, to_or_from);
+	if ((seqid != SEQID_SST_AAI_WP_CONT)) {
+		do {
+			qspi_start_transaction(priv, SEQID_WREN, 0);
+			status_reg = wait_for_idle(priv);
+			/* Try until write is enabled */
+		} while (!(status_reg & FLASH_STATUS_WEL));
+	}
 
-	tx_size = (len > TX_BUFFER_SIZE) ?
-		TX_BUFFER_SIZE : len;
+	qspi_write32(priv->flags, &regs->mcr,
+		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
+	tx_size = (len > TX_BUFFER_SIZE) ? TX_BUFFER_SIZE : len;
 
-	size = tx_size / 4;
-	for (i = 0; i < size; i++) {
-		memcpy(&data, txbuf, 4);
+	i = tx_size;
+	while (i) {
+		size = 4;
+		if (size > i) {
+			data = 0;
+			size = i;
+		}
+		memcpy(&data, txbuf, size);
 		data = qspi_endian_xchg(data);
 		qspi_write32(priv->flags, &regs->tbdr, data);
-		txbuf += 4;
+		txbuf += size;
+		i -= size;
 	}
-
-	size = tx_size % 4;
-	if (size) {
-		data = 0;
-		memcpy(&data, txbuf, size);
-		data = qspi_endian_xchg(data);
+	i = tx_size;
+	while (i <= 12) {
 		qspi_write32(priv->flags, &regs->tbdr, data);
+		i += 4;
 	}
 
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (seqid << QSPI_IPCR_SEQID_SHIFT) | tx_size);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
+	qspi_start_transaction_tx(priv, seqid, tx_size);
 
 	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
 }
@@ -686,33 +708,14 @@
 static void qspi_op_rdsr(struct fsl_qspi_priv *priv, void *rxbuf, u32 len)
 {
 	struct fsl_qspi_regs *regs = priv->regs;
-	u32 mcr_reg, reg, data;
+	u32 mcr_reg, data;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
 
-	qspi_write32(priv->flags, &regs->sfar, priv->cur_amba_base);
-
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_RDSR << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
-	while (1) {
-		reg = qspi_read32(priv->flags, &regs->rbsr);
-		if (reg & QSPI_RBSR_RDBFL_MASK) {
-			data = qspi_read32(priv->flags, &regs->rbdr[0]);
-			data = qspi_endian_xchg(data);
-			memcpy(rxbuf, &data, len);
-			qspi_write32(priv->flags, &regs->mcr,
-				     qspi_read32(priv->flags, &regs->mcr) |
-				     QSPI_MCR_CLR_RXF_MASK);
-			break;
-		}
-	}
+	qspi_start_transaction(priv, SEQID_RDSR, 1);
+	data = qspi_rx_single_entry(priv);
+	memcpy(rxbuf, &data, len);
 
 	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
 }
@@ -721,32 +724,18 @@
 {
 	struct fsl_qspi_regs *regs = priv->regs;
 	u32 mcr_reg;
-	u32 to_or_from = 0;
 
 	mcr_reg = qspi_read32(priv->flags, &regs->mcr);
-	qspi_write32(priv->flags, &regs->mcr,
-		     QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
-		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_END_CFD_LE);
 	qspi_write32(priv->flags, &regs->rbct, QSPI_RBCT_RXBRD_USEIPS);
 
-	to_or_from = priv->sf_addr + priv->cur_amba_base;
-	qspi_write32(priv->flags, &regs->sfar, to_or_from);
+	qspi_start_transaction(priv, SEQID_WREN, 0);
 
-	qspi_write32(priv->flags, &regs->ipcr,
-		     (SEQID_WREN << QSPI_IPCR_SEQID_SHIFT) | 0);
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
 
-	if (priv->cur_seqid == QSPI_CMD_SE) {
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_SE << QSPI_IPCR_SEQID_SHIFT) | 0);
-	} else if (priv->cur_seqid == QSPI_CMD_BE_4K) {
-		qspi_write32(priv->flags, &regs->ipcr,
-			     (SEQID_BE_4K << QSPI_IPCR_SEQID_SHIFT) | 0);
+	if (priv->cur_cmd == QSPI_CMD_SE) {
+		qspi_start_transaction(priv, SEQID_SE, 0);
+	} else if (priv->cur_cmd == QSPI_CMD_BE_4K) {
+		qspi_start_transaction(priv, SEQID_BE_4K, 0);
 	}
-	while (qspi_read32(priv->flags, &regs->sr) & QSPI_SR_BUSY_MASK)
-		;
-
 	qspi_write32(priv->flags, &regs->mcr, mcr_reg);
 }
 
@@ -754,67 +743,114 @@
 		const void *dout, void *din, unsigned long flags)
 {
 	u32 bytes = DIV_ROUND_UP(bitlen, 8);
-	static u32 wr_sfaddr;
-	u32 txbuf;
 
 	if (dout) {
 		if (flags & SPI_XFER_BEGIN) {
-			priv->cur_seqid = *(u8 *)dout;
-			memcpy(&txbuf, dout, 4);
+			priv->prev_cmd = priv->cur_cmd;
+			priv->cur_cmd = *(u8 *)dout;
+			debug("%s: cur_cmd=%02x\n", __func__, priv->cur_cmd);
+			switch (priv->cur_cmd) {
+#ifdef CONFIG_SPI_FLASH_BAR
+			case QSPI_CMD_BRWR:
+			case QSPI_CMD_WREAR:
+			case QSPI_CMD_BRRD:
+			case QSPI_CMD_RDEAR:
+				break;
+#else
+			case QSPI_CMD_WRITE_STATUS:
+			case QSPI_CMD_WRITE_DISABLE:
+				break;
+			case QSPI_CMD_SST_AAI_WP:
+#endif
+			case QSPI_CMD_FAST_READ:
+			case QSPI_CMD_RDAR:
+			case QSPI_CMD_SE:
+			case QSPI_CMD_PP:
+			case QSPI_CMD_WRAR:
+			case QSPI_CMD_BE_4K:
+				if (bitlen >= 16) {
+					u32 txbuf = 0;
+					int len = (bitlen <= 32) ?
+							bitlen >> 3 : 4;
+
+					memcpy(&txbuf, dout, len);
+					priv->sf_addr = swab32(txbuf)
+							& OFFSET_BITS_MASK;
+				}
+			case QSPI_CMD_RDID:
+			case QSPI_CMD_RDSR:
+			case QSPI_CMD_WREN:
+				break;
+			default:
+				printf("%s: unexpected cmd=%02x\n", __func__, priv->cur_cmd);
+			}
 		}
 
 		if (flags == SPI_XFER_END) {
-			priv->sf_addr = wr_sfaddr;
 			qspi_op_write(priv, (u8 *)dout, bytes);
+			if ((priv->cur_cmd) == QSPI_CMD_WRITE_STATUS) {
+				u32 wanted = *(u8 *)dout;
+				u32 status = wait_for_idle(priv);
+
+				if ((status ^ wanted) & 0x3c)
+					printf("!!write_status: wanted %x, got=%x\n",
+						wanted, status);
+			}
 			return 0;
 		}
 
-		if (priv->cur_seqid == QSPI_CMD_FAST_READ ||
-		    priv->cur_seqid == QSPI_CMD_RDAR) {
-			priv->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
-		} else if ((priv->cur_seqid == QSPI_CMD_SE) ||
-			   (priv->cur_seqid == QSPI_CMD_BE_4K)) {
-			priv->sf_addr = swab32(txbuf) & OFFSET_BITS_MASK;
+		switch (priv->cur_cmd) {
+		case QSPI_CMD_WREN:
+			/* This is done in the write command */
+			break;
+		case QSPI_CMD_SE:
+		case QSPI_CMD_BE_4K:
 			qspi_op_erase(priv);
-		} else if (priv->cur_seqid == QSPI_CMD_PP ||
-			   priv->cur_seqid == QSPI_CMD_WRAR) {
-			wr_sfaddr = swab32(txbuf) & OFFSET_BITS_MASK;
-		} else if ((priv->cur_seqid == QSPI_CMD_BRWR) ||
-			 (priv->cur_seqid == QSPI_CMD_WREAR)) {
-#ifdef CONFIG_SPI_FLASH_BAR
-			wr_sfaddr = 0;
+			break;
+#ifndef CONFIG_SPI_FLASH_BAR
+		case QSPI_CMD_WRITE_DISABLE:
+			qspi_send_cmd(priv, SEQID_WRITE_DISABLE);
+			priv->aai_mode = 0;
+			break;
 #endif
 		}
 	}
 
 	if (din) {
-		if (priv->cur_seqid == QSPI_CMD_FAST_READ) {
+		switch (priv->cur_cmd) {
+		case QSPI_CMD_FAST_READ:
 #ifdef CONFIG_SYS_FSL_QSPI_AHB
 			qspi_ahb_read(priv, din, bytes);
 #else
 			qspi_op_read(priv, din, bytes);
 #endif
-		} else if (priv->cur_seqid == QSPI_CMD_RDAR) {
+			break;
+		case QSPI_CMD_RDAR:
 			qspi_op_read(priv, din, bytes);
-		} else if (priv->cur_seqid == QSPI_CMD_RDID)
+			break;
+		case QSPI_CMD_RDID:
 			qspi_op_rdid(priv, din, bytes);
-		else if (priv->cur_seqid == QSPI_CMD_RDSR)
+			break;
+		case QSPI_CMD_RDSR:
 			qspi_op_rdsr(priv, din, bytes);
+			break;
 #ifdef CONFIG_SPI_FLASH_BAR
-		else if ((priv->cur_seqid == QSPI_CMD_BRRD) ||
-			 (priv->cur_seqid == QSPI_CMD_RDEAR)) {
+		case QSPI_CMD_BRRD:
+		case QSPI_CMD_RDEAR:
 			priv->sf_addr = 0;
 			qspi_op_rdbank(priv, din, bytes);
-		}
+			break;
 #endif
+		}
 	}
 
 #ifdef CONFIG_SYS_FSL_QSPI_AHB
-	if ((priv->cur_seqid == QSPI_CMD_SE) ||
-	    (priv->cur_seqid == QSPI_CMD_PP) ||
-	    (priv->cur_seqid == QSPI_CMD_BE_4K) ||
-	    (priv->cur_seqid == QSPI_CMD_WREAR) ||
-	    (priv->cur_seqid == QSPI_CMD_BRWR))
+	if ((priv->cur_cmd == QSPI_CMD_SE) ||
+	    (priv->cur_cmd == QSPI_CMD_PP) ||
+	    (priv->cur_cmd == QSPI_CMD_WRITE_DISABLE) ||
+	    (priv->cur_cmd == QSPI_CMD_BE_4K) ||
+	    (priv->cur_cmd == QSPI_CMD_WREAR) ||
+	    (priv->cur_cmd == QSPI_CMD_BRWR))
 		qspi_ahb_invalid(priv);
 #endif
 
@@ -886,6 +922,7 @@
 
 	regs = (struct fsl_qspi_regs *)spi_bases[bus];
 	qspi->priv.regs = regs;
+	qspi->priv.speed_hz = max_hz;
 	/*
 	 * According cs, use different amba_base to choose the
 	 * corresponding flash devices.
@@ -897,6 +934,7 @@
 
 	qspi->slave.max_write_size = TX_BUFFER_SIZE;
 
+	set_clk_qspi(qspi->priv.speed_hz);
 	mcr_val = qspi_read32(qspi->priv.flags, &regs->mcr);
 	qspi_write32(qspi->priv.flags, &regs->mcr,
 		     QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK |
@@ -966,6 +1004,7 @@
 {
 	/* Nothing to do */
 }
+
 #else
 static int fsl_qspi_child_pre_probe(struct udevice *dev)
 {
diff -Nru u-boot-2017.07/drivers/spi/fsl_qspi.h u-boot-imx6/drivers/spi/fsl_qspi.h
--- u-boot-2017.07/drivers/spi/fsl_qspi.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/spi/fsl_qspi.h	2018-08-27 21:35:37.554135465 +0300
@@ -113,18 +113,8 @@
 
 #define LUT_KEY_VALUE			0x5af05af0
 
-#define OPRND0_SHIFT			0
-#define OPRND0(x)			((x) << OPRND0_SHIFT)
-#define PAD0_SHIFT			8
-#define PAD0(x)				((x) << PAD0_SHIFT)
-#define INSTR0_SHIFT			10
-#define INSTR0(x)			((x) << INSTR0_SHIFT)
-#define OPRND1_SHIFT			16
-#define OPRND1(x)			((x) << OPRND1_SHIFT)
-#define PAD1_SHIFT			24
-#define PAD1(x)				((x) << PAD1_SHIFT)
-#define INSTR1_SHIFT			26
-#define INSTR1(x)			((x) << INSTR1_SHIFT)
+#define LUT0(inst, op, pad)		(((inst) << 10) | (op) | ((pad) << 8))
+#define LUT1(inst, op, pad)		(LUT0(inst, op, pad) << 16)
 
 #define LUT_CMD				1
 #define LUT_ADDR			2
diff -Nru u-boot-2017.07/drivers/usb/gadget/g_dnl.c u-boot-imx6/drivers/usb/gadget/g_dnl.c
--- u-boot-2017.07/drivers/usb/gadget/g_dnl.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/usb/gadget/g_dnl.c	2018-08-27 21:35:37.570802053 +0300
@@ -19,6 +19,8 @@
 #include <dfu.h>
 #include <thor.h>
 
+#include <env_callback.h>
+
 #include "gadget_chips.h"
 #include "composite.c"
 
@@ -202,6 +204,19 @@
 	return g_dnl_get_board_bcd_device_number(gcnum);
 }
 
+/**
+ * Update internal serial number variable when the "serial#" env var changes.
+ *
+ * Handle all cases, even when flags == H_PROGRAMMATIC or op == env_op_delete.
+ */
+static int on_serialno(const char *name, const char *value, enum env_op op,
+		int flags)
+{
+	g_dnl_set_serialnumber((char *)value);
+	return 0;
+}
+U_BOOT_ENV_CALLBACK(serialno, on_serialno);
+
 static int g_dnl_bind(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget *gadget = cdev->gadget;
diff -Nru u-boot-2017.07/drivers/video/cfb_console.c u-boot-imx6/drivers/video/cfb_console.c
--- u-boot-2017.07/drivers/video/cfb_console.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/cfb_console.c	2018-08-27 21:35:37.674134894 +0300
@@ -1696,11 +1696,12 @@
 }
 #endif
 
-
-#ifdef CONFIG_VIDEO_LOGO
+#if defined(CONFIG_VIDEO_LOGO) || defined(CONFIG_SPLASH_SCREEN)
 static int video_logo_xpos;
 static int video_logo_ypos;
+#endif
 
+#ifdef CONFIG_VIDEO_LOGO
 static void plot_logo_or_black(void *screen, int x, int y, int black);
 
 static void logo_plot(void *screen, int x, int y)
@@ -1855,13 +1856,19 @@
 #endif
 }
 
+#endif
+
+#if defined(CONFIG_VIDEO_LOGO) || defined(CONFIG_SPLASH_SCREEN)
 static void *video_logo(void)
 {
+#ifdef CONFIG_VIDEO_LOGO
 	char info[128];
+	__maybe_unused int len, space;
+#endif
 	__maybe_unused int y_off = 0;
 	__maybe_unused ulong addr;
 	__maybe_unused char *s;
-	__maybe_unused int len, ret, space;
+	__maybe_unused int ret;
 
 	splash_get_pos(&video_logo_xpos, &video_logo_ypos);
 
@@ -1882,6 +1889,7 @@
 	}
 #endif /* CONFIG_SPLASH_SCREEN */
 
+#ifdef CONFIG_VIDEO_LOGO
 	logo_plot(video_fb_address, video_logo_xpos, video_logo_ypos);
 
 #ifdef CONFIG_SPLASH_SCREEN_ALIGN
@@ -1907,6 +1915,7 @@
 	if (board_cfb_skip())
 		return 0;
 
+#ifndef CONFIG_VIDEO_SKIP_VERSION
 	sprintf(info, " %s", version_string);
 
 #ifndef CONFIG_HIDE_LOGO_VERSION
@@ -1922,6 +1931,7 @@
 		y_off = 1;
 	} else
 		video_drawstring(VIDEO_INFO_X, VIDEO_INFO_Y, (uchar *) info);
+#endif
 
 #ifdef CONFIG_CONSOLE_EXTRA_INFO
 	{
@@ -1961,6 +1971,7 @@
 #endif
 #endif
 
+#endif
 	return (video_fb_address + video_logo_height * VIDEO_LINE_LEN);
 }
 #endif
@@ -2010,7 +2021,6 @@
 {
 	unsigned char color8;
 
-	pGD = video_hw_init();
 	if (pGD == NULL)
 		return -1;
 
@@ -2091,20 +2101,26 @@
 	}
 	eorx = fgx ^ bgx;
 
+	/* Initialize the console */
+	old_col = console_col = 0;
+	old_row = console_row = 0;
 	video_clear();
 
-#ifdef CONFIG_VIDEO_LOGO
+#ifndef CONFIG_VIDEO_LOGO
+	if (!board_cfb_skip()){
+		video_console_address = video_fb_address;
+#ifndef CONFIG_VIDEO_SKIP_VERSION
+		video_drawstring(VIDEO_FONT_WIDTH, 0, (uchar *)version_string);
+		old_row = console_row = 1;
+#endif
+	}
+#endif
+#if defined(CONFIG_VIDEO_LOGO) || defined(CONFIG_SPLASH_SCREEN)
 	/* Plot the logo and get start point of console */
 	debug("Video: Drawing the logo ...\n");
 	video_console_address = video_logo();
-#else
-	video_console_address = video_fb_address;
 #endif
 
-	/* Initialize the console */
-	console_col = 0;
-	console_row = 0;
-
 	if (cfb_do_flush_cache)
 		flush_cache(VIDEO_FB_ADRS, VIDEO_SIZE);
 
@@ -2132,7 +2148,7 @@
 		return 0;
 
 	/* Init video chip - returns with framebuffer cleared */
-	if (cfg_video_init() == -1)
+	if (!drv_video_init2(video_hw_init()))
 		return 0;
 
 	if (board_cfb_skip())
@@ -2176,6 +2192,14 @@
 	return 1;
 }
 
+int drv_video_init2(struct graphic_device *fb)
+{
+	pGD = fb;
+	if (cfg_video_init() == -1)
+		return 0;
+	return 1;
+}
+
 void video_position_cursor(unsigned col, unsigned row)
 {
 	console_col = min(col, CONSOLE_COLS - 1);
diff -Nru u-boot-2017.07/drivers/video/ipu_common.c u-boot-imx6/drivers/video/ipu_common.c
--- u-boot-2017.07/drivers/video/ipu_common.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/ipu_common.c	2018-08-27 21:35:37.694134800 +0300
@@ -453,19 +453,14 @@
 {
 	unsigned long ipu_base;
 #if defined CONFIG_MX51
-	u32 temp;
-
+	/* Errata ENGcm08316 */
 	u32 *reg_hsc_mcd = (u32 *)MIPI_HSC_BASE_ADDR;
+	u32 *reg_hsc_mccmc = (u32 *)(MIPI_HSC_BASE_ADDR + 0x0d8);
 	u32 *reg_hsc_mxt_conf = (u32 *)(MIPI_HSC_BASE_ADDR + 0x800);
 
-	 __raw_writel(0xF00, reg_hsc_mcd);
-
-	/* CSI mode reserved*/
-	temp = __raw_readl(reg_hsc_mxt_conf);
-	 __raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
-
-	temp = __raw_readl(reg_hsc_mxt_conf);
-	__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
+	__raw_writel(0xF00, reg_hsc_mcd);
+	__raw_writel(0x00c, reg_hsc_mccmc);
+	__raw_writel(0xf003008b, reg_hsc_mxt_conf);
 #endif
 
 	ipu_base = IPU_CTRL_BASE_ADDR;
@@ -492,8 +487,6 @@
 	while (__raw_readl(IPU_MEM_RST) & 0x80000000)
 		;
 
-	ipu_init_dc_mappings();
-
 	__raw_writel(0, IPU_INT_CTRL(5));
 	__raw_writel(0, IPU_INT_CTRL(6));
 	__raw_writel(0, IPU_INT_CTRL(9));
@@ -588,7 +581,8 @@
 
 		g_dc_di_assignment[1] = params->mem_dc_sync.di;
 		ipu_dc_init(1, params->mem_dc_sync.di,
-			     params->mem_dc_sync.interlaced);
+			     params->mem_dc_sync.interlaced,
+			     params->mem_dc_sync.out_pixel_fmt);
 		ipu_di_use_count[params->mem_dc_sync.di]++;
 		ipu_dc_use_count++;
 		ipu_dmfc_use_count++;
@@ -603,7 +597,8 @@
 		ipu_dp_init(channel, params->mem_dp_bg_sync.in_pixel_fmt,
 			     params->mem_dp_bg_sync.out_pixel_fmt);
 		ipu_dc_init(5, params->mem_dp_bg_sync.di,
-			     params->mem_dp_bg_sync.interlaced);
+			     params->mem_dp_bg_sync.interlaced,
+			     params->mem_dp_bg_sync.out_pixel_fmt);
 		ipu_di_use_count[params->mem_dp_bg_sync.di]++;
 		ipu_dc_use_count++;
 		ipu_dp_use_count++;
@@ -807,6 +802,8 @@
 	struct ipu_ch_param params;
 
 	memset(&params, 0, sizeof(params));
+	debug("%s:pixel_fmt=%x, width=%d, height=%d, stride=%d, u=%d, v=%d, uv_stride=%d\n",
+			__func__, pixel_fmt, width, height, stride, u, v, uv_stride);
 
 	ipu_ch_param_set_field(&params, 0, 125, 13, width - 1);
 
@@ -884,7 +881,7 @@
 	case IPU_PIX_FMT_YUYV:
 		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
 		ipu_ch_param_set_field(&params, 1, 85, 4, 0x8);	/* pix format */
-		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 15);	/* burst size */
 		break;
 	case IPU_PIX_FMT_YUV420P2:
 	case IPU_PIX_FMT_YUV420P:
@@ -1001,6 +998,7 @@
 	uint32_t reg;
 	uint32_t dma_chan;
 
+	debug("%s: chan=0x%08x, pixel_fmt=%x\n", __func__, channel, pixel_fmt);
 	dma_chan = channel_2_dma(channel, type);
 	if (!idma_is_valid(dma_chan))
 		return -EINVAL;
diff -Nru u-boot-2017.07/drivers/video/ipu_disp.c u-boot-imx6/drivers/video/ipu_disp.c
--- u-boot-2017.07/drivers/video/ipu_disp.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/ipu_disp.c	2018-08-27 21:35:37.697468117 +0300
@@ -43,6 +43,19 @@
 #define DC_DISP_ID_SERIAL	2
 #define DC_DISP_ID_ASYNC	3
 
+/* DC microcode address */
+#define DC_MCODE_DI0			0	/* 0 - 5 */
+#define MCI_I			0
+#define MCI_NL			1
+#define MCI_EOL			2
+#define MCI_NEW_DATA		3
+#define MCI_EVEN_UGDE		4
+#define MCI_ODD_UGDE		5
+
+#define DC_MCODE_DI1			6	/* 6-11 */
+
+#define DC_MCODE_ASYNC_NEW_DATA		0x64
+
 int dmfc_type_setup;
 static int dmfc_size_28, dmfc_size_29, dmfc_size_24, dmfc_size_27, dmfc_size_23;
 int g_di1_tvout;
@@ -55,6 +68,11 @@
 extern unsigned char g_ipu_clk_enabled;
 extern unsigned char g_dc_di_assignment[];
 
+void ipu_dmfc_uninit(void)
+{
+	dmfc_type_setup = 0;
+}
+
 void ipu_dmfc_init(int dmfc_type, int first)
 {
 	u32 dmfc_wr_chan, dmfc_dp_chan;
@@ -235,29 +253,6 @@
 	__raw_writel(reg, DI_STP_REP(di, wave_gen));
 }
 
-static void ipu_dc_map_config(int map, int byte_num, int offset, int mask)
-{
-	int ptr = map * 3 + byte_num;
-	u32 reg;
-
-	reg = __raw_readl(DC_MAP_CONF_VAL(ptr));
-	reg &= ~(0xFFFF << (16 * (ptr & 0x1)));
-	reg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));
-	__raw_writel(reg, DC_MAP_CONF_VAL(ptr));
-
-	reg = __raw_readl(DC_MAP_CONF_PTR(map));
-	reg &= ~(0x1F << ((16 * (map & 0x1)) + (5 * byte_num)));
-	reg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));
-	__raw_writel(reg, DC_MAP_CONF_PTR(map));
-}
-
-static void ipu_dc_map_clear(int map)
-{
-	u32 reg = __raw_readl(DC_MAP_CONF_PTR(map));
-	__raw_writel(reg & ~(0xFFFF << (16 * (map & 0x1))),
-		     DC_MAP_CONF_PTR(map));
-}
-
 static void ipu_dc_write_tmpl(int word, u32 opcode, u32 operand, int map,
 			       int wave, int glue, int sync)
 {
@@ -280,11 +275,32 @@
 static void ipu_dc_link_event(int chan, int event, int addr, int priority)
 {
 	u32 reg;
-
-	reg = __raw_readl(DC_RL_CH(chan, event));
-	reg &= ~(0xFFFF << (16 * (event & 0x1)));
-	reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
-	__raw_writel(reg, DC_RL_CH(chan, event));
+	u32 address_shift;
+	if (event < DC_EVEN_UGDE0) {
+		reg = __raw_readl(DC_RL_CH(chan, event));
+		reg &= ~(0xFFFF << (16 * (event & 0x1)));
+		reg |= ((addr << 8) | priority) << (16 * (event & 0x1));
+		__raw_writel(reg, DC_RL_CH(chan, event));
+	} else {
+		reg = __raw_readl(DC_UGDE_0((event - DC_EVEN_UGDE0) / 2));
+		if ((event - DC_EVEN_UGDE0) & 0x1) {
+			/* DC_ODD_UGDEx */
+			reg &= ~(0x2FF << 16);
+			reg |= (addr << 16);
+			reg |= priority ? (2 << 24) : 0x0;
+		} else {
+			/* DC_EVEN_UGDEx */
+			reg &= ~0xFC00FFFF;
+			if (priority)
+				chan = (chan >> 1) +
+					((((chan & 0x1) + ((chan & 0x2) >> 1))) | (chan >> 3));
+			else
+				chan = 0x7;
+			address_shift = ((event - DC_EVEN_UGDE0) >> 1) ? 7 : 8;
+			reg |= (addr << address_shift) | (priority << 3) | chan;
+		}
+		__raw_writel(reg, DC_UGDE_0((event - DC_EVEN_UGDE0) / 2));
+	}
 }
 
 /* Y = R *  1.200 + G *  2.343 + B *  .453 + 0.250;
@@ -422,7 +438,10 @@
 	int dp;
 	int partial = 0;
 	uint32_t reg;
+	enum csc_type_t csc_type;
+	struct dp_csc_param_t param;
 
+	debug("%s: chan=0x%08x, infmt %x, outfmt=%x\n", __func__, channel, in_pixel_fmt, out_pixel_fmt);
 	if (channel == MEM_FG_SYNC) {
 		dp = DP_SYNC;
 		partial = 1;
@@ -439,31 +458,14 @@
 	in_fmt = format_to_colorspace(in_pixel_fmt);
 	out_fmt = format_to_colorspace(out_pixel_fmt);
 
-	if (partial) {
-		if (in_fmt == RGB) {
-			if (out_fmt == RGB)
-				fg_csc_type = RGB2RGB;
-			else
-				fg_csc_type = RGB2YUV;
-		} else {
-			if (out_fmt == RGB)
-				fg_csc_type = YUV2RGB;
-			else
-				fg_csc_type = YUV2YUV;
-		}
-	} else {
-		if (in_fmt == RGB) {
-			if (out_fmt == RGB)
-				bg_csc_type = RGB2RGB;
-			else
-				bg_csc_type = RGB2YUV;
-		} else {
-			if (out_fmt == RGB)
-				bg_csc_type = YUV2RGB;
-			else
-				bg_csc_type = YUV2YUV;
-		}
-	}
+	debug("%s: %s to %s\n", __func__, (in_fmt == RGB) ? "rgb" : "yuv", (out_fmt == RGB) ? "rgb" : "yuv");
+	csc_type = (in_fmt == RGB) ? ((out_fmt == RGB) ? RGB2RGB : RGB2YUV) :
+				     ((out_fmt == RGB) ? YUV2RGB : YUV2YUV);
+	if (partial)
+		fg_csc_type = csc_type;
+	else
+		bg_csc_type = csc_type;
+
 
 	/* Transform color key from rgb to yuv if CSC is enabled */
 	reg = __raw_readl(DP_COM_CONF());
@@ -496,6 +498,9 @@
 		debug("_ipu_dp_init color key change to yuv fmt 0x%x!\n",
 			color_key);
 	}
+	param = dp_csc_array[bg_csc_type][fg_csc_type];
+	if ((fg_csc_type == RGB2YUV) || (bg_csc_type == RGB2YUV))
+		param.mode |= (1 << 11);  /* Y range 16-235, U/V range 16-240. */
 
 	ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], 1);
 
@@ -528,26 +533,29 @@
 	ipu_dp_csc_setup(dp, dp_csc_array[bg_csc_type][fg_csc_type], 0);
 }
 
-void ipu_dc_init(int dc_chan, int di, unsigned char interlaced)
+void ipu_dc_init(int dc_chan, int di, unsigned char interlaced, uint32_t pixel_fmt)
 {
 	u32 reg = 0;
+	int mc = di ? DC_MCODE_DI1 : DC_MCODE_DI0;
 
+	debug("%s: fmt %x, chan=%d, di=%d, interlaced=%d\n", __func__, pixel_fmt, dc_chan, di, interlaced);
 	if ((dc_chan == 1) || (dc_chan == 5)) {
 		if (interlaced) {
 			ipu_dc_link_event(dc_chan, DC_EVT_NL, 0, 3);
 			ipu_dc_link_event(dc_chan, DC_EVT_EOL, 0, 2);
 			ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, 0, 1);
 		} else {
-			if (di) {
-				ipu_dc_link_event(dc_chan, DC_EVT_NL, 2, 3);
-				ipu_dc_link_event(dc_chan, DC_EVT_EOL, 3, 2);
-				ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA,
-					4, 1);
-			} else {
-				ipu_dc_link_event(dc_chan, DC_EVT_NL, 5, 3);
-				ipu_dc_link_event(dc_chan, DC_EVT_EOL, 6, 2);
-				ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA,
-					7, 1);
+			int evt = di ? DC_EVEN_UGDE1 : DC_EVEN_UGDE0;
+
+			ipu_dc_link_event(dc_chan, DC_EVT_NL, mc + MCI_NL, 3);
+			ipu_dc_link_event(dc_chan, DC_EVT_EOL, mc + MCI_EOL, 2);
+			ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA, mc + MCI_NEW_DATA, 1);
+
+			if ((pixel_fmt == IPU_PIX_FMT_YUYV) ||
+			    (pixel_fmt == IPU_PIX_FMT_UYVY)) {
+				printf("%s: link %d %d\n", __func__, evt, mc);
+				ipu_dc_link_event(dc_chan, evt, mc + MCI_EVEN_UGDE, 5);
+				ipu_dc_link_event(dc_chan, evt + 1, mc + MCI_ODD_UGDE, 5);
 			}
 		}
 		ipu_dc_link_event(dc_chan, DC_EVT_NF, 0, 0);
@@ -564,8 +572,8 @@
 			reg |= DC_WR_CH_CONF_FIELD_MODE;
 	} else if ((dc_chan == 8) || (dc_chan == 9)) {
 		/* async channels */
-		ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, 0x64, 1);
-		ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, 0x64, 1);
+		ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_0, DC_MCODE_ASYNC_NEW_DATA, 1);
+		ipu_dc_link_event(dc_chan, DC_EVT_NEW_DATA_W_1, DC_MCODE_ASYNC_NEW_DATA, 1);
 
 		reg = 0x3;
 		reg |= DC_DISP_ID_SERIAL << DC_WR_CH_CONF_PROG_DISP_ID_OFFSET;
@@ -716,6 +724,11 @@
 		/* Make sure that we leave at the irq starting edge */
 		__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
 		do {
+			udelay(2000);
+			if (--timeout <= 0) {
+				printf("%s: timeout\n", __func__);
+				break;
+			}
 			reg = __raw_readl(IPUIRQ_2_STATREG(irq));
 		} while (!(reg & IPUIRQ_2_MASK(irq)));
 
@@ -736,56 +749,221 @@
 	}
 }
 
-void ipu_init_dc_mappings(void)
+struct offset_mask {
+	u8 offset;
+	u8 mask;
+};
+
+struct f_mapping {
+	struct offset_mask om[3];
+};
+
+enum {
+	I_IPU_PIX_FMT_RGB24,
+	I_IPU_PIX_FMT_BGR24,
+	I_IPU_PIX_FMT_GBR24,
+	I_IPU_PIX_FMT_RGB666,
+	I_IPU_PIX_FMT_RGB565,
+	I_IPU_PIX_FMT_LVDS666,
+	I_IPU_PIX_FMT_YUV444,
+
+	I_IPU_PIX_FMT_2CYCLE_START,
+	I_IPU_PIX_FMT_VYUYa_1 = I_IPU_PIX_FMT_2CYCLE_START,
+	I_IPU_PIX_FMT_VYUYa_2,
+/* 16bit width for BT1120 */
+	I_IPU_PIX_FMT_BT1120_1,
+	I_IPU_PIX_FMT_BT1120_2,
+
+	I_IPU_PIX_FMT_VYUY_1,
+	I_IPU_PIX_FMT_VYUY_2,
+	I_IPU_PIX_FMT_UYVY_1,
+	I_IPU_PIX_FMT_UYVY_2,
+	I_IPU_PIX_FMT_YUYV_1,
+	I_IPU_PIX_FMT_YUYV_2,
+	I_IPU_PIX_FMT_YVYU_1,
+	I_IPU_PIX_FMT_YVYU_2,
+
+/* 8bit width for BT656 */
+	I_IPU_PIX_FMT_3CYCLE_START,
+	I_IPU_PIX_FMT_BT656_1 = I_IPU_PIX_FMT_3CYCLE_START,
+	I_IPU_PIX_FMT_BT656_2,
+	I_IPU_PIX_FMT_BT656_3,
+};
+
+static struct f_mapping fmt_mappings[] = {
+/* RGB formats are named from High bits to low bits */
+/* YUV formats are named from low bits to high bits */
+			/* B		G		R */
+[I_IPU_PIX_FMT_RGB24] = {{{7, 0xFF}, {15, 0xFF}, {23, 0xFF}}},
+[I_IPU_PIX_FMT_BGR24] = {{{23, 0xFF}, {15, 0xFF}, {7, 0xFF}}},
+[I_IPU_PIX_FMT_GBR24] = {{{15, 0xFF}, {23, 0xFF}, {7, 0xFF}}},
+[I_IPU_PIX_FMT_RGB666] = {{{5, 0xFC}, {11, 0xFC}, {17, 0xFC}}},
+[I_IPU_PIX_FMT_RGB565] = {{{4, 0xF8}, {10, 0xFC}, {15, 0xF8}}},
+[I_IPU_PIX_FMT_LVDS666] = {{{5, 0xFC}, {13, 0xFC}, {21, 0xFC}}},
+
+			/* V		U		Y */
+[I_IPU_PIX_FMT_YUV444] = {{{23, 0xFF}, {15, 0xFF}, {7, 0xFF}}},
+#define BT656_IF_DI_MSB	23
+[I_IPU_PIX_FMT_VYUYa_1] = {{{BT656_IF_DI_MSB - 8, 0xFF}, {0, 0x0}, {BT656_IF_DI_MSB, 0xFF}}},
+[I_IPU_PIX_FMT_VYUYa_2] = {{{0, 0x0}, {BT656_IF_DI_MSB - 8, 0xFF}, {BT656_IF_DI_MSB, 0xFF}}},
+/* 16bit width for BT1120 */
+[I_IPU_PIX_FMT_BT1120_1] = {{{0, 0x0}, {BT656_IF_DI_MSB - 8, 0xFF}, {BT656_IF_DI_MSB, 0xFF}}},
+[I_IPU_PIX_FMT_BT1120_2] = {{{BT656_IF_DI_MSB - 8, 0xFF}, {0, 0x0}, {BT656_IF_DI_MSB, 0xFF}}},
+
+			/* V		U		Y */
+[I_IPU_PIX_FMT_VYUY_1] = {{{7, 0xFF}, {0, 0x0}, {15, 0xFF}}},
+[I_IPU_PIX_FMT_VYUY_2] = {{{0, 0x0}, {7, 0xFF}, {15, 0xFF}}},
+
+[I_IPU_PIX_FMT_UYVY_1] = {{{0, 0x0}, {7, 0xFF}, {15, 0xFF}}},
+[I_IPU_PIX_FMT_UYVY_2] = {{{7, 0xFF}, {0, 0x0}, {15, 0xFF}}},
+
+[I_IPU_PIX_FMT_YUYV_1] = {{{0, 0x0}, {15, 0xFF}, {7, 0xFF}}},
+[I_IPU_PIX_FMT_YUYV_2] = {{{15, 0xFF}, {0, 0x0}, {7, 0xFF}}},
+
+[I_IPU_PIX_FMT_YVYU_1] = {{{15, 0xFF}, {0, 0x0}, {7, 0xFF}}},
+[I_IPU_PIX_FMT_YVYU_2] = {{{0, 0x0}, {15, 0xFF}, {7, 0xFF}}},
+
+/* 8bit width for BT656 */
+[I_IPU_PIX_FMT_BT656_1] = {{{0, 0x0}, {BT656_IF_DI_MSB, 0xFF}, {0, 0x0}}},	/* U */
+[I_IPU_PIX_FMT_BT656_2] = {{{0, 0x0}, {0, 0x0}, {BT656_IF_DI_MSB, 0xFF}}},	/* Y */
+[I_IPU_PIX_FMT_BT656_3] = {{{BT656_IF_DI_MSB, 0xFF}, {0, 0x0}, {0, 0x0}}},	/* V */
+};
+
+#define DC_MAPPING_VAL_MAX	23
+static unsigned long offset_mask_bitmap;
+
+#define DC_MAPPING_PTR_MAX	29
+static unsigned long mapping_bitmap;
+
+static void set_bit_(int nr, volatile void *addr)
 {
-	/* IPU_PIX_FMT_RGB24 */
-	ipu_dc_map_clear(0);
-	ipu_dc_map_config(0, 0, 7, 0xFF);
-	ipu_dc_map_config(0, 1, 15, 0xFF);
-	ipu_dc_map_config(0, 2, 23, 0xFF);
-
-	/* IPU_PIX_FMT_RGB666 */
-	ipu_dc_map_clear(1);
-	ipu_dc_map_config(1, 0, 5, 0xFC);
-	ipu_dc_map_config(1, 1, 11, 0xFC);
-	ipu_dc_map_config(1, 2, 17, 0xFC);
-
-	/* IPU_PIX_FMT_YUV444 */
-	ipu_dc_map_clear(2);
-	ipu_dc_map_config(2, 0, 15, 0xFF);
-	ipu_dc_map_config(2, 1, 23, 0xFF);
-	ipu_dc_map_config(2, 2, 7, 0xFF);
-
-	/* IPU_PIX_FMT_RGB565 */
-	ipu_dc_map_clear(3);
-	ipu_dc_map_config(3, 0, 4, 0xF8);
-	ipu_dc_map_config(3, 1, 10, 0xFC);
-	ipu_dc_map_config(3, 2, 15, 0xF8);
-
-	/* IPU_PIX_FMT_LVDS666 */
-	ipu_dc_map_clear(4);
-	ipu_dc_map_config(4, 0, 5, 0xFC);
-	ipu_dc_map_config(4, 1, 13, 0xFC);
-	ipu_dc_map_config(4, 2, 21, 0xFC);
+	int     mask;
+	unsigned int *a = (unsigned int *)addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
 }
 
-static int ipu_pixfmt_to_map(uint32_t fmt)
+static int find_field(u32 val, u32 *reg_base, unsigned long* bitmap, int max)
+{
+	int i = 0;
+	u32 reg;
+
+	while (i <= max) {
+		if (!test_bit(i, bitmap))
+			break;
+		reg = __raw_readl(&reg_base[i >> 1]);
+		if (val == (reg & 0xffff))
+			return i;
+		i++;
+		if (!test_bit(i, bitmap))
+			break;
+		if (val == (reg >> 16))
+			return i;
+		i++;
+	}
+	i = ffz(*bitmap);
+
+	if (i > max) {
+		printf("out of mappings, max=%d\n", max);
+		return -EINVAL;
+	}
+
+	reg = __raw_readl(&reg_base[i >> 1]);
+	reg &= ~(0xFFFF << (16 * (i & 0x1)));
+	reg |= val << (16 * (i & 0x1));
+	__raw_writel(reg, &reg_base[i >> 1]);
+	set_bit_(i, bitmap);
+	debug("%s: [%d] = 0x%x max=%d\n", __func__, i, val, max);
+	return i;
+}
+
+static int find_om(struct offset_mask *om)
+{
+	return find_field((om->offset << 8) | om->mask, DC_MAP_CONF_VAL(0), &offset_mask_bitmap, DC_MAPPING_VAL_MAX);
+}
+
+static int find_mptr(u32 val)
+{
+	return find_field(val, DC_MAP_CONF_PTR(0), &mapping_bitmap, DC_MAPPING_PTR_MAX);
+}
+
+int do_mapping(int i)
+{
+	struct f_mapping *fm = &fmt_mappings[i];
+	u32 t = 0;
+
+	for (i = 0; i < 3; i++) {
+		int m = find_om(&fm->om[i]);
+
+		if (m < 0)
+			return m;
+		t = (t >> 5) | (m << 10);
+	}
+	return find_mptr(t);
+}
+
+static int pixfmt_to_i(uint32_t fmt)
 {
 	switch (fmt) {
 	case IPU_PIX_FMT_GENERIC:
 	case IPU_PIX_FMT_RGB24:
-		return 0;
+		return  I_IPU_PIX_FMT_RGB24;
 	case IPU_PIX_FMT_RGB666:
-		return 1;
+		return I_IPU_PIX_FMT_RGB666;
 	case IPU_PIX_FMT_YUV444:
-		return 2;
+		return I_IPU_PIX_FMT_YUV444;
 	case IPU_PIX_FMT_RGB565:
-		return 3;
+		return I_IPU_PIX_FMT_RGB565;
 	case IPU_PIX_FMT_LVDS666:
-		return 4;
+		return I_IPU_PIX_FMT_LVDS666;
+//	case IPU_PIX_FMT_VYUY:
+//		return I_IPU_PIX_FMT_VYUY_1;
+//	case IPU_PIX_FMT_BT1120:
+//		return I_IPU_PIX_FMT_BT1120_1;
+//	case IPU_PIX_FMT_BT656:
+//		return I_IPU_PIX_FMT_BT656_1;
+	case IPU_PIX_FMT_UYVY:
+		return I_IPU_PIX_FMT_UYVY_1;
+	case IPU_PIX_FMT_YUYV:
+		return I_IPU_PIX_FMT_YUYV_1;
+//	case IPU_PIX_FMT_YVYU:
+//		return I_IPU_PIX_FMT_YVYU_1;
+//	case IPU_PIX_FMT_GBR24:
+//	case IPU_PIX_FMT_VYU444:
+//		return I_IPU_PIX_FMT_GBR24;
+	case IPU_PIX_FMT_BGR24:
+		return I_IPU_PIX_FMT_BGR24;
 	}
+	return -EINVAL;
+}
 
-	return -1;
+static int ipu_pixfmt_to_map(uint32_t fmt, int *mappings)
+{
+	int i = pixfmt_to_i(fmt);
+	int ret;
+
+	if (i < 0)
+		return i;
+
+	ret = do_mapping(i++);
+	if (ret < 0)
+		return ret;
+	*mappings++ = ret;
+	if (i > I_IPU_PIX_FMT_2CYCLE_START) {
+		ret = do_mapping(i++);
+		if (ret < 0)
+			return ret;
+		*mappings++ = ret;
+		if (i > I_IPU_PIX_FMT_3CYCLE_START) {
+			ret = do_mapping(i++);
+			if (ret < 0)
+				return ret;
+			*mappings++ = ret;
+		}
+	}
+	return 0;
 }
 
 /*
@@ -837,7 +1015,8 @@
 	uint32_t di_gen, vsync_cnt;
 	uint32_t div, rounded_pixel_clk;
 	uint32_t h_total, v_total;
-	int map;
+	int map[3] = {0, 0, 0};
+	int ret;
 	struct clk *di_parent;
 
 	debug("panel size = %d x %d\n", width, height);
@@ -898,10 +1077,10 @@
 	ipu_di_data_wave_config(disp, SYNC_WAVE, div - 1, div - 1);
 	ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
 
-	map = ipu_pixfmt_to_map(pixel_fmt);
-	if (map < 0) {
+	ret = ipu_pixfmt_to_map(pixel_fmt, map);
+	if (ret < 0) {
 		debug("IPU_DISP: No MAP\n");
-		return -EINVAL;
+		return ret;
 	}
 
 	di_gen = __raw_readl(DI_GENERAL(disp));
@@ -1073,6 +1252,8 @@
 		di_gen |= DI_GEN_POLARITY_5;
 		di_gen |= DI_GEN_POLARITY_8;
 	} else {
+		int mc = disp ? DC_MCODE_DI1 : DC_MCODE_DI0;
+
 		/* Setup internal HSYNC waveform */
 		ipu_di_sync_config(disp, 1, h_total - 1, DI_SYNC_CLK,
 				0, DI_SYNC_NONE, 0, DI_SYNC_NONE,
@@ -1120,15 +1301,17 @@
 		__raw_writel(0, DI_STP_REP9(disp));
 
 		/* Init template microcode */
-		if (disp) {
-		   ipu_dc_write_tmpl(2, WROD(0), 0, map, SYNC_WAVE, 8, 5);
-		   ipu_dc_write_tmpl(3, WROD(0), 0, map, SYNC_WAVE, 4, 5);
-		   ipu_dc_write_tmpl(4, WROD(0), 0, map, SYNC_WAVE, 0, 5);
-		} else {
-		   ipu_dc_write_tmpl(5, WROD(0), 0, map, SYNC_WAVE, 8, 5);
-		   ipu_dc_write_tmpl(6, WROD(0), 0, map, SYNC_WAVE, 4, 5);
-		   ipu_dc_write_tmpl(7, WROD(0), 0, map, SYNC_WAVE, 0, 5);
+		if ((pixel_fmt == IPU_PIX_FMT_YUYV) ||
+		    (pixel_fmt == IPU_PIX_FMT_UYVY)) {
+			printf("%s: map %d %d\n", __func__, map[0], map[1]);
+			ipu_dc_write_tmpl(mc + MCI_EVEN_UGDE, WROD(0), 0, map[0], SYNC_WAVE, 0, 5);
+			ipu_dc_write_tmpl(mc + MCI_ODD_UGDE, WROD(0), 0, map[1], SYNC_WAVE, 0, 5);
+			/* configure user events according to DISP NUM */
+			__raw_writel((width - 1), DC_UGDE_3(disp));
 		}
+		ipu_dc_write_tmpl(mc + MCI_NL, WROD(0), 0, map[0], SYNC_WAVE, 8, 5);
+		ipu_dc_write_tmpl(mc + MCI_EOL, WROD(0), 0, map[0], SYNC_WAVE, 4, 5);
+		ipu_dc_write_tmpl(mc + MCI_NEW_DATA, WROD(0), 0, map[0], SYNC_WAVE, 0, 5);
 
 		if (sig.Hsync_pol)
 			di_gen |= DI_GEN_POLARITY_2;
diff -Nru u-boot-2017.07/drivers/video/ipu.h u-boot-imx6/drivers/video/ipu.h
--- u-boot-2017.07/drivers/video/ipu.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/ipu.h	2018-08-27 21:35:37.694134800 +0300
@@ -152,6 +152,8 @@
 	struct {
 		uint32_t di;
 		unsigned char interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
 	} mem_dc_sync;
 	struct {
 		uint32_t temp;
@@ -255,9 +257,8 @@
 int ipu_probe(void);
 
 void ipu_dmfc_init(int dmfc_type, int first);
-void ipu_init_dc_mappings(void);
 void ipu_dmfc_set_wait4eot(int dma_chan, int width);
-void ipu_dc_init(int dc_chan, int di, unsigned char interlaced);
+void ipu_dc_init(int dc_chan, int di, unsigned char interlaced, uint32_t pixel_fmt);
 void ipu_dc_uninit(int dc_chan);
 void ipu_dp_dc_enable(ipu_channel_t channel);
 int ipu_dp_init(ipu_channel_t channel, uint32_t in_pixel_fmt,
diff -Nru u-boot-2017.07/drivers/video/ipu_regs.h u-boot-imx6/drivers/video/ipu_regs.h
--- u-boot-2017.07/drivers/video/ipu_regs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/ipu_regs.h	2018-08-27 21:35:37.697468117 +0300
@@ -74,6 +74,14 @@
 #define DC_EVT_NEW_CHAN_R_1	9
 #define DC_EVT_NEW_DATA_R_0	10
 #define DC_EVT_NEW_DATA_R_1	11
+#define DC_EVEN_UGDE0 		12
+#define DC_ODD_UGDE0 		13
+#define DC_EVEN_UGDE1 		14
+#define DC_ODD_UGDE1 		15
+#define DC_EVEN_UGDE2 		16
+#define DC_ODD_UGDE2 		17
+#define DC_EVEN_UGDE3 		18
+#define DC_ODD_UGDE3 		19
 
 /* Software reset for ipu */
 #define SW_IPU_RST	8
@@ -276,7 +284,7 @@
 	u32 di1_conf[2];
 	u32 dc_map_ptr[15];
 	u32 dc_map_val[12];
-	u32 udge[16];
+	u32 ugde[16];
 	u32 lla[2];
 	u32 r_lla[2];
 	u32 wr_ch_addr_5_alt;
@@ -393,6 +401,10 @@
 #define DC_GEN			(&DC_REG->gen)
 #define DC_DISP_CONF2(disp)	(&DC_REG->disp_conf2[disp])
 #define DC_STAT			(&DC_REG->stat)
+#define DC_UGDE_0(evt)		(&DC_REG->ugde[0 + (4 * (evt))])
+#define DC_UGDE_1(evt)		(&DC_REG->ugde[1 + (4 * (evt))])
+#define DC_UGDE_2(evt)		(&DC_REG->ugde[2 + (4 * (evt))])
+#define DC_UGDE_3(evt)		(&DC_REG->ugde[3 + (4 * (evt))])
 
 #define DP_SYNC 0
 #define DP_ASYNC0 0x60
diff -Nru u-boot-2017.07/drivers/video/mxcfb.h u-boot-imx6/drivers/video/mxcfb.h
--- u-boot-2017.07/drivers/video/mxcfb.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/mxcfb.h	2018-08-27 21:35:37.700801435 +0300
@@ -49,4 +49,6 @@
 	int slopek[16];
 };
 
+void board_video_enable(void);
+
 #endif
diff -Nru u-boot-2017.07/drivers/video/mxc_ipuv3_fb.c u-boot-imx6/drivers/video/mxc_ipuv3_fb.c
--- u-boot-2017.07/drivers/video/mxc_ipuv3_fb.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/mxc_ipuv3_fb.c	2018-08-27 21:35:37.700801435 +0300
@@ -28,7 +28,6 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 static int mxcfb_map_video_memory(struct fb_info *fbi);
-static int mxcfb_unmap_video_memory(struct fb_info *fbi);
 
 /* graphics setup */
 static GraphicDevice panel;
@@ -222,9 +221,6 @@
 
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
 	if (!fbi->fix.smem_start || (mem_len > fbi->fix.smem_len)) {
-		if (fbi->fix.smem_start)
-			mxcfb_unmap_video_memory(fbi);
-
 		if (mxcfb_map_video_memory(fbi) < 0)
 			return -ENOMEM;
 	}
@@ -397,25 +393,38 @@
 
 static int mxcfb_map_video_memory(struct fb_info *fbi)
 {
-	if (fbi->fix.smem_len < fbi->var.yres_virtual * fbi->fix.line_length) {
-		fbi->fix.smem_len = fbi->var.yres_virtual *
-				    fbi->fix.line_length;
-	}
-	fbi->fix.smem_len = roundup(fbi->fix.smem_len, ARCH_DMA_MINALIGN);
-	fbi->screen_base = (char *)memalign(ARCH_DMA_MINALIGN,
-					    fbi->fix.smem_len);
-	fbi->fix.smem_start = (unsigned long)fbi->screen_base;
-	if (fbi->screen_base == 0) {
-		puts("Unable to allocate framebuffer memory\n");
-		fbi->fix.smem_len = 0;
-		fbi->fix.smem_start = 0;
-		return -EBUSY;
+	unsigned smem_len = fbi->var.yres_virtual * fbi->fix.line_length;
+	unsigned min = 1920 * 1080 * 2;
+
+	fbi->screen_size = smem_len;
+	if (smem_len < min)
+		smem_len = min;
+	smem_len = roundup(smem_len, ARCH_DMA_MINALIGN);
+	if (fbi->fix.smem_len < smem_len) {
+		debug("smem_len %d %d, %lx\n", fbi->fix.smem_len, smem_len, fbi->fix.smem_start);
+		if (fbi->fix.smem_start) {
+			free((void *)fbi->fix.smem_start);
+			fbi->fix.smem_start = 0;
+			fbi->screen_base = NULL;
+			fbi->fix.smem_len = 0;
+		}
+	}
+	if (!fbi->fix.smem_start) {
+		fbi->screen_base = memalign(ARCH_DMA_MINALIGN, smem_len);
+		fbi->fix.smem_start = (unsigned long)fbi->screen_base;
+		debug("screen_base = %p\n", fbi->screen_base);
+		if (!fbi->screen_base) {
+			puts("Unable to allocate framebuffer memory\n");
+			fbi->fix.smem_len = 0;
+			fbi->fix.smem_start = 0;
+			return -EBUSY;
+		}
+		fbi->fix.smem_len = smem_len;
 	}
 
 	debug("allocated fb @ paddr=0x%08X, size=%d.\n",
 		(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
 
-	fbi->screen_size = fbi->fix.smem_len;
 
 	gd->fb_base = fbi->fix.smem_start;
 
@@ -425,14 +434,6 @@
 	return 0;
 }
 
-static int mxcfb_unmap_video_memory(struct fb_info *fbi)
-{
-	fbi->screen_base = 0;
-	fbi->fix.smem_start = 0;
-	fbi->fix.smem_len = 0;
-	return 0;
-}
-
 /*
  * Initializes the framebuffer information pointer. After allocating
  * sufficient memory for the framebuffer structure, the fields are
@@ -448,7 +449,6 @@
 #define PADDING (BYTES_PER_LONG - (sizeof(struct fb_info) % BYTES_PER_LONG))
 	struct fb_info *fbi;
 	struct mxcfb_info *mxcfbi;
-	char *p;
 	int size = sizeof(struct mxcfb_info) + PADDING +
 		sizeof(struct fb_info);
 
@@ -462,14 +462,12 @@
 	 * Allocate sufficient memory for the fb structure
 	 */
 
-	p = malloc(size);
-	if (!p)
+	fbi = malloc(size);
+	if (!fbi)
 		return NULL;
+	memset(fbi, 0, size);
 
-	memset(p, 0, size);
-
-	fbi = (struct fb_info *)p;
-	fbi->par = p + sizeof(struct fb_info) + PADDING;
+	fbi->par = ((char *)fbi) + sizeof(struct fb_info) + PADDING;
 
 	mxcfbi = (struct mxcfb_info *)fbi->par;
 	debug("Framebuffer structures at: fbi=0x%x mxcfbi=0x%x\n",
@@ -497,16 +495,34 @@
 	struct fb_info *fbi;
 	struct mxcfb_info *mxcfbi;
 	int ret = 0;
+	int xres = mode->xres;
+	int gdfIndex = GDF_16BIT_565RGB;
+	int bytes_per_pixel = 2;
+	struct fb_videomode umode;
+
+	if (interface_pix_fmt == IPU_PIX_FMT_UPS051) {
+		interface_pix_fmt = IPU_PIX_FMT_RGB565;
+		umode = *mode;
+		umode.xres = xres * 3 / 2;
+		mode = &umode;
+		gdfIndex = GDF_24BIT_888RGB;
+		bytes_per_pixel = 3;
+	}
 
 	/*
 	 * Initialize FB structures
 	 */
-	fbi = mxcfb_init_fbinfo();
+	fbi = mxcfb_info[disp];
 	if (!fbi) {
-		ret = -ENOMEM;
-		goto err0;
+		fbi = mxcfb_init_fbinfo();
+		if (!fbi) {
+			ret = -ENOMEM;
+			goto err0;
+		}
+		mxcfb_info[disp] = fbi;
 	}
 	mxcfbi = (struct mxcfb_info *)fbi->par;
+	mxcfbi->ipu_di = disp;
 
 	if (!g_dp_in_use) {
 		mxcfbi->ipu_ch = MEM_BG_SYNC;
@@ -516,15 +532,12 @@
 		mxcfbi->blank = FB_BLANK_POWERDOWN;
 	}
 
-	mxcfbi->ipu_di = disp;
-
 	ipu_disp_set_global_alpha(mxcfbi->ipu_ch, 1, 0x80);
 	ipu_disp_set_color_key(mxcfbi->ipu_ch, 0, 0);
 	strcpy(fbi->fix.id, "DISP3 BG");
 
 	g_dp_in_use = 1;
 
-	mxcfb_info[mxcfbi->ipu_di] = fbi;
 
 	/* Need dummy values until real panel is configured */
 
@@ -532,7 +545,6 @@
 	fb_videomode_to_var(&fbi->var, mode);
 	fbi->var.bits_per_pixel = 16;
 	fbi->fix.line_length = fbi->var.xres * (fbi->var.bits_per_pixel / 8);
-	fbi->fix.smem_len = fbi->var.yres_virtual * fbi->fix.line_length;
 
 	mxcfb_check_var(&fbi->var, fbi);
 
@@ -547,16 +559,16 @@
 
 	mxcfb_set_par(fbi);
 
-	panel.winSizeX = mode->xres;
+	panel.winSizeX = xres;
 	panel.winSizeY = mode->yres;
-	panel.plnSizeX = mode->xres;
+	panel.plnSizeX = xres;
 	panel.plnSizeY = mode->yres;
 
 	panel.frameAdrs = (u32)fbi->screen_base;
 	panel.memSize = fbi->screen_size;
 
-	panel.gdfBytesPP = 2;
-	panel.gdfIndex = GDF_16BIT_565RGB;
+	panel.gdfBytesPP = bytes_per_pixel;
+	panel.gdfIndex = gdfIndex;
 
 	ipu_dump_registers();
 
@@ -566,6 +578,8 @@
 	return ret;
 }
 
+void ipu_dmfc_uninit(void);
+
 void ipuv3_fb_shutdown(void)
 {
 	int i;
@@ -583,6 +597,23 @@
 		__raw_writel(__raw_readl(&stat->int_stat[i]),
 			     &stat->int_stat[i]);
 	}
+	ipu_dmfc_uninit();
+	g_dp_in_use = 0;
+}
+
+static void __board_video_enable(void)
+{
+}
+
+void board_video_enable(void)
+	__attribute__((weak, alias("__board_video_enable")));
+
+void *ipuv3_fb_init2(void)
+{
+	mxcfb_probe(gpixfmt, gdisp, gmode);
+	board_video_enable();
+	debug("Framebuffer at 0x%x\n", (unsigned int)panel.frameAdrs);
+	return (void *)&panel;
 }
 
 void *video_hw_init(void)
@@ -592,11 +623,7 @@
 	ret = ipu_probe();
 	if (ret)
 		puts("Error initializing IPU\n");
-
-	ret = mxcfb_probe(gpixfmt, gdisp, gmode);
-	debug("Framebuffer at 0x%x\n", (unsigned int)panel.frameAdrs);
-
-	return (void *)&panel;
+	return ipuv3_fb_init2();
 }
 
 int ipuv3_fb_init(struct fb_videomode const *mode,
diff -Nru u-boot-2017.07/drivers/video/mxsfb.c u-boot-imx6/drivers/video/mxsfb.c
--- u-boot-2017.07/drivers/video/mxsfb.c	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/drivers/video/mxsfb.c	2018-08-27 21:35:37.700801435 +0300
@@ -14,6 +14,9 @@
 #include <asm/arch/sys_proto.h>
 #include <linux/errno.h>
 #include <asm/io.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <stdio_dev.h>
 
 #include <asm/imx-common/dma.h>
 
@@ -21,7 +24,7 @@
 
 #define	PS2KHZ(ps)	(1000000000UL / (ps))
 
-static GraphicDevice panel;
+static struct graphic_device panel;
 struct mxs_dma_desc desc;
 
 /**
@@ -47,15 +50,17 @@
  * 	 le:89,ri:164,up:23,lo:10,hs:10,vs:10,sync:0,vmode:0
  */
 
-static void mxs_lcd_init(GraphicDevice *panel,
+static void mxs_lcd_init(struct graphic_device *panel,
 			struct ctfb_res_modes *mode, int bpp)
 {
 	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)MXS_LCDIF_BASE;
 	uint32_t word_len = 0, bus_width = 0;
 	uint8_t valid_data = 0;
 
+#if !defined(CONFIG_CMD_FBPANEL)
 	/* Kick in the LCDIF clock */
 	mxs_set_lcdclk(MXS_LCDIF_BASE, PS2KHZ(mode->pixclock));
+#endif
 
 	/* Restart the LCDIF block */
 	mxs_reset_block(&regs->hw_lcdif_ctrl_reg);
@@ -151,32 +156,26 @@
 	mxs_reset_block((struct mxs_register_32 *)&regs->hw_lcdif_ctrl_reg);
 }
 
-void *video_hw_init(void)
+static void __board_video_enable(void)
 {
-	int bpp = -1;
-	char *penv;
-	void *fb;
-	struct ctfb_res_modes mode;
+}
 
-	puts("Video: ");
+void board_video_enable(void)
+	__attribute__((weak, alias("__board_video_enable")));
 
-	/* Suck display configuration from "videomode" variable */
-	penv = getenv("videomode");
-	if (!penv) {
-		puts("MXSFB: 'videomode' variable not set!\n");
-		return NULL;
-	}
-
-	bpp = video_get_params(&mode, penv);
+static struct graphic_device *mxsfb_probe(int bpp, struct ctfb_res_modes *mode)
+{
+	void *fb;
+	unsigned mem_size;
 
 	/* fill in Graphic device struct */
 	sprintf(panel.modeIdent, "%dx%dx%d",
-			mode.xres, mode.yres, bpp);
+			mode->xres, mode->yres, bpp);
 
-	panel.winSizeX = mode.xres;
-	panel.winSizeY = mode.yres;
-	panel.plnSizeX = mode.xres;
-	panel.plnSizeY = mode.yres;
+	panel.winSizeX = mode->xres;
+	panel.winSizeY = mode->yres;
+	panel.plnSizeX = mode->xres;
+	panel.plnSizeY = mode->yres;
 
 	switch (bpp) {
 	case 24:
@@ -197,25 +196,31 @@
 		return NULL;
 	}
 
-	panel.memSize = mode.xres * mode.yres * panel.gdfBytesPP;
-
-	/* Allocate framebuffer */
-	fb = memalign(ARCH_DMA_MINALIGN,
-		      roundup(panel.memSize, ARCH_DMA_MINALIGN));
+	mem_size = mode->xres * mode->yres * panel.gdfBytesPP;
+	fb = (void *)panel.frameAdrs;
+	if (fb) {
+		if (panel.memSize < mem_size) {
+			free(fb);
+			fb = NULL;
+			panel.frameAdrs = (u32)fb;
+		}
+	}
 	if (!fb) {
-		printf("MXSFB: Error allocating framebuffer!\n");
-		return NULL;
+		/* Allocate framebuffer */
+		fb = memalign(ARCH_DMA_MINALIGN,
+			roundup(mem_size, ARCH_DMA_MINALIGN));
+		if (!fb) {
+			printf("MXSFB: Error allocating framebuffer!\n");
+			return NULL;
+		}
+		panel.memSize = mem_size;
+		panel.frameAdrs = (u32)fb;
 	}
-
 	/* Wipe framebuffer */
-	memset(fb, 0, panel.memSize);
-
-	panel.frameAdrs = (u32)fb;
-
-	printf("%s\n", panel.modeIdent);
+	memset(fb, 0, mem_size);
 
 	/* Start framebuffer */
-	mxs_lcd_init(&panel, &mode, bpp);
+	mxs_lcd_init(&panel, mode, bpp);
 
 #ifdef CONFIG_VIDEO_MXS_MODE_SYSTEM
 	/*
@@ -240,5 +245,89 @@
 	mxs_dma_circ_start(MXS_DMA_CHANNEL_AHB_APBH_LCDIF, &desc);
 #endif
 
+	board_video_enable();
 	return (void *)&panel;
 }
+
+void cvt_fb_videomode_to_ctfb_res_modes(const struct fb_videomode *fb, struct ctfb_res_modes *ct)
+{
+	ct->xres = fb->xres;
+	ct->yres = fb->yres;
+	ct->refresh = fb->refresh;
+	ct->pixclock = fb->pixclock;
+	ct->pixclock_khz = 0;
+	ct->left_margin = fb->left_margin;
+	ct->right_margin = fb->right_margin;
+	ct->upper_margin = fb->upper_margin;
+	ct->lower_margin = fb->lower_margin;
+	ct->hsync_len = fb->hsync_len;
+	ct->vsync_len = fb->vsync_len;
+	ct->sync = fb->sync;
+	ct->vmode = fb->vmode;
+}
+
+static struct fb_videomode const *gmode;
+static uint32_t gpixfmt;
+
+static struct graphic_device *mxsfb_probe2(void)
+{
+	struct ctfb_res_modes ct;
+	int bpp = -1;
+
+	switch (gpixfmt) {
+	case IPU_PIX_FMT_RGB32:
+		bpp = 32;
+		break;
+	case IPU_PIX_FMT_RGB24:
+		bpp = 24;
+		break;
+	case IPU_PIX_FMT_RGB666:
+		bpp = 18;
+		break;
+	case IPU_PIX_FMT_RGB565:
+		bpp = 16;
+		break;
+	}
+
+	cvt_fb_videomode_to_ctfb_res_modes(gmode, &ct);
+	return mxsfb_probe(bpp, &ct);
+}
+
+void *mxsfb_init2(void)
+{
+	struct graphic_device *fb = mxsfb_probe2();
+
+	if (fb) {
+		drv_video_init2(fb);
+		debug("Framebuffer at 0x%x\n", (unsigned int)fb->frameAdrs);
+	}
+	return fb;
+}
+
+int mxsfb_init(struct fb_videomode const *mode, uint32_t pixfmt)
+{
+	gmode = mode;
+	gpixfmt = pixfmt;
+	return 0;
+}
+
+void *video_hw_init(void)
+{
+	char *penv;
+	int bpp = -1;
+	struct ctfb_res_modes mode;
+
+	if (gmode)
+		return mxsfb_probe2();
+	puts("Video: ");
+
+	/* Suck display configuration from "videomode" variable */
+	penv = getenv("videomode");
+	if (!penv) {
+		puts("MXSFB: 'videomode' variable not set!\n");
+		return NULL;
+	}
+
+	bpp = video_get_params(&mode, penv);
+	return mxsfb_probe(bpp, &mode);
+}
diff -Nru u-boot-2017.07/.git/config u-boot-imx6/.git/config
--- u-boot-2017.07/.git/config	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/config	2018-08-27 21:34:05.071241802 +0300
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/boundarydevices/u-boot-imx6.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "overview"]
+	remote = origin
+	merge = refs/heads/overview
diff -Nru u-boot-2017.07/.git/description u-boot-imx6/.git/description
--- u-boot-2017.07/.git/description	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/description	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -Nru u-boot-2017.07/.git/HEAD u-boot-imx6/.git/HEAD
--- u-boot-2017.07/.git/HEAD	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/HEAD	2018-08-27 21:35:38.024133231 +0300
@@ -0,0 +1 @@
+e8bc5aa930abb24d9881d97e1ab111af8d400e07
diff -Nru u-boot-2017.07/.git/hooks/applypatch-msg.sample u-boot-imx6/.git/hooks/applypatch-msg.sample
--- u-boot-2017.07/.git/hooks/applypatch-msg.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/applypatch-msg.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -Nru u-boot-2017.07/.git/hooks/commit-msg.sample u-boot-imx6/.git/hooks/commit-msg.sample
--- u-boot-2017.07/.git/hooks/commit-msg.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/commit-msg.sample	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -Nru u-boot-2017.07/.git/hooks/fsmonitor-watchman.sample u-boot-imx6/.git/hooks/fsmonitor-watchman.sample
--- u-boot-2017.07/.git/hooks/fsmonitor-watchman.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/fsmonitor-watchman.sample	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,114 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 1) and a time in nanoseconds
+# formatted as a string and outputs to stdout all files that have been
+# modified since the given time. Paths must be relative to the root of
+# the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $time) = @ARGV;
+
+# Check the hook interface version
+
+if ($version == 1) {
+	# convert nanoseconds to seconds
+	$time = int $time / 1000000000;
+} else {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree;
+if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+	$git_work_tree = Win32::GetCwd();
+	$git_work_tree =~ tr/\\/\//;
+} else {
+	require Cwd;
+	$git_work_tree = Cwd::cwd();
+}
+
+my $retry = 1;
+
+launch_watchman();
+
+sub launch_watchman {
+
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	    or die "open2() failed: $!\n" .
+	    "Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $time but were not transient (ie created after
+	# $time but no longer exist).
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	#
+	# The category of transient files that we want to ignore will have a
+	# creation clock (cclock) newer than $time_t value and will also not
+	# currently exist.
+
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $time,
+			"fields": ["name"],
+			"expression": ["not", ["allof", ["since", $time, "cclock"], ["not", "exists"]]]
+		}]
+	END
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	die "Watchman: command returned no output.\n" .
+	    "Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	my $json_pkg;
+	eval {
+		require JSON::XS;
+		$json_pkg = "JSON::XS";
+		1;
+	} or do {
+		require JSON::PP;
+		$json_pkg = "JSON::PP";
+	};
+
+	my $o = $json_pkg->new->utf8->decode($response);
+
+	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+		$retry--;
+		qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		print "/\0";
+		eval { launch_watchman() };
+		exit 0;
+	}
+
+	die "Watchman: $o->{error}.\n" .
+	    "Falling back to scanning...\n" if $o->{error};
+
+	binmode STDOUT, ":utf8";
+	local $, = "\0";
+	print @{$o->{files}};
+}
diff -Nru u-boot-2017.07/.git/hooks/post-update.sample u-boot-imx6/.git/hooks/post-update.sample
--- u-boot-2017.07/.git/hooks/post-update.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/post-update.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -Nru u-boot-2017.07/.git/hooks/pre-applypatch.sample u-boot-imx6/.git/hooks/pre-applypatch.sample
--- u-boot-2017.07/.git/hooks/pre-applypatch.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/pre-applypatch.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -Nru u-boot-2017.07/.git/hooks/pre-commit.sample u-boot-imx6/.git/hooks/pre-commit.sample
--- u-boot-2017.07/.git/hooks/pre-commit.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/pre-commit.sample	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -Nru u-boot-2017.07/.git/hooks/prepare-commit-msg.sample u-boot-imx6/.git/hooks/prepare-commit-msg.sample
--- u-boot-2017.07/.git/hooks/prepare-commit-msg.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/prepare-commit-msg.sample	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -Nru u-boot-2017.07/.git/hooks/pre-push.sample u-boot-imx6/.git/hooks/pre-push.sample
--- u-boot-2017.07/.git/hooks/pre-push.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/pre-push.sample	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -Nru u-boot-2017.07/.git/hooks/pre-rebase.sample u-boot-imx6/.git/hooks/pre-rebase.sample
--- u-boot-2017.07/.git/hooks/pre-rebase.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/pre-rebase.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -Nru u-boot-2017.07/.git/hooks/pre-receive.sample u-boot-imx6/.git/hooks/pre-receive.sample
--- u-boot-2017.07/.git/hooks/pre-receive.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/pre-receive.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff -Nru u-boot-2017.07/.git/hooks/update.sample u-boot-imx6/.git/hooks/update.sample
--- u-boot-2017.07/.git/hooks/update.sample	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/hooks/update.sample	2018-08-27 21:28:12.382920247 +0300
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
  u-boot-2017.07/.git/index  u-boot-imx6/.git/index 
diff -Nru u-boot-2017.07/.git/info/exclude u-boot-imx6/.git/info/exclude
--- u-boot-2017.07/.git/info/exclude	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/info/exclude	2018-08-27 21:28:12.379586928 +0300
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -Nru u-boot-2017.07/.git/logs/HEAD u-boot-imx6/.git/logs/HEAD
--- u-boot-2017.07/.git/logs/HEAD	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/logs/HEAD	2018-08-27 21:35:38.024133231 +0300
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 cf048df0ffcff2ef17b0a973cf979e1491abc0bb N.Leiten <nickleiten@gmail.com> 1535394845 +0300	clone: from https://github.com/boundarydevices/u-boot-imx6.git
+cf048df0ffcff2ef17b0a973cf979e1491abc0bb e8bc5aa930abb24d9881d97e1ab111af8d400e07 N.Leiten <nickleiten@gmail.com> 1535394938 +0300	checkout: moving from overview to remotes/origin/boundary-v2017.07
diff -Nru u-boot-2017.07/.git/logs/refs/heads/overview u-boot-imx6/.git/logs/refs/heads/overview
--- u-boot-2017.07/.git/logs/refs/heads/overview	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/logs/refs/heads/overview	2018-08-27 21:34:05.071241802 +0300
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 cf048df0ffcff2ef17b0a973cf979e1491abc0bb N.Leiten <nickleiten@gmail.com> 1535394845 +0300	clone: from https://github.com/boundarydevices/u-boot-imx6.git
diff -Nru u-boot-2017.07/.git/logs/refs/remotes/origin/HEAD u-boot-imx6/.git/logs/refs/remotes/origin/HEAD
--- u-boot-2017.07/.git/logs/refs/remotes/origin/HEAD	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/logs/refs/remotes/origin/HEAD	2018-08-27 21:34:05.067908485 +0300
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 cf048df0ffcff2ef17b0a973cf979e1491abc0bb N.Leiten <nickleiten@gmail.com> 1535394845 +0300	clone: from https://github.com/boundarydevices/u-boot-imx6.git
  u-boot-2017.07/.git/objects/pack/pack-6fe0702cc90efa883125eeec3c0e962ea17ec975.idx  u-boot-imx6/.git/objects/pack/pack-6fe0702cc90efa883125eeec3c0e962ea17ec975.idx 
  u-boot-2017.07/.git/objects/pack/pack-6fe0702cc90efa883125eeec3c0e962ea17ec975.pack  u-boot-imx6/.git/objects/pack/pack-6fe0702cc90efa883125eeec3c0e962ea17ec975.pack 
diff -Nru u-boot-2017.07/.git/packed-refs u-boot-imx6/.git/packed-refs
--- u-boot-2017.07/.git/packed-refs	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/packed-refs	2018-08-27 21:34:05.067908485 +0300
@@ -0,0 +1,343 @@
+# pack-refs with: peeled fully-peeled sorted 
+03ea18324cdf594b0dbc354ba00d86b337d84b52 refs/remotes/origin/AD
+b661d854a0643db52b0e75c37cb5bb11afd0ccba refs/remotes/origin/boundary-imx_v2017.03_4.9.51_imx8m_ga
+6334977a84a775d775a07d332fc72a26d0f8471a refs/remotes/origin/boundary-v2014.07-20140912-simple-rebase
+ea52dd9b6da1226c8dba439da01f89cba485cb59 refs/remotes/origin/boundary-v2015.07
+0dbffd30b6a81b53c8a4780490ea625ccbfa5596 refs/remotes/origin/boundary-v2016.03
+7d8fb8c1f421482797665d8bcd253fd2fe3d5cbb refs/remotes/origin/boundary-v2017.03
+e8bc5aa930abb24d9881d97e1ab111af8d400e07 refs/remotes/origin/boundary-v2017.07
+17f4452a2c1925ce68ffa48d16592fda04bc00a2 refs/remotes/origin/boundary-v2018.07
+a5a24c34364d59175d7d3130d02e8472572b9f4e refs/remotes/origin/imx_v2013.04_3.5.7_1.0.0_alpha
+6167f540705f8e21446c5abcf555f6448952394d refs/remotes/origin/imx_v2014.04-plus
+877fd9eea1858585c8939e05173feb612c42a95f refs/remotes/origin/jb4.3_1.0.0-beta
+47cd385c0dfcd6026743944038eec01adf04bc0d refs/remotes/origin/mainline
+f9860cf081efdf32c8a01b9fc271fe55e2a79f8d refs/remotes/origin/master
+cf048df0ffcff2ef17b0a973cf979e1491abc0bb refs/remotes/origin/overview
+6ff5865d79b46392c829316fb727bfda0f25c3f5 refs/remotes/origin/production
+1e8892278066984c73a82423d674bc50df1c7fde refs/remotes/origin/production-before-20130402
+300f40f75af421ee265ff6fcb3866cf5a60564fe refs/remotes/origin/production-before-20130826
+4034391b51ca8722a0fc9a44a27fb0c04f482d4f refs/remotes/origin/production-before-20131107
+9e3e96a5534c5aa0072bc6fcc40cae72eb9b54ac refs/remotes/origin/production-before-20140228
+5cbf8c50b5132c386a5649ba049d4c36d651368b refs/remotes/origin/production-before-20140419
+c370cb10374085504726776c6f34852914dbe764 refs/remotes/origin/production-before-20140912
+4dfca8881f318f0d346b575ffbe93aa12755c4e9 refs/remotes/origin/production-before-20140922
+c8819ac088361699ba1762626b113470c7a48a4c refs/remotes/origin/silent-uart
+14a700f0555cbeab98963291743252ff3dba6310 refs/remotes/origin/solo-dl-staging
+881e34f495896e9d487c52af7da0dad15547b6e5 refs/remotes/origin/staging
+5957f6d05a1778ed7cc002e8635b13f6954ec5b6 refs/remotes/origin/staging-20130225
+2c629987ab5cc9adce1209330fa2c0f5b62017b6 refs/remotes/origin/staging-before-20121017
+01ce18f6bdbda2adf3c1b33c2c79255c61bb412d refs/remotes/origin/staging-before-20130529
+5476f5bc35a3dd3efaaa3337ab931c6d6d09575b refs/remotes/origin/staging-before-20130617
+a85245959680a611eea29fbcbc48b355ad733237 refs/remotes/origin/staging-before-20130818
+49b0415a80474eeb7876dede868c65764d6e973a refs/remotes/origin/staging-before-20130826
+ed146e7f3dab681daa103c6f9763566be6b41652 refs/remotes/origin/staging-before-20131009
+e2ee7f487aa6fd451aa5c8a56d2a3acf54b85138 refs/remotes/origin/staging-before-20131107
+bb725a4b53c7cb5f0c0a28af9af63ae35b2388b2 refs/remotes/origin/staging-before-20140123
+26fe52891dda25b28368e699bf0d55bad978236b refs/remotes/origin/staging-before-20140210
+6fa8940a6dbf29395921c4c6ee0c33d2bd636f36 refs/remotes/origin/staging-before-20140223
+6f1ea21f68b27e9e0ec2b8bc68ad266b3f68959b refs/remotes/origin/staging-before-20140228
+5c59c4844784fe14ed23c7dd539f76fc33fc8bba refs/remotes/origin/staging-before-20140304
+e5940df6e20b1ee2aa00ebc1367576834aff61b7 refs/remotes/origin/staging-before-20140312
+3a46c63e9bc072d14621f7e897ad7665dea55d57 refs/remotes/origin/staging-before-20140419
+20ee485137281190b1df3218928511a7a61a7d56 refs/remotes/origin/staging-before-20140912
+6e08c9c7cbcc012615d64fb2ebfffba90a9647c2 refs/remotes/origin/staging-before-20140927
+925f4946cb30bac9cd0cc647ac5a07964ca0c25c refs/remotes/origin/staging-h
+96b03ed4c108c92a21f4a67d29a7c29ec362905b refs/remotes/origin/staging-plus-6P
+622429b5dd8412f551a84a4928b2ce397af521ff refs/remotes/origin/staging-v2014.10-rc2
+ce12b6fba93996645d03c30447224f4de5c1a929 refs/remotes/origin/t22
+129212133e70672b057bb39359c68de50afd9e39 refs/remotes/origin/upstream-v2014.10-common-displays
+ffa1d3e58c38df4cef17f2e7103822dca2d8ab26 refs/remotes/origin/v2013.10-20131016
+7257391def98981514d5c13533da1242c3459f99 refs/remotes/origin/v2013.10-20131119
+7a2bfd561047f432175715a735bf4b9c841b378b refs/remotes/origin/v2014.01-20140223
+c4acd1b68c9a843d05aa8cb233843c2689041ef2 refs/remotes/origin/v2014.01-20140228
+4dfca8881f318f0d346b575ffbe93aa12755c4e9 refs/remotes/origin/v2014.04-20140419
+21eb41461f0f1e9b7dde59cee37de89b473868ef refs/remotes/origin/v2014.07-20140914
+ebb0f6275f9e02c6a5656e4f7715785e16954187 refs/remotes/origin/v2014.10-common-video
+be360d9824d653780ebd3ffc08f1938a8e3dd747 refs/tags/DENX-2005-10-29-2350
+384ae02506f0673070a3516b1858f058a07f85f3 refs/tags/LABEL_2002_11_05_0120
+56f94be3ef63732384063e110277ed89701b6471 refs/tags/LABEL_2002_11_05_1735
+7f6c2cbc2bc0721c41bb776242c0b18ec70328e4 refs/tags/LABEL_2002_11_10_2310
+1d0350ed0b1b0f63e3fb5db6b19397b84a2ea1c7 refs/tags/LABEL_2002_11_11_2211
+2262cfeef91458b01a1bfe3812ccbbfdf8b82807 refs/tags/LABEL_2002_11_18_0115
+ea909b7604306a400ee3abf57e2fa7b2dde5dde1 refs/tags/LABEL_2002_11_22_0015
+a6c7ad2f65afaa717ba19cbf9d8d138b5f10ccf9 refs/tags/LABEL_2002_12_03_2230
+7c7a23bd5a0bc149d2edd665ec46381726b24e0c refs/tags/LABEL_2002_12_07_0120
+288b3d7f5a54c987ecdfc5add4c7c25d36a9a3e1 refs/tags/LABEL_2002_12_21_0040
+13122b4f1d6d00d6d4993ef56d9b5c5bd24f431e refs/tags/LABEL_2002_12_28_1700
+d0fb80c3021e15853895e9ae45ab9368d0fb52fa refs/tags/LABEL_2003_01_11_1050
+608c91460b37fd9fe0088a0ce813a443f116a8d5 refs/tags/LABEL_2003_01_14_0055
+6069ff265362ef6239749b5f598b137f407b821e refs/tags/LABEL_2003_02_28_0150
+43d9616cffb4a130e1620e3e33fc9bc1bcabe399 refs/tags/LABEL_2003_03_06_0050
+db2f721ffcf9693086a7e5c6c7015f2019e7f52e refs/tags/LABEL_2003_03_06_0200
+500545cc6b83958209128bffa825b3c842a21a4e refs/tags/LABEL_2003_03_06_1440
+1cb8e980c41e86760fa93de63f4e4cf643bef9d9 refs/tags/LABEL_2003_03_06_2255
+1957dd29d980ecb197c3a6dbe4f6609dae135a1d refs/tags/LABEL_2003_03_14_2150
+10f670178cce29d7f078ca622f0eeafd6903748a refs/tags/LABEL_2003_03_25_1830
+ac6dbb85b7f080d923013bff4e1d5267cb6f8a5a refs/tags/LABEL_2003_03_26_1300
+cdd8a0f1517b89349265465bf334db32e2304b45 refs/tags/LABEL_2003_03_27_1900
+3e38691e8f7aa0d9b498d76c7279ddec6e4946f3 refs/tags/LABEL_2003_04_05_0300
+4a6fd34b267dbf4a72080ab9a085bb45c63660fb refs/tags/LABEL_2003_04_15_1900
+7aa78614716b7bd7bdf68553f261ad0d5a12826a refs/tags/LABEL_2003_05_03_1700
+45219c46605f9b933ab454738ee4ce543d5b70d6 refs/tags/LABEL_2003_05_12_2355
+7f70e85309c6367138c0ebd14abdd49964b8d50a refs/tags/LABEL_2003_05_20_1630
+82226bf4d2fe87076d7f5d7e2677fdd5d0e35fc2 refs/tags/LABEL_2003_05_20_2250
+c8c3a8be2dd09e51d7dc33f431e3a638ac5688f2 refs/tags/LABEL_2003_05_22_2230
+5d232d0e7ea982d859d028ab482d95eb68460b19 refs/tags/LABEL_2003_05_23_0055
+4c3b21a5f915988e3d9681cf9cb566bb7bd56859 refs/tags/LABEL_2003_05_23_1450
+3b57fe0a70b903f4db66c558bb9828bc58acf06b refs/tags/LABEL_2003_05_30_1450
+7a8e9bed17d7924a9c5c4699b1f6a3a0359524ed refs/tags/LABEL_2003_05_31_2115
+682011ff6968198da14b89e40d9f55b00f6d91f7 refs/tags/LABEL_2003_06_04_0200
+a3ed3996cdb9fca78329f6aca62d235263b7da90 refs/tags/LABEL_2003_06_05_2140
+71f9511803de65a3b98d2f592d418da1d1539f13 refs/tags/LABEL_2003_06_16_0055
+9a0e21a3a87830f66a93c17d1bca66fd12d860ae refs/tags/LABEL_2003_06_22_1530
+b783edaee8252bfdba3f7b3fd29519a81ce71e42 refs/tags/LABEL_2003_06_26_2220
+8bde7f776c77b343aca29b8c7b58464d915ac245 refs/tags/LABEL_2003_06_27_2340
+91a0ce965d5905c37fff45555b7e3113b9359c8f refs/tags/LABEL_2003_06_28_0050-stable
+ef0630617e0f52dabb2cf7073df281e680073ec1 refs/tags/LABEL_2003_06_28_0130-stable
+ed579b4210cc5341d511e090239ca697e91ad728 refs/tags/LABEL_2003_06_28_1800-stable
+eeacb89cb311fe273fef0f20b2bacf589b36f8f4 refs/tags/LABEL_2003_06_29_0145
+7152b1d0b3f8beec8c297d64664e41b4c4ef610a refs/tags/LABEL_2003_09_06_0055
+4f7cb08ee7b48a511a9cd2398fd4a243ca2733c7 refs/tags/LABEL_2003_09_12_0110
+f5300ab241898c490231e59229e6312aa862ce52 refs/tags/LABEL_2003_09_12_1745
+531716e1710083f91d9fa351f89d18e271b5c577 refs/tags/LABEL_2003_09_13_2100
+34b3049a60a37e180d73332ccddf706c049a0515 refs/tags/LABEL_2003_09_16_2310
+80369866a482b923f0398f4c8172865282559f5b refs/tags/LABEL_2003_09_18_2045
+bb65a312675f3cd1923a5cbe325ad9ca1703fc58 refs/tags/LABEL_2003_10_01_1830
+fbe4b5cbdea438ccec0d93de443f367f3ba46196 refs/tags/LABEL_2003_10_06_2355
+a0ff7f2eda50de4d4096265a086c94ac640fab7c refs/tags/LABEL_2003_10_09_1515
+5da627a424b3ad2d38a81886ba4a18e5123a6788 refs/tags/LABEL_2003_10_09_2320
+f72da3406bf6f1c1bce9aa03b07d070413a916af refs/tags/LABEL_2003_10_10_1200
+2d5b561e2bfdee8552a99b2cf93016cce2a74895 refs/tags/LABEL_2003_10_14_2140
+42d1f0394bef0624fc9664714d54bb137931d6a6 refs/tags/LABEL_2003_10_16_0200
+d7281f41094bee59eca958de3c04995a2f79034a refs/tags/LABEL_2003_10_20_0025
+b4757cee52597ab5a67c30a1bf2a3208209e1ccb refs/tags/LABEL_2003_11_26_MKR
+fa1399ed127c8be507bf182dc7d8d61a54938d79 refs/tags/LABEL_2003_12_06_1550
+5e4be00fb037feb6476125d044b98e0e22b70d31 refs/tags/LABEL_2004_01_21_2110
+6876609446980c3055bbd32c195a63330e21d8e6 refs/tags/LABEL_2004_01_29_1030
+a2d18bb7d31e7b971386fef505ff0218f3b6e893 refs/tags/LABEL_2004_02_11_2240
+cf56e1101957c09cb4aafcf28a89658c4649c511 refs/tags/LABEL_2004_02_20_2310
+5cfbab3d822cb690be6d4f1793aab0cea761134c refs/tags/LABEL_2004_02_24_0305
+232c150a250bb2fcb894b15d67c65df2458e271f refs/tags/LABEL_2004_03_12_0130
+42dfe7a1844cbad7114038aaf03828acb7a84414 refs/tags/LABEL_2004_03_14_2340
+d9df1f4e662441c487f96a4e1f91caa9297afdd9 refs/tags/LABEL_2004_03_16_2330
+b79a11cc2bda7a4d5e00444427a0d06b4e86a990 refs/tags/LABEL_2004_03_25_1630
+998eaaecd46ee5f00550e30e606cb5556e0b9345 refs/tags/LABEL_2004_04_18_2135
+5cf91d6bdc3e60bd43f9ba1bbb97a43ee49b2b2d refs/tags/LABEL_2004_04_23_2240
+e4cc71aa4403c82f0b3e89087024f83832ece9ec refs/tags/LABEL_2004_05_19_2335
+69459791268d48c7081802dbc7a51d4e42c8a8cd refs/tags/LABEL_2004_05_29_1850
+021bfcd3c624ce88f739f01ba4220197bdd47a5e refs/tags/LABEL_2004_06_24_1800
+e94d2cd9d1dc0f58b18e7c31fc9345129b1a44fb refs/tags/LABEL_2004_07_01_1200
+31a649234ee4051e96cf45285cdf2dbfa668d30c refs/tags/LABEL_2004_08_28_2355
+7ca202f566a6e9dc3d0dd0216e82ad1a48f50f19 refs/tags/LABEL_2004_08_29_0045
+eedcd078fe1434d93b84322c4e14c52f80282a41 refs/tags/LABEL_2004_09_09_0000
+8b74bf31fe57edfc502f94e905977304eac943ca refs/tags/LABEL_2004_10_12_0110
+14699a22cf47b83995d19877d2b938b2270defc0 refs/tags/LABEL_2004_10_20_0020
+cacfab588a897c369a4906818c5ed4bc40a450c5 refs/tags/LABEL_2004_11_17_2222
+ed54e6212518262d27abe5e6de3c608d5ebceafb refs/tags/LABEL_2004_11_25_0035
+f7d1572bf51619554f278cb543ef0445baa3a1f8 refs/tags/LABEL_2004_12_18_2335
+bff96b0e6bdf8551e8468b111177c553e4994db2 refs/tags/LABEL_2004_12_19_1100
+08f272787a93cb11338fd81ab92a7439a361e3b2 refs/tags/LABEL_2004_12_19_2240
+400ab719c6025c176c50bcdff342384222d7424b refs/tags/LABEL_2004_12_20_1220
+436be29cad60a46ed5983120aff71909d8f234a3 refs/tags/LABEL_2005_01_31_2245
+e799d3755e83c70bf8c92977190d1777b390a8de refs/tags/LABEL_2005_02_07_2045
+b9649854f6ffdeaad23daec21013552cef2e05f0 refs/tags/LABEL_2005_02_08_1615
+e58cf2a0cfeb357faa134af1e12b96f4109af360 refs/tags/LABEL_2005_02_28_0050
+f4733a0764741966a5e842968166b40fb062d577 refs/tags/LABEL_2005_03_06_0225
+911d08f6ae244c6407fff268585e5b9544ce8adb refs/tags/LABEL_2005_03_15_0125
+f5c5ef4a1fa7dcf90fd74f795a131d07377406ab refs/tags/LABEL_2005_04_05_1830
+12b43d515c62682fcf7b578f31920a2be49142fe refs/tags/LABEL_2005_04_05_2345
+5e5f9ed254e20b830fef5f42a52ac0bbdc92a57e refs/tags/LABEL_2005_04_14_0115
+412babe304b948e1e3a909f8d2eb091b83f700d5 refs/tags/LABEL_2005_05_05_1920
+ed16fefcbaf99a67a7dd7639898dbc896c70cb1b refs/tags/LABEL_2005_05_09_1245
+9dd41a7b0c5c94d74c25edfdd6393c656669c09a refs/tags/LABEL_2005_05_13_0050
+88804d19e2bf36c9eaefadbd7199c093c900953b refs/tags/LABEL_2005_07_04_0202
+dafba16e6fc1837381c8e74c4891ad6965cf54ab refs/tags/LABEL_2005_08_12_0050
+053b40fa0c90d885b00c29c9c4490924801809f7 refs/tags/LABEL_2005_09_15_2320
+eb394f56db3e05d00891d6dc36a00df0025cf255 refs/tags/LABEL_2006_03_12_0025
+^84ef51a632063e8cb57b2e9a4252497512831ffe
+9bf86baaa3b35b25baa2d664e2f7f6cafad689ee refs/tags/LABEL_2006_04_18_1106
+^8419c013048b1f15f3fa2fc7c0463d860a04ee3e
+7a4978bc272e20c7febd15d76786c7d9b86a98cd refs/tags/LABEL_2006_05_10_1800
+^977b50f86824fe3c262ef7efce5dbb7ddaf8a48f
+c7071e6d645a8e13adb0d4cea2caad27213fa62f refs/tags/LABEL_2006_05_19_1133
+^5770a1e488621a9e7e344afed7c921ff4e715a63
+b11752921b5d22dcfda237e035a86470993e887b refs/tags/LABEL_2006_06_30_2020
+^3f7a63e6a34c5b435864c860c1563117e45d1c35
+2f91a3d0f8a73665423eb6ab17689c67f05e0887 refs/tags/U-Boot-0_2_0
+60fbe254243ec461ec73da13132be098db33d3fa refs/tags/U-Boot-0_3_0
+02c9bed451b36f3b1f11d5fe617da4fe4b9f9ab7 refs/tags/U-Boot-0_3_1
+993cad9364c6b87ae429d1ed1130d8153f6f027e refs/tags/U-Boot-0_4_0
+b0fce99bfc116c2ddb4506268d6e4a0a7054478d refs/tags/U-Boot-0_4_1
+f12e568ca45f6c56b5a6d52a43524987e141abe7 refs/tags/U-Boot-0_4_2
+ad12965db5d145f7cf7595cbeaf03b3402f42897 refs/tags/U-Boot-0_4_3
+945af8d723a29e9b6289d84250745ed0dc16fc81 refs/tags/U-Boot-0_4_4
+ae3af05ec986a8ac66dadb5eafe13db2d4a02c5c refs/tags/U-Boot-0_4_5
+e0ac62d798ce60ec5d43125d4786e58b0d881836 refs/tags/U-Boot-0_4_6
+0cb61d7dddb0d8c087f6df46a74815950668c97b refs/tags/U-Boot-0_4_7
+7205e4075d8b50e4dd89fe39ed03860b23cbb704 refs/tags/U-Boot-0_4_8
+b13fb01a62708492cae4b33c4d6fa9ae127905f4 refs/tags/U-Boot-1_0_0
+b299e41a0d34bf96202d9bbb72739bdd9414b0cc refs/tags/U-Boot-1_0_1
+198ea9e294e38cea49f9f2d9b911bdfdd20e48dc refs/tags/U-Boot-1_0_2
+f525c8a1476945b078ce4ffe6cf768c286cbf8cc refs/tags/U-Boot-1_1_0
+08f1080c9cbde2a500e6efe8bc5647a68f183c91 refs/tags/U-Boot-1_1_1
+15c7a8efd2f7275e5b3249aac305f2598a998645 refs/tags/U-Boot-1_1_2
+2893ecbf3e5b983970138289b759baf45a327ff3 refs/tags/U-Boot-1_1_3
+74ad4b4fef966ab4cc7192b5b3808ec95e60570b refs/tags/U-Boot-1_1_4
+^e6b6d16de73de6a76e2ec4338291e828b860f040
+b7487ff5a5d41e379809509b9a07546e73577dc8 refs/tags/U-Boot-1_1_5
+^ba999c531ed16ec749b2b6f4b0133cee38842b91
+ba89ef3908907cf55a5bff6ba211b8d8c2b08800 refs/tags/U-Boot-1_1_6
+^c59200443072353044aa4bf737a5a60f9a9af231
+eb8fae4983cfe07fe7c785f483f2278b6146463a refs/tags/U-Boot-1_2_0
+^f4eb54529bb3664c3a562e488b460fe075f79d67
+d9af3c87df93e1a8126b1a52adf8db978e9a0d40 refs/tags/U_BOOT_0_1_0
+69a193a815e7f0b35eeeb013a1f1e0cd9e590f92 refs/tags/v1.3.0
+^9a337ddc154a10a26f117fd147b009abcdeba75a
+6b894f3c3eac06420acad28e70621c5ba410b321 refs/tags/v1.3.0-rc1
+^ff7640c9ead8806b5d827f2b29f9cb2632add729
+a5d674296b4a991efdb708a9c8d6c78d4e47f565 refs/tags/v1.3.0-rc2
+^66dcad3a9a53e0766d90e0084123bd8529522fb0
+bf58489ae2e0de9bd2d7a6ebdbfdb655b48f0c09 refs/tags/v1.3.0-rc3
+^636400198228d96983c06657b17f760f5989958e
+409530dcb489cf4c24fab977ca041dac27ff9f28 refs/tags/v1.3.0-rc4
+^5947f6999aafa7c54c1390983d264a8463dfea8e
+2006af48494237562529cfdb111681149e0f13e9 refs/tags/v1.3.1
+^41be969f4957115ed7b1fe8b890bfaee99d7a7a2
+b67a97f26c406e9116fc85f5dcad4917b7a1c801 refs/tags/v1.3.1-rc1
+^8d4f040a3c15036a6ea25a9c39e7d89fefa8440d
+2b0e9596bac7d2776431657488db88703ba1d441 refs/tags/v1.3.2
+^30f1806f60978d707b0cff2d7bf89d141fc24290
+1dec865fbd4b229061233c504166443f623335db refs/tags/v1.3.2-rc1
+^67a4389e39ad853d65b72e2b7cad15c7e8291147
+c19f1e9b9a8794d488221a9cc3a60db03b7ccc5a refs/tags/v1.3.2-rc2
+^b29661fc1151077776454288051bc9a488351ce8
+955a05aa4445c5652c53e06254d420d7dffd49a6 refs/tags/v1.3.2-rc3
+^661bad63a076a96c39c64f136915f146725af92b
+01348d89a001323ae51dda449decea61092e008b refs/tags/v1.3.3
+^180a90abdae72587c0f679edf8991455e559440d
+33a7d077fd81772d263a4e91a5aebe585c5362ca refs/tags/v1.3.3-rc1
+^fd7531c1e9d56b9e5e06d2c0e02b798dab72f70c
+5ee1a6e902f3b76f672587bb7be4600ab9af1c34 refs/tags/v1.3.3-rc2
+^76617299358ebba260ecc02d33e8e75d8d13dd3b
+239f0883ea3a9f511f8925619d30a0dc9ea8fe01 refs/tags/v1.3.3-rc3
+^6adf61dc4cb5c53a2df990cbc8df2bceacbfd869
+5978b7d69fc40ee9512a6c1b5a3216019ee8e847 refs/tags/v1.3.4
+^cd82919e6c8a73b363a26f34b734923844e52d1c
+7cbbab2ab61f4f726fac1ff6b8bf2dfd26f2b3ba refs/tags/v1.3.4-rc1
+^699f05125509249072a0b865c8d35520d97cd501
+69be245e15510af0756aafb01020f9752ff7e066 refs/tags/v1.3.4-rc2
+^4b50cd12a3b3c644153c4cf393f4a4c12289e5aa
+624c2d518b6dfc652db6fcbc969bbd93f9821322 refs/tags/v2008.10
+^b59b16ca24bc7e77ec113021a6d77b9b32fcf192
+3033c74cb0ad3dfbb1733a36f72f2f4496ba1863 refs/tags/v2008.10-rc1
+^8b9e4787641719d709bfa2ebeb72e8bd4952bee7
+2071c4239c250da6c8cbc93aa1d74b503acb2507 refs/tags/v2008.10-rc2
+^c0d2f87d6c450128b88e73eea715fa3654f65b6c
+789d45f945bc37e721b91923388a91a4f4fcbedb refs/tags/v2008.10-rc3
+^b4dbacf69a669a17487054552fc2761149dd6767
+c2d264a1e4540f09e7098a42d094bf6724567043 refs/tags/v2009.01
+^72d15e705bc3983884105cb7755c7ba80e74a0a5
+866b1cc6f942be4e2669c17e390cd552abc68e3e refs/tags/v2009.01-rc1
+^aced78d852d0b009e8aaa1445af8cb40861ee549
+35ca1e5e625049dbad16ce4cb273e5af47706a23 refs/tags/v2009.01-rc2
+^0e3ece33801e377be67ffa29f083421ad820f28b
+79f73ea6d9d81ce14a839fa4cc24d1a3ad0975fc refs/tags/v2009.01-rc3
+^635e5f8fc82365e6e9734b3132bc95135a6de679
+661e77d04058f94336f621e41b7b341a3b503833 refs/tags/v2009.03
+^e60beb13cf0135dc71c541021487b5ccc4d269cb
+0eb92888fc505ffc6bc58a5e7bedc0ae127279fa refs/tags/v2009.03-rc1
+^32688e572ff96715b41420e9a7f280db6c399b65
+0e34d8aa7974c11a5fd9afe983e9c277e02ef358 refs/tags/v2009.03-rc2
+^b3dd629e78870ba2dc9f8032978721c0fa02a856
+d70da93b038dbee50cb3e84cc0db25aab424a772 refs/tags/v2009.06
+^6b1f78ae6ad037382ad430b07064105c88f7ac02
+4cb5ec6e36792f300ecbe4e67eb6931848e0bace refs/tags/v2009.06-rc1
+^6b8edfde22acc574b5532e9f086e6a7287a9bc78
+210d415558d01a195f98360b127e3f4eb3bb933b refs/tags/v2009.06-rc2
+^a2e0ffcf2d9a22c582a93e84a4bef20fd3877f47
+95bd78f93cfc903186e88fc58deac036c401cfbc refs/tags/v2009.06-rc3
+^580611cb0932143fc2d7a735cfa9ce1ef34d6002
+e99ab567a1a6848b871a9af8cab3ad2c0c49647a refs/tags/v2009.08
+^3d35d87d5482de23cd5dc4d7721b1086107cae50
+e2447f7b3a5336462dd3bebf9a10fc368461b023 refs/tags/v2009.08-rc1
+^94978e19f31d225b4f7d97c4acbac1ecfaeb8f69
+6f03d260e53b1263471e5c3e690ddfe43b53d959 refs/tags/v2009.08-rc2
+^eb1a4d0a471505c169bef19a73a60f8641f0b875
+9ab87511114da4af82dbdf745edc7478d3e3f274 refs/tags/v2009.08-rc3
+^963f2f611741f8d9c38bd7caf20ae8c95cab7b3f
+bd1e74b1989e22fe19f8809cacfbf9cbbf4eaf20 refs/tags/v2009.11
+^a200a7c04d89853d2a1395b96d8ca5e3dd754551
+815f048382dc123c29baa41238a89f820876bf1e refs/tags/v2009.11-rc1
+^4946775c6db52dba28f72ba3525764b54f1d4593
+4c682c60e20b5624868ed6aa214d073cfb8dc0a6 refs/tags/v2009.11-rc2
+^0fc52948bda0734431cb528ee4fd82f1dec8c7b5
+9fd828dddea4306b99670d07366fe3f7c1052d08 refs/tags/v2009.11.1
+^f20393c5e787b3776c179d20f82a86bda124d651
+65bc917e953601b09965e5fcdfbe4f6c75547e50 refs/tags/v2010.03
+^ca6e1c136ddb720c3bb2cc043b99f7f06bc46c55
+537c2a51feed445384aa43e482e4ddc0b5549a75 refs/tags/v2010.03-rc1
+^93910edb595a88d394da3eb2cf5148096155dfe9
+273a6decf55982f7a5263d17559b94281f36caf7 refs/tags/v2010.03-rc2
+^152dda3d94e97ede7af3f9560a59a659384d4585
+3ef91195a43e6a229290977d70bb913008db2dc9 refs/tags/v2010.03-rc3
+^2883cc2d48e99fd1873ef8af03fee7966611b735
+41d5718ee6fb36a1282cde6c86b55f83b62278e1 refs/tags/v2010.06
+^a59e27997637a2395ae2cc7f809127f24119a167
+096e50e0a8934f4e083d43d5711d611eebe82607 refs/tags/v2010.06-rc1
+^01f03bda5b22e5aeae5f02fd537da97a41485c73
+a42fe9aa726cd3d64c3fcf11eea0bc531ee8d281 refs/tags/v2010.06-rc2
+^a9046b9e1aeeedc66ddf1d00474ad0ce8c6aa6e4
+17d61cb4e86f3dc4e7deaa0042fe6d6a6afff8f3 refs/tags/v2010.06-rc3
+^482126e27b3dbf0e69a6445da8b94b3551adf05d
+f7b386b1df73ff213287eed6ca1b74bb91da1b05 refs/tags/v2010.09
+^1e4e5ef0469050f014aee1204dae8a9ab6053e49
+c988fb931f8c8f5d9ce1fc6ca2c20219bcd0fc10 refs/tags/v2010.09-rc1
+^2d941de9d5c7ba00dc19787dfa0aac2949fd00fb
+09012d353eaf26310dc3ddb1915a3d3504ab9a27 refs/tags/v2010.09-rc2
+^07517e7f4f582d1607adbc444bab75af3ac4a7f9
+d0e3a3f4574f1f51ae3d7c5605b7ea5c6df929d4 refs/tags/v2010.12
+^250ef029844be2cb98635f265359396866d1749f
+5aeba5ba231ccceba84dd2311b1dae645b75bfdc refs/tags/v2010.12-rc1
+^908614f20f7f0f5df736eed21b88e81ebbf14e86
+a1904f2bc34e97d79483bcefc35b188620ee9089 refs/tags/v2010.12-rc2
+^d0d2271f8c62e830ec65fb069b6d12dd708e3e2f
+9bde025ff24c811c02d2a7e6451a57ea63895b3a refs/tags/v2010.12-rc3
+^3ac45988ab1605baaf83bd3acb80a197c9a208c2
+b29fbb347698286935bfc401c08499a6f63479de refs/tags/v2011.03
+^19b54a701811220221fc4d5089a2bb18892018ca
+2360c73ed79d91fe75c297c8a62b2810e8eef281 refs/tags/v2011.03-rc1
+^42d44f631c4e8e5359775bdc098f2fffde4e5c05
+38c5af4db86a3e7feaff5092b136722c53784c03 refs/tags/v2011.03-rc2
+^cb815e5ff979e36d68df130a810d34de4bf93289
+54d5e1052f16fe5e3337600f485b13b4c6204972 refs/tags/v2011.06
+^b1af6f532e0d348b153d5c148369229d24af361a
+4d0984f19a46afd17d1ca843deacc5bbedd95eda refs/tags/v2011.06-rc1
+^7a82c208143bbc774ffcb4e53239410f867a0794
+1b885e3346f4e06463949dcca3f9444d3d76eeda refs/tags/v2011.06-rc2
+^6f4dd40cddbd69c56fec1285fee02cbd5a3833d8
+0431724fde21417139eb1209ea8b562235c64c6e refs/tags/v2011.06-rc3
+^79cfe422615c010a75ece41662a05cd432ada389
+58fb473021fd5377db6cb934ea7032da885f80b7 refs/tags/v2011.09
+^1d5e7fb403257d62f0f2419cb83fdf6b0f02f215
+86773b53d37288d8ad16f27b93fd948ff11f8012 refs/tags/v2011.09-rc1
+^6ceb0135f96d73063ffbaab5be7ce23933367388
+00e61f6907d4ecc2e41f4ba61da74e7cc8665e29 refs/tags/v2011.09-rc2
+^bc196029f53c2d82eb9a12eb8b66e696b6284941
+d0b049d45ae734fa473894ae6fd9f4d7d2437cc5 refs/tags/v2011.12
+^cba9a894fdb1cb49b60fcd1d1d6919cbd7995dd5
+ee26bfcef5eb5cb4481eb073924cddc22ea2e423 refs/tags/v2011.12-rc1
+^5738946be46c513fd945d3e1d8f8a0fa718b7c58
+db9c62b847eab7d42b396ee59cbf4e5e75f02fc6 refs/tags/v2011.12-rc2
+^901de79a3792c81aefcbf207a34049e63f21362b
+d18276f86b5bed7646749a6a81ae94af79578d5f refs/tags/v2011.12-rc3
+^be662e9a6b7bf27cb7bc06de18f3c51b2ea80160
+5910ada22359d6cd06b9299f1ef6020a1ea2b893 refs/tags/v2012.04
+^2790bf69dc12fb9aeb9836904e5f57c7f83d5552
+bf41e44b53ad476c47da12f985115d2f073c716d refs/tags/v2012.04-rc1
+^c008b6f6dd6b8965e9a7654ffbce75bb9ff7a3b5
+b9c6ec5eb3eaa4471b32e92f48d6df2867020738 refs/tags/v2012.04-rc2
+^f5cdc11775c4b7fdbf52a6dd2f463d329804ab11
+d2062de0a3356d2e5c4b9ee6b7c805f0ac5cef37 refs/tags/v2012.04-rc3
+^fb14b6b2f680363678b4e6a75eb9f3f0d79111fa
+b75d3092239fc5e0e05571d91a380eb8d90d2f45 refs/tags/v2012.04.01
+^415d386877df49eb051b85ef74fa59a16dc17c7d
diff -Nru u-boot-2017.07/.git/refs/heads/overview u-boot-imx6/.git/refs/heads/overview
--- u-boot-2017.07/.git/refs/heads/overview	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/refs/heads/overview	2018-08-27 21:34:05.071241802 +0300
@@ -0,0 +1 @@
+cf048df0ffcff2ef17b0a973cf979e1491abc0bb
diff -Nru u-boot-2017.07/.git/refs/remotes/origin/HEAD u-boot-imx6/.git/refs/remotes/origin/HEAD
--- u-boot-2017.07/.git/refs/remotes/origin/HEAD	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/.git/refs/remotes/origin/HEAD	2018-08-27 21:34:05.067908485 +0300
@@ -0,0 +1 @@
+ref: refs/remotes/origin/overview
diff -Nru u-boot-2017.07/include/common.h u-boot-imx6/include/common.h
--- u-boot-2017.07/include/common.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/common.h	2018-08-27 21:35:37.747467879 +0300
@@ -417,6 +417,7 @@
 int board_postclk_init (void); /* after clocks/timebase, before env/serial */
 int board_early_init_r (void);
 void board_poweroff (void);
+void board_power_check(void);
 
 #if defined(CONFIG_SYS_DRAM_TEST)
 int testdram(void);
diff -Nru u-boot-2017.07/include/config_distro_bootcmd.h u-boot-imx6/include/config_distro_bootcmd.h
--- u-boot-2017.07/include/config_distro_bootcmd.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/config_distro_bootcmd.h	2018-08-27 21:35:37.747467879 +0300
@@ -309,6 +309,12 @@
 	BOOTENV_DEV_NAME_##devtypeu(devtypeu, devtypel, instance)
 #define BOOTENV_BOOT_TARGETS \
 	"boot_targets=" BOOT_TARGET_DEVICES(BOOTENV_DEV_NAME) "\0"
+#ifndef BOOTENV_EXTRA_BOOT_PREFIXES
+#define BOOTENV_EXTRA_BOOT_PREFIXES ""
+#endif
+#ifndef BOOTENV_EXTRA_BOOT_SCRIPTS
+#define BOOTENV_EXTRA_BOOT_SCRIPTS ""
+#endif
 
 #define BOOTENV_DEV(devtypeu, devtypel, instance) \
 	BOOTENV_DEV_##devtypeu(devtypeu, devtypel, instance)
@@ -322,9 +328,9 @@
 	BOOTENV_SHARED_IDE \
 	BOOTENV_SHARED_UBIFS \
 	BOOTENV_SHARED_EFI \
-	"boot_prefixes=/ /boot/\0" \
-	"boot_scripts=boot.scr.uimg boot.scr\0" \
-	"boot_script_dhcp=boot.scr.uimg\0" \
+	"boot_prefixes=/boot/ /" BOOTENV_EXTRA_BOOT_PREFIXES "\0" \
+	"boot_scripts=boot.scr.uimg boot.scr" BOOTENV_EXTRA_BOOT_SCRIPTS "\0" \
+	"boot_script_dhcp=boot.scr.uimg" BOOTENV_EXTRA_BOOT_SCRIPTS "\0" \
 	BOOTENV_BOOT_TARGETS \
 	\
 	"boot_extlinux="                                                  \
@@ -341,6 +347,9 @@
 		"fi\0"                                                    \
 	\
 	"boot_a_script="                                                  \
+		"setenv disk ${devnum}; "                                 \
+		"setenv dtype ${devtype}; "                               \
+		"setenv bootpart ${distro_bootpart}; "                    \
 		"load ${devtype} ${devnum}:${distro_bootpart} "           \
 			"${scriptaddr} ${prefix}${script}; "              \
 		"source ${scriptaddr}\0"                                  \
diff -Nru u-boot-2017.07/include/configs/acl.h u-boot-imx6/include/configs/acl.h
--- u-boot-2017.07/include/configs/acl.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/acl.h	2018-08-27 21:35:37.754134514 +0300
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	6
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/a.h u-boot-imx6/include/configs/a.h
--- u-boot-2017.07/include/configs/a.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/a.h	2018-08-27 21:35:37.754134514 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices A board
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	0xffffffff
+
+#define CONFIG_CONSOLE_MUX
+
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#define BD_I2C_MASK	2
+#define BOOT_TARGET_DEVICES(func) \
+	DISTRO_BOOT_DEV_USB(func) \
+	DISTRO_BOOT_DEV_MMC(func)
+#define BD_USB_START 	"setexpr otgstat *0x020c9030 \\\\& 0x08000000;" \
+				"if itest.l ${otgstat} -eq 0 ; then " \
+					"usb start;" \
+				"fi ;"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"cmd_custom= \0" \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ap.h u-boot-imx6/include/configs/ap.h
--- u-boot-2017.07/include/configs/ap.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ap.h	2018-08-27 21:35:37.757467832 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6_max
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ash2.h u-boot-imx6/include/configs/ash2.h
--- u-boot-2017.07/include/configs/ash2.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ash2.h	2018-08-27 21:35:37.757467832 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Ash
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_MXC_SPI_DISPLAY
+#define CONFIG_VIDEO_SKIP_VERSION
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ash.h u-boot-imx6/include/configs/ash.h
--- u-boot-2017.07/include/configs/ash.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ash.h	2018-08-27 21:35:37.757467832 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Ash
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_MXC_SPI_DISPLAY
+#define CONFIG_VIDEO_SKIP_VERSION
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/boundary.h u-boot-imx6/include/configs/boundary.h
--- u-boot-2017.07/include/configs/boundary.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/boundary.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,505 @@
+/*
+ * common configuration settings for the Boundary Devices boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __BOUNDARY_H
+#define __BOUNDARY_H
+
+#ifdef CONFIG_BOARD_TYPE
+#undef CONFIG_SYS_BOARD
+#define CONFIG_SYS_BOARD CONFIG_BOARD_TYPE
+#endif
+#include <config_distro_defaults.h>
+
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOARD_LATE_INIT
+
+#ifndef CONFIG_SYS_MALLOC_LEN
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(12 * 1024 * 1024)
+#endif
+
+#define CONFIG_MXC_UART
+#ifndef CONFIG_MXC_UART_BASE
+#define CONFIG_MXC_UART_BASE		UART2_BASE
+#endif
+
+/* Secure boot (HAB) support */
+#ifdef CONFIG_SECURE_BOOT
+#define CONFIG_CSF_SIZE			0x2000
+#define CONFIG_SYS_FSL_SEC_COMPAT	4
+#define CONFIG_CMD_DEKBLOB
+#endif
+
+/* SPL magic */
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_TEXT_BASE		0x00908400
+#define CONFIG_SPL_PAD_TO 0x400
+#define CONFIG_SPL_START_S_PATH		"arch/arm/cpu/armv7"
+#define CONFIG_SPL_STACK		0x0091FFB8
+
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_USB
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+
+/* SPI flash. */
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		0
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x20000
+
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SYS_SPL_MALLOC_START	0x00916000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x2000
+#endif
+
+/* I2C Configs */
+#ifdef BD_I2C_MASK
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#if (BD_I2C_MASK & 1)
+#define CONFIG_SYS_I2C_MXC_I2C1
+#endif
+#if (BD_I2C_MASK & 2)
+#define CONFIG_SYS_I2C_MXC_I2C2
+#endif
+#if (BD_I2C_MASK & 4)
+#define CONFIG_SYS_I2C_MXC_I2C3
+#endif
+#if (BD_I2C_MASK & 8)
+#define CONFIG_SYS_I2C_MXC_I2C4
+#endif
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_I2C_EDID
+#endif
+
+/* MMC Configs */
+#ifdef CONFIG_SYS_FSL_USDHC_NUM
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#endif
+
+#ifdef CONFIG_CMD_SF
+#ifndef CONFIG_FSL_QSPI
+#define CONFIG_MXC_SPI
+#endif
+#define CONFIG_SF_DEFAULT_BUS  0
+#ifndef CONFIG_SF_DEFAULT_CS
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+#ifndef CONFIG_SF_DEFAULT_SPEED
+#define CONFIG_SF_DEFAULT_SPEED 25000000
+#endif
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_PHY_MICREL
+#endif
+
+#if defined(CONFIG_PHY_ATHEROS) || defined(CONFIG_PHY_MICREL_KSZ9021)
+#define CONFIG_PHYLIB
+#define CONFIG_FEC_MXC
+
+#ifndef CONFIG_FEC_MXC_PHYADDR
+#define CONFIG_FEC_MXC_PHYADDR		6
+#endif
+
+#define CONFIG_MII
+#ifndef IMX_FEC_BASE
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#endif
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#ifdef CONFIG_RGMII2
+#define CONFIG_ETHPRIME			"FEC0"
+#else
+#define CONFIG_ETHPRIME			"FEC"
+#endif
+
+#ifndef GP_RGMII_PHY_RESET
+#ifdef CONFIG_MX6SX
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(2, 7)
+#define GP_RGMII2_PHY_RESET	IMX_GPIO_NR(2, 6)
+#elif defined(CONFIG_MX7D)
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(6, 10)
+#elif defined(CONFIG_MX51)
+#else
+#define GP_RGMII_PHY_RESET	IMX_GPIO_NR(1, 27)
+#endif
+#endif
+
+#endif
+
+/*
+ * SATA Configs
+ */
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+/* USB gadget support */
+#ifdef CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_ETHER
+#define CONFIG_USB_ETH_CDC
+#define CONFIG_NETCONSOLE
+#endif
+
+/* USB Configs */
+#ifdef CONFIG_USB_MAX_CONTROLLER_COUNT
+#if defined(CONFIG_MX51) || defined(CONFIG_MX53)
+#define CONFIG_USB_EHCI_MX5
+#endif
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_USB_ETHER_MCS7830
+#define CONFIG_USB_ETHER_SMSC95XX
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET	/* For OTG port */
+#ifndef CONFIG_MXC_USB_PORTSC
+#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
+#endif
+#ifndef CONFIG_MXC_USB_FLAGS
+#define CONFIG_MXC_USB_FLAGS	0
+#endif
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+#endif
+
+/* Framebuffer and LCD */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_VIDEO_BMP_GZIP
+#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE (6 * 1024 * 1024)
+#define CONFIG_BMP_16BPP
+#define CONFIG_CMD_FBPANEL
+#if defined(CONFIG_MX6SX)
+#define CONFIG_VIDEO_MXS
+#define MXS_LCDIF_BASE MX6SX_LCDIF1_BASE_ADDR
+#elif defined(CONFIG_MX7D)
+#define CONFIG_VIDEO_MXS
+#else
+#define CONFIG_VIDEO_IPUV3
+#ifdef CONFIG_MX51
+#define CONFIG_IPUV3_CLK 133000000
+#elif defined(CONFIG_MX53)
+#define CONFIG_IPUV3_CLK 200000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#endif
+#endif
+
+#ifndef CONFIG_PREBOOT
+#define CONFIG_PREBOOT                 ""
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define DISTRO_BOOT_DEV_SATA(func) func(SATA, sata, 0)
+#else
+#define DISTRO_BOOT_DEV_SATA(func)
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#if (CONFIG_SYS_FSL_USDHC_NUM == 1)
+#define DISTRO_BOOT_DEV_MMC(func) func(MMC, mmc, 0)
+#elif (CONFIG_SYS_FSL_USDHC_NUM == 2)
+#define DISTRO_BOOT_DEV_MMC(func) func(MMC, mmc, 0) func(MMC, mmc, 1)
+#else
+#define DISTRO_BOOT_DEV_MMC(func) func(MMC, mmc, 0) func(MMC, mmc, 1) func(MMC, mmc, 2)
+#endif
+#else
+#define DISTRO_BOOT_DEV_MMC(func)
+#endif
+
+#ifndef BD_FASTBOOT_FLASH_MMC_DEV
+#if (CONFIG_SYS_FSL_USDHC_NUM == 1)
+#define BD_FASTBOOT_FLASH_MMC_DEV   0
+#elif (CONFIG_SYS_FSL_USDHC_NUM == 2)
+#define BD_FASTBOOT_FLASH_MMC_DEV   1
+#else
+#define BD_FASTBOOT_FLASH_MMC_DEV   2
+#endif
+#endif
+
+#ifdef CONFIG_USB_STORAGE
+#define DISTRO_BOOT_DEV_USB(func) func(USB, usb, 0)
+#else
+#define DISTRO_BOOT_DEV_USB(func)
+#endif
+
+#ifndef BD_CONSOLE
+#if CONFIG_MXC_UART_BASE == UART2_BASE
+#define BD_CONSOLE	"ttymxc1"
+#elif CONFIG_MXC_UART_BASE == UART1_BASE
+#define BD_CONSOLE	"ttymxc0"
+#endif
+#endif
+
+#ifndef BD_CONSOLE_STR
+#define BD_CONSOLE_STR	"console=" BD_CONSOLE "\0"
+#endif
+
+#if defined(CONFIG_VIDEO) && !defined(BD_NOVIDEO_CONSOLE)
+#define BD_STDOUT_SERIAL	"setenv stdout serial;"
+#define BD_STDOUT_VIDEO		"setenv stdout serial,vga; "
+#define BD_STDIN_USBKBD		"setenv stdin serial,usbkbd;"
+#else
+#define BD_STDOUT_SERIAL
+#define BD_STDOUT_VIDEO
+#define BD_STDIN_USBKBD
+#endif
+
+#ifndef BD_SPLASH_FLASH
+#define BD_SPLASH_FLASH	"c2000"
+#endif
+
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX7D)
+#define BD_RAM_BASE	0x80000000
+#define BD_RAM_SCRIPT	"80008000"
+#define BD_RAM_KERNEL	"80800000"
+#define BD_RAM_RAMDISK	"82800000"
+#define BD_RAM_FDT	"83000000"
+#elif defined(CONFIG_MX51)
+#define BD_RAM_BASE	0x90000000
+#define BD_RAM_SCRIPT	"90008000"
+#define BD_RAM_KERNEL	"90800000"
+#define BD_RAM_RAMDISK	"92800000"
+#define BD_RAM_FDT	"93000000"
+#elif defined(CONFIG_MX53)
+#define BD_RAM_BASE	0x70000000
+#define BD_RAM_SCRIPT	"70008000"
+#define BD_RAM_KERNEL	"70800000"
+#define BD_RAM_RAMDISK	"72800000"
+#define BD_RAM_FDT	"73000000"
+#else
+#define BD_RAM_BASE	0x10000000
+#define BD_RAM_SCRIPT	"10008000"
+#define BD_RAM_KERNEL	"10800000"
+#define BD_RAM_RAMDISK	"12800000"
+#define BD_RAM_FDT	"13000000"
+#endif
+
+#ifndef BD_SKIP_FUSES
+#ifndef BD_FUSE1
+#if defined(CONFIG_MX6SX)
+#define BD_FUSE1		"0 5"
+#define BD_FUSE1_VAL		"08000030"	/* CS0 */
+#define BD_FUSE2		"0 6"
+#define BD_FUSE2_VAL		"00000010"
+#elif defined(CONFIG_MX6Q) || defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
+#define BD_FUSE1		"0 5"
+#define BD_FUSE1_VAL		"18000030"	/* CS1 */
+#define BD_FUSE2		"0 6"
+#define BD_FUSE2_VAL		"00000010"
+#elif defined(CONFIG_MX7D)
+#define BD_FUSE1		"1 3"
+#define BD_FUSE1_VAL		"10004000"	/* QSPI */
+#endif
+#endif
+
+#ifndef BD_FUSE_MAC1A
+#if defined(CONFIG_MX7D)
+#define BD_FUSE_MAC1A		"9 1"
+#define BD_FUSE_MAC1A_VAL	"00000019"
+#define BD_FUSE_MAC1B		"9 0"
+#else
+#define BD_FUSE_MAC1A		"4 3"
+#define BD_FUSE_MAC1A_VAL	"00000019"
+#define BD_FUSE_MAC1B		"4 2"
+#endif
+#endif
+#endif
+
+#ifdef BD_FUSE1
+#define BD_FUSE1_STR		"fuse1=" BD_FUSE1 "\0"
+#define BD_FUSE1_VAL_STR	"fuse1_val=" BD_FUSE1_VAL "\0"
+#else
+#define BD_FUSE1_STR		""
+#define BD_FUSE1_VAL_STR	""
+#endif
+
+#ifdef BD_FUSE2
+#define BD_FUSE2_STR		"fuse2=" BD_FUSE2 "\0"
+#define BD_FUSE2_VAL_STR	"fuse2_val=" BD_FUSE2_VAL "\0"
+#else
+#define BD_FUSE2_STR		""
+#define BD_FUSE2_VAL_STR	""
+#endif
+
+#ifdef BD_FUSE_MAC1A
+#define BD_FUSE_MAC1A_STR	"fuse_mac1a=" BD_FUSE_MAC1A "\0"
+#define BD_FUSE_MAC1A_VAL_STR	"fuse_mac1a_val=" BD_FUSE_MAC1A_VAL "\0"
+#define BD_FUSE_MAC1B_STR	"fuse_mac1b=" BD_FUSE_MAC1B "\0"
+#else
+#define BD_FUSE_MAC1A_STR	""
+#define BD_FUSE_MAC1A_VAL_STR	""
+#define BD_FUSE_MAC1B_STR	""
+#endif
+
+#ifndef BOOT_TARGET_DEVICES
+#define BOOT_TARGET_DEVICES(func) \
+	DISTRO_BOOT_DEV_MMC(func) \
+	DISTRO_BOOT_DEV_SATA(func) \
+	DISTRO_BOOT_DEV_USB(func)
+#endif
+
+#define BOOTENV_EXTRA_BOOT_SCRIPTS " 6x_bootscript "
+
+#include <config_distro_bootcmd.h>
+
+#ifdef BD_LOG_LEVEL
+#define LOG_LEVEL_STR "loglevel=" BD_LOG_LEVEL "\0"
+#else
+#define LOG_LEVEL_STR ""
+#endif
+
+#ifdef BD_CMA
+#define LOG_CMA_STR "cma=" BD_CMA "\0"
+#else
+#define LOG_CMA_STR ""
+#endif
+
+#ifndef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_OFFSET		0xc0000
+#endif
+
+#define BD_BOUNDARY_ENV_SETTINGS \
+	"clearenv=if sf probe || sf probe ; then " \
+		"sf erase " __stringify(CONFIG_ENV_OFFSET) " 0x2000 && " \
+		"echo restored environment to factory default ; fi\0" \
+	LOG_CMA_STR \
+	BD_CONSOLE_STR \
+	"dfu_alt_info=u-boot raw 0x0 0xc0000\0" \
+	"fdt_addr=" BD_RAM_FDT "\0" \
+	"fdt_high=0xffffffff\0" \
+	BD_FUSE1_STR \
+	BD_FUSE1_VAL_STR \
+	BD_FUSE2_STR \
+	BD_FUSE2_VAL_STR \
+	BD_FUSE_MAC1A_STR \
+	BD_FUSE_MAC1A_VAL_STR \
+	BD_FUSE_MAC1B_STR \
+	"initrd_high=0xffffffff\0" \
+	"loadsplash=if sf probe ; then sf read ${splashimage} ${splashflash} ${splashsize} ; fi\0" \
+	LOG_LEVEL_STR \
+	"net_fuses=dhcp " BD_RAM_SCRIPT " prog_fuses.scr && source " BD_RAM_SCRIPT "\0" \
+	"net_program=next=prog_fuses.scr; run net_upgradeu\0" \
+	"net_upgradeu=dhcp " BD_RAM_SCRIPT " net_upgradeu.scr && source " BD_RAM_SCRIPT "\0" \
+	"rundfu=dfu 0 sf 0:0:25000000:0\0" \
+	"otg_fuses=run usbnetwork; tftp " BD_RAM_SCRIPT " prog_fuses.scr && source " BD_RAM_SCRIPT "\0" \
+	"otg_program=next=prog_fuses.scr; run otg_upgradeu\0" \
+	"otg_upgradeu=run usbnetwork; tftp " BD_RAM_SCRIPT " net_upgradeu.scr && source " BD_RAM_SCRIPT "\0" \
+	"program=next=prog_fuses.scr; run upgradeu\0" \
+	"scriptaddr=" BD_RAM_SCRIPT "\0" \
+	"splashflash=" BD_SPLASH_FLASH "\0" \
+	"uboot_defconfig=" CONFIG_DEFCONFIG "\0" \
+	"upgradeu=setenv boot_scripts upgrade.scr; boot\0" \
+	"usb_pgood_delay=2000\0" \
+	"usbnet_devaddr=00:19:b8:00:00:02\0" \
+	"usbnet_hostaddr=00:19:b8:00:00:01\0" \
+	"usbnetwork=setenv ethact usb_ether; " \
+		"setenv ipaddr 10.0.0.2; " \
+		"setenv netmask 255.255.255.0; " \
+		"setenv serverip 10.0.0.1;\0" \
+	"usbrecover=run usbnetwork;" \
+		"setenv bootargs console=${console},115200; " \
+		"tftpboot " BD_RAM_KERNEL " 10.0.0.1:uImage-${board}-recovery && " \
+		"tftpboot " BD_RAM_RAMDISK " 10.0.0.1:uramdisk-${board}-recovery.img && " \
+		"bootm " BD_RAM_KERNEL " " BD_RAM_RAMDISK "\0" \
+	BOOTENV
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_MEMTEST_START       BD_RAM_BASE
+#define CONFIG_SYS_MEMTEST_END	       (BD_RAM_BASE + 0x00010000)
+#define CONFIG_SYS_MEMTEST_SCRATCH     (BD_RAM_BASE + 0x00800000)
+#define CONFIG_SYS_ALT_MEMTEST
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS	       1
+#if defined(CONFIG_MX51) || defined(CONFIG_MX53)
+#define PHYS_SDRAM		       CSD0_BASE_ADDR
+#else
+#define PHYS_SDRAM		       MMDC0_ARB_BASE_ADDR
+#endif
+
+#define CONFIG_RESET_CAUSE_ADDR	       (PHYS_SDRAM + 0x80)
+
+#define CONFIG_SYS_SDRAM_BASE	       PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#ifndef CONFIG_ENV_IS_NOWHERE
+#ifndef CONFIG_ENV_IS_IN_MMC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#undef CONFIG_ENV_OFFSET
+#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(8 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+#endif
+
+/*
+ * PCI express
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#endif
+
+#define CONFIG_CMD_UNZIP
+
+#ifdef CONFIG_CI_UDC
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_USB_FUNCTION_FASTBOOT
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_FASTBOOT_BUF_SIZE   0x26000000
+#define CONFIG_FASTBOOT_FLASH
+#define CONFIG_FASTBOOT_FLASH_MMC_DEV   BD_FASTBOOT_FLASH_MMC_DEV
+#define CONFIG_CMD_GPT
+#define CONFIG_CMD_PART
+
+/* USB Device Firmware Update support */
+#define CONFIG_USB_FUNCTION_DFU
+#define CONFIG_DFU_SF
+#define CONFIG_CMD_DFU
+#define CONFIG_SYS_DFU_DATA_BUF_SIZE	0xc0000
+#define DFU_MANIFEST_POLL_TIMEOUT	25000
+#endif
+
+#endif
diff -Nru u-boot-2017.07/include/configs/bt.h u-boot-imx6/include/configs/bt.h
--- u-boot-2017.07/include/configs/bt.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/bt.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices bt
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3780
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_CMA		"384M"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"cmd_custom=setenv bootargs $bootargs pci=nomsi pcie.force_gen=1 coherent_pool=32M\0" \
+
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cad.h u-boot-imx6/include/configs/cad.h
--- u-boot-2017.07/include/configs/cad.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cad.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X
+ * and Freescale i.MX6Q Sabre Lite boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3774
+
+#define CONFIG_ETHPRIME			"usb_ether"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PREBOOT	"if itest.s  \"\" != \"$splashsize\" ; then " \
+				"sf probe && " \
+				"sf read $splashimage $splashflash $splashsize && " \
+				"bmp d $splashimage ;" \
+			"fi"
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#define BD_I2C_MASK	7
+#define BD_SPLASH_FLASH	"f0000"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"novideo=1\0" \
+	"savesplash=script=/savesplash; run runscript\0" \
+	"splashimage=0x10008000\0" \
+	"splashpos=m,m\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cid.h u-boot-imx6/include/configs/cid.h
--- u-boot-2017.07/include/configs/cid.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cid.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X-Lite
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+#define CONFIG_HW_WATCHDOG
+#define CONFIG_SYS_BOOT_BOARD_POWER_CHECK
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define CONFIG_FEC_MAC_FUSE
+
+#define BOOT_TARGET_DEVICES(func) func(MMC, mmc, 1)
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"cmd_custom= \0" \
+	"magic_keys=12\0" \
+	"key_magic1=pr\0" \
+	"key_cmd1=echo Starting fastboot; fastboot 0\0" \
+	"key_magic2=t\0" \
+	"key_cmd2=echo Starting fastboot; fastboot 0\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cid_tab.h u-boot-imx6/include/configs/cid_tab.h
--- u-boot-2017.07/include/configs/cid_tab.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cid_tab.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X-Lite
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK  66000000
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#define BOOT_TARGET_DEVICES(func) func(MMC, mmc, 1)
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"magic_keys=12\0" \
+	"key_magic1=r+\0" \
+	"key_cmd1=echo Starting fastboot; fastboot 0\0" \
+	"key_magic2=t\0" \
+	"key_cmd2=echo Starting fastboot; fastboot 0\0" \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cnt.h u-boot-imx6/include/configs/cnt.h
--- u-boot-2017.07/include/configs/cnt.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cnt.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices CNT board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_BOOTDELAY	1
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#define BOOT_TARGET_DEVICES(func) \
+	DISTRO_BOOT_DEV_USB(func) \
+	DISTRO_BOOT_DEV_MMC(func)
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cob2.h u-boot-imx6/include/configs/cob2.h
--- u-boot-2017.07/include/configs/cob2.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cob2.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices cob
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK  66000000
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_SKIP_FUSES
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/cob.h u-boot-imx6/include/configs/cob.h
--- u-boot-2017.07/include/configs/cob.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/cob.h	2018-08-27 21:35:37.760801149 +0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices cob
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_ETHPRIME		"usbnet"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_PWM_IMX
+#define CONFIG_IMX6_PWM_PER_CLK  66000000
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_SKIP_FUSES
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/dash.h u-boot-imx6/include/configs/dash.h
--- u-boot-2017.07/include/configs/dash.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/dash.h	2018-08-27 21:35:37.764134467 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices DASH board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_ETHPRIME			"usb_ether"
+#define CONFIG_FEC_MAC_FUSE
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/eo.h u-boot-imx6/include/configs/eo.h
--- u-boot-2017.07/include/configs/eo.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/eo.h	2018-08-27 21:35:37.764134467 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices eo board
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_fec=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/h4.h u-boot-imx6/include/configs/h4.h
--- u-boot-2017.07/include/configs/h4.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/h4.h	2018-08-27 21:35:37.774134420 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices H4
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_ETHPRIME			"usbnet"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/h.h u-boot-imx6/include/configs/h.h
--- u-boot-2017.07/include/configs/h.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/h.h	2018-08-27 21:35:37.774134420 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices H board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/hl.h u-boot-imx6/include/configs/hl.h
--- u-boot-2017.07/include/configs/hl.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/hl.h	2018-08-27 21:35:37.774134420 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X-Lite
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/hp.h u-boot-imx6/include/configs/hp.h
--- u-boot-2017.07/include/configs/hp.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/hp.h	2018-08-27 21:35:37.774134420 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices hp
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3978
+
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_SYS_BOOT_BOARD_POWER_CHECK
+
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/insp.h u-boot-imx6/include/configs/insp.h
--- u-boot-2017.07/include/configs/insp.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/insp.h	2018-08-27 21:35:37.780801055 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices INSP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_FEC_MAC_FUSE
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"allow_noncea=1\0" \
+	"bootdelay=1\0" \
+	"preboot=if itest 0 != 0x$splashsize ; then sf probe && sf read ${splashimage} ${splashflash} $splashsize && bmp d ${splashimage} ; fi\0" \
+	"splashimage=0x10008000\0" \
+	"splashsize=2b7a\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ioc.h u-boot-imx6/include/configs/ioc.h
--- u-boot-2017.07/include/configs/ioc.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ioc.h	2018-08-27 21:35:37.780801055 +0300
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices ioc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"fb_lvds=AA065VE11\0" \
+	"panel=AA065VE11\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/jlm.h u-boot-imx6/include/configs/jlm.h
--- u-boot-2017.07/include/configs/jlm.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/jlm.h	2018-08-27 21:35:37.780801055 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X
+ * and Freescale i.MX6Q Sabre Lite boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_FEC_MAC_FUSE
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ls.h u-boot-imx6/include/configs/ls.h
--- u-boot-2017.07/include/configs/ls.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ls.h	2018-08-27 21:35:37.787467689 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices LS board
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_ETHPRIME	"usbnet"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/lshore.h u-boot-imx6/include/configs/lshore.h
--- u-boot-2017.07/include/configs/lshore.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/lshore.h	2018-08-27 21:35:37.787467689 +0300
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices L-Shore
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_BOOTDELAY	1
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "0"
+
+#undef CONFIG_SYS_BOARD
+#define BOOT_TARGET_DEVICES(func) \
+	DISTRO_BOOT_DEV_USB(func) \
+	DISTRO_BOOT_DEV_MMC(func)
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ltch.h u-boot-imx6/include/configs/ltch.h
--- u-boot-2017.07/include/configs/ltch.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ltch.h	2018-08-27 21:35:37.787467689 +0300
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 Boundary Devices <info@boundarydevices.com>
+ *
+ * Configuration settings for the Boundary Devices ltch
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/mcs.h u-boot-imx6/include/configs/mcs.h
--- u-boot-2017.07/include/configs/mcs.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/mcs.h	2018-08-27 21:35:37.790801007 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices MCS board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_PREBOOT	"if itest.s  \"\" != \"$bmpsize\" ; then " \
+				"sf probe && " \
+				"sf read ${splashimage} ${splashflash} $bmpsize" \
+				" && bmp d 10008000;" \
+			"fi"
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_SPLASH_FLASH "f0000"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+	"savesplash=script=/savesplash; run runscript\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/med.h u-boot-imx6/include/configs/med.h
--- u-boot-2017.07/include/configs/med.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/med.h	2018-08-27 21:35:37.790801007 +0300
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X
+ * and Freescale i.MX6Q Sabre Lite boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3774
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_FEC_MXC_PHYADDR		7
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_PREBOOT	"if itest.s x != x$splashsize ; then " \
+				"sf probe && " \
+				"sf read $splashimage $splashflash $splashsize" \
+				" && bmp d $splashimage;" \
+			"fi"
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1"
+#define BD_SPLASH_FLASH "f0000"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"netrecover=setenv ethact FEC; " \
+		"setenv bootargs console=ttymxc1,115200; " \
+		"dhcp 10800000 $serverip:uImage-${board}-recovery" \
+		"&& dhcp 12800000 $serverip:uramdisk-${board}-recovery.img " \
+		"&& bootm 10800000 12800000\0" \
+	"novideo=1\0" \
+	"savesplash=script=/savesplash; run runscript\0" \
+	"splashpos=m,m\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/mtp.h u-boot-imx6/include/configs/mtp.h
--- u-boot-2017.07/include/configs/mtp.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/mtp.h	2018-08-27 21:35:37.790801007 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices mtp
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3779
+
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_IPUV3_CLK 264000000
+#define CONFIG_CONSOLE_MUX
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"cmd_custom= \0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/mx6_r.h u-boot-imx6/include/configs/mx6_r.h
--- u-boot-2017.07/include/configs/mx6_r.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/mx6_r.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X
+ * and Freescale i.MX6Q Sabre Lite boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3774
+
+#define CONFIG_ETHPRIME			"usb_ether"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_MXC_SPI_DISPLAY
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/mx7_common.h u-boot-imx6/include/configs/mx7_common.h
--- u-boot-2017.07/include/configs/mx7_common.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/configs/mx7_common.h	2018-08-27 21:35:37.794134324 +0300
@@ -36,6 +36,9 @@
 #define CONFIG_ENV_OVERWRITE
 #define CONFIG_CONS_INDEX               1
 
+/* Filesystems and image support */
+#define CONFIG_SUPPORT_RAW_INITRD
+ 
 /* Miscellaneous configurable options */
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_CMDLINE_EDITING
diff -Nru u-boot-2017.07/include/configs/neol.h u-boot-imx6/include/configs/neol.h
--- u-boot-2017.07/include/configs/neol.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/neol.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices Neol
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nit6xlite.h u-boot-imx6/include/configs/nit6xlite.h
--- u-boot-2017.07/include/configs/nit6xlite.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nit6xlite.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X-Lite
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen51_e.h u-boot-imx6/include/configs/nitrogen51_e.h
--- u-boot-2017.07/include/configs/nitrogen51_e.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen51_e.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2018 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices nitrogen51_e
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/***********************************/
+
+#define CONFIG_SYS_BOOTM_LEN	0x1000000
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SYS_FSL_CLK
+
+/* ATAGs */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_LOADADDR		0x92000000
+#define CONFIG_SYS_TEXT_BASE	0x97800000
+#define CONFIG_SYS_LOAD_ADDR	CONFIG_LOADADDR
+
+#ifndef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY        3
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX       1
+#define CONFIG_BAUDRATE         115200
+
+/* Filesystems and image support */
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Miscellaneous configurable options */
+#undef CONFIG_CMD_IMLS
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE       512
+#define CONFIG_SYS_MAXARGS      32
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+
+/* GPIO */
+#define CONFIG_MXC_GPIO
+
+/* MMC */
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FSL_ESDHC
+#define ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE
+#define CONFIG_SYS_FSL_ESDHC_ADDR	MMC_SDHC1_BASE_ADDR
+#define CONFIG_SYS_FSL_ESDHC_NUM	1
+
+/* Fuses */
+#define CONFIG_CMD_FUSE
+/************************************/
+#define CONFIG_FSL_IIM
+
+#define CONFIG_SYS_DDR_CLKSEL	0
+
+#define IMX_FEC_BASE		FEC_BASE_ADDR
+#define CONFIG_MII
+#if 1
+#define CONFIG_MXC_USB_PORT	1
+#define CONFIG_MXC_USB_PORTSC	PORT_PTS_ULPI
+#define CONFIG_MXC_USB_FLAGS	MXC_EHCI_POWER_PINS_ENABLED
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+#define CONFIG_SYS_CLKTL_CBCDR	0x59E35100
+
+#define CONFIG_MACH_TYPE	3169
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+#define CONFIG_SYS_ARM_PODF		0
+#define CONFIG_FSL_PMIC_BUS		0
+#define CONFIG_FSL_PMIC_CS		0
+#define CONFIG_FSL_PMIC_CLK		2500000
+#define CONFIG_FSL_PMIC_MODE		(SPI_MODE_0 | SPI_CS_HIGH)
+#define CONFIG_FSL_PMIC_BITLEN		32
+
+#define CONFIG_PHYLIB
+#define CONFIG_FEC_MXC
+#define CONFIG_FEC_MXC_PHYADDR		5
+#define ETH_PHY_MASK			(0xf << 4)
+
+/* PMIC Configs */
+#define CONFIG_POWER
+#define CONFIG_POWER_SPI
+#define CONFIG_POWER_FSL
+#define CONFIG_FSL_PMIC_BUS   0
+#define CONFIG_FSL_PMIC_CS    0
+#define CONFIG_SF_DEFAULT_CS   1
+
+#define CONFIG_FSL_PMIC_CLK   2500000
+#define CONFIG_FSL_PMIC_MODE  (SPI_MODE_0 | SPI_CS_HIGH)
+#define CONFIG_FSL_PMIC_BITLEN        32
+
+#define CONFIG_POWER_FSL_MC13892
+#define CONFIG_RTC_MC13XXX
+#if 0
+#define CONFIG_MMC_TRACE
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT 1
+#endif
+
+#if 1
+#define CONFIG_VIDEO_LOGO
+#endif
+#define BD_I2C_MASK	3
+#define BD_CONSOLE "ttymxc0"
+#define BD_MMC_DISKS "0"
+#define BD_FASTBOOT_FLASH_MMC_DEV   0
+#define BD_LOG_LEVEL	"7"
+#define BD_CMA		"2M"
+
+#ifdef CONFIG_SPI_FLASH_ATMEL
+/* only rev0 needs this for the small 512K at45db041d spi-nor */
+#define CONFIG_ENV_OFFSET		0x7e000
+#else
+/* default to no console */
+#define BD_CONSOLE_STR	""
+#endif
+
+
+#include "boundary.h"
+
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"fb_lcd=off\0" \
+	"fb_lcd2=off\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen51_vm.h u-boot-imx6/include/configs/nitrogen51_vm.h
--- u-boot-2017.07/include/configs/nitrogen51_vm.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen51_vm.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2017 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices nitrogen51_vm
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/***********************************/
+
+#define CONFIG_SYS_BOOTM_LEN	0x1000000
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_SYS_FSL_CLK
+
+/* ATAGs */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+#define CONFIG_LOADADDR		0x92000000
+#define CONFIG_SYS_TEXT_BASE	0x97800000
+#define CONFIG_SYS_LOAD_ADDR	CONFIG_LOADADDR
+
+#ifndef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY        3
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX       1
+#define CONFIG_BAUDRATE         115200
+
+/* Filesystems and image support */
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* Miscellaneous configurable options */
+#undef CONFIG_CMD_IMLS
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE       512
+#define CONFIG_SYS_MAXARGS      32
+#define CONFIG_SYS_BARGSIZE     CONFIG_SYS_CBSIZE
+
+/* GPIO */
+#define CONFIG_MXC_GPIO
+
+/* MMC */
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_FSL_ESDHC
+#define ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE
+#define CONFIG_SYS_FSL_ESDHC_ADDR	MMC_SDHC1_BASE_ADDR
+#define CONFIG_SYS_FSL_ESDHC_NUM	1
+
+/* Fuses */
+/* #define CONFIG_IIM_MAC_ADDR_INDEX	9 */
+#define CONFIG_CMD_FUSE
+/************************************/
+#define CONFIG_FSL_IIM
+
+#define CONFIG_SYS_DDR_CLKSEL	0
+
+#define IMX_FEC_BASE		FEC_BASE_ADDR
+#define CONFIG_MII
+#if 1
+#define CONFIG_MXC_USB_PORT	1
+#define CONFIG_MXC_USB_PORTSC	PORT_PTS_ULPI
+#define CONFIG_MXC_USB_FLAGS	MXC_EHCI_POWER_PINS_ENABLED
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+#define CONFIG_SYS_CLKTL_CBCDR	0x59E35100
+
+#define CONFIG_MACH_TYPE	3169
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+#define CONFIG_SYS_ARM_PODF		0
+#define CONFIG_FSL_PMIC_BUS		0
+#define CONFIG_FSL_PMIC_CS		0
+#define CONFIG_FSL_PMIC_CLK		2500000
+#define CONFIG_FSL_PMIC_MODE		(SPI_MODE_0 | SPI_CS_HIGH)
+#define CONFIG_FSL_PMIC_BITLEN		32
+
+#define CONFIG_PHYLIB
+#define CONFIG_FEC_MXC
+#define CONFIG_FEC_MXC_PHYADDR		5
+#define ETH_PHY_MASK			(0xf << 4)
+
+/* PMIC Configs */
+#define CONFIG_POWER
+#define CONFIG_POWER_SPI
+#define CONFIG_POWER_FSL
+#define CONFIG_FSL_PMIC_BUS   0
+#define CONFIG_FSL_PMIC_CS    0
+#define CONFIG_SF_DEFAULT_CS   1
+
+#define CONFIG_FSL_PMIC_CLK   2500000
+#define CONFIG_FSL_PMIC_MODE  (SPI_MODE_0 | SPI_CS_HIGH)
+#define CONFIG_FSL_PMIC_BITLEN        32
+
+#define CONFIG_POWER_FSL_MC13892
+#define CONFIG_RTC_MC13XXX
+#if 0
+#define CONFIG_MMC_TRACE
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT 1
+#endif
+
+#if 1
+#define CONFIG_VIDEO_LOGO
+#endif
+#define BD_I2C_MASK	3
+#define BD_CONSOLE "ttymxc0"
+#define BD_MMC_DISKS "0"
+#define BD_FASTBOOT_FLASH_MMC_DEV   0
+#define BD_LOG_LEVEL	"7"
+#define BD_CMA		"2M"
+
+#include "boundary.h"
+
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6_max.h u-boot-imx6/include/configs/nitrogen6_max.h
--- u-boot-2017.07/include/configs/nitrogen6_max.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6_max.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6_max
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6_scm.h u-boot-imx6/include/configs/nitrogen6_scm.h
--- u-boot-2017.07/include/configs/nitrogen6_scm.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6_scm.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6SX
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+#define CONFIG_ETHPRIME			"usb_ether"
+#define CONFIG_FEC_MAC_FUSE
+
+/* M4 specific */
+#define SYS_AUXCORE_BOOTDATA_DDR	0x9ff00000
+#define SYS_AUXCORE_BOOTDATA_OCRAM	0x00910000
+#define SYS_AUXCORE_BOOTDATA_TCM	0x007F8000
+#define EXTRA_ENV_M4 \
+	"m4image=m4_fw.bin\0" \
+	"m4offset=0x1e0000\0" \
+	"m4size=0x8000\0" \
+	"loadm4image=load ${dtype} ${disk}:1 ${loadaddr} ${m4image}\0" \
+	"m4update=for dtype in ${bootdevs}; do " \
+		"for disk in 0 1 ; do ${dtype} dev ${disk} ;" \
+			"if run loadm4image; then " \
+				"sf probe; " \
+				"sf erase ${m4offset} ${m4size}; " \
+				"sf write ${loadaddr} ${m4offset} ${filesize}; " \
+				"exit; " \
+			"fi; " \
+		"done; " \
+		"done\0" \
+	"m4loadaddr="__stringify(CONFIG_SYS_AUXCORE_BOOTDATA_TCM)"\0" \
+	"m4boot=run m4boot_nor\0" \
+	"m4boot_ext=load ${dtype} ${disk}:1 ${m4loadaddr} ${m4image}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4boot_nor=sf probe; sf read ${m4loadaddr} ${m4offset} ${m4size}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0"
+
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(4, 10)
+#define CONFIG_SYS_AUXCORE_BOOTDATA	0x900000	/* M4 specific */
+#define CONFIG_SYS_FSL_ESDHC_GPIO_WP
+#define CONFIG_SYS_SPD_BUS_NUM	1
+
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_CONSOLE	"ttymxc0"
+#define BD_I2C_MASK	0xf
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	EXTRA_ENV_M4
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6_som2.h u-boot-imx6/include/configs/nitrogen6_som2.h
--- u-boot-2017.07/include/configs/nitrogen6_som2.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6_som2.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6_som2
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6sx.h u-boot-imx6/include/configs/nitrogen6sx.h
--- u-boot-2017.07/include/configs/nitrogen6sx.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6sx.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6SX
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+/* M4 specific */
+#define SYS_AUXCORE_BOOTDATA_DDR	0x9ff00000
+#define SYS_AUXCORE_BOOTDATA_OCRAM	0x00910000
+#define SYS_AUXCORE_BOOTDATA_TCM	0x007F8000
+#define EXTRA_ENV_M4 \
+	"loadm4image=load ${devtype} ${devnum}:1 ${loadaddr} ${m4image}\0" \
+	"m4boot=run m4boot_nor\0" \
+	"m4boot_ext=load ${devtype} ${devnum}:1 ${m4loadaddr} ${m4image}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4boot_nor=sf probe; sf read ${m4loadaddr} ${m4offset} ${m4size}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4image=m4_fw.bin\0" \
+	"m4loadaddr="__stringify(SYS_AUXCORE_BOOTDATA_TCM)"\0" \
+	"m4loaddevs=mmc\0" \
+	"m4offset=0x1e0000\0" \
+	"m4size=0x8000\0" \
+	"m4update=for devtype in ${m4loaddevs}; do " \
+		"for devnum in 0 1 ; do ${devtype} dev ${devnum} ;" \
+			"if run loadm4image; then " \
+				"sf probe; " \
+				"sf erase ${m4offset} ${m4size}; " \
+				"sf write ${loadaddr} ${m4offset} ${filesize}; " \
+				"exit; " \
+			"fi; " \
+		"done; " \
+		"done\0"
+
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(4, 10)
+#define CONFIG_RGMII1
+#define CONFIG_RGMII2
+#define CONFIG_SYS_FSL_ESDHC_GPIO_WP
+#define ENET_MDIO_BASE			ENET_BASE_ADDR
+
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_CONSOLE	"ttymxc0"
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	EXTRA_ENV_M4
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6_vm.h u-boot-imx6/include/configs/nitrogen6_vm.h
--- u-boot-2017.07/include/configs/nitrogen6_vm.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6_vm.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices nitrogen6_vm
+ * board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen6x.h u-boot-imx6/include/configs/nitrogen6x.h
--- u-boot-2017.07/include/configs/nitrogen6x.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen6x.h	2018-08-27 21:35:37.794134324 +0300
@@ -11,115 +11,32 @@
 #define __CONFIG_H
 
 #include "mx6_common.h"
+#ifndef CONFIG_BOARD_TYPE
+#undef CONFIG_SYS_BOARD
+#endif
 
 #define CONFIG_MACH_TYPE	3769
 
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(10 * 1024 * 1024)
-
-#define CONFIG_MISC_INIT_R
-#define CONFIG_USBD_HS
-#define CONFIG_USB_ETHER
-#define CONFIG_USB_ETH_CDC
-#define CONFIG_NETCONSOLE
-
-#define CONFIG_MXC_UART
-#define CONFIG_MXC_UART_BASE	       UART2_BASE
-
-#ifdef CONFIG_CMD_SF
-#define CONFIG_MXC_SPI
-#define CONFIG_SF_DEFAULT_BUS  0
-#define CONFIG_SF_DEFAULT_CS   0
-#define CONFIG_SF_DEFAULT_SPEED 25000000
-#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
-#endif
-
-/* I2C Configs */
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_SPEED		100000
-#define CONFIG_I2C_EDID
-
-/* MMC Configs */
-#define CONFIG_SYS_FSL_ESDHC_ADDR      0
-#define CONFIG_SYS_FSL_USDHC_NUM       2
+#define CONFIG_MXC_SPI_DISPLAY
 
 #ifdef CONFIG_MX6Q
 #define CONFIG_CMD_SATA
 #endif
 
-/*
- * SATA Configs
- */
-#ifdef CONFIG_CMD_SATA
-#define CONFIG_DWC_AHSATA
-#define CONFIG_SYS_SATA_MAX_DEVICE	1
-#define CONFIG_DWC_AHSATA_PORT_ID	0
-#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
-#define CONFIG_LBA48
-#define CONFIG_LIBATA
-#endif
-
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define IMX_FEC_BASE			ENET_BASE_ADDR
-#define CONFIG_FEC_XCV_TYPE		RGMII
-#define CONFIG_ETHPRIME			"FEC"
-#define CONFIG_FEC_MXC_PHYADDR		6
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_MICREL
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
 #define CONFIG_PHY_MICREL_KSZ9021
+/* Sabrelite has different reset pin */
+#define GP_RGMII2_PHY_RESET	IMX_GPIO_NR(3, 23)
 
-/* USB Configs */
-#define CONFIG_USB_HOST_ETHER
-#define CONFIG_USB_ETHER_ASIX
-#define CONFIG_USB_ETHER_MCS7830
-#define CONFIG_USB_ETHER_SMSC95XX
+#define CONFIG_SYS_FSL_USDHC_NUM	2
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 2
-#define CONFIG_EHCI_HCD_INIT_AFTER_RESET	/* For OTG port */
-#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
-#define CONFIG_MXC_USB_FLAGS	0
-#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
-
-/* Framebuffer and LCD */
-#define CONFIG_VIDEO_IPUV3
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_VIDEO_BMP_GZIP
-#define CONFIG_SYS_VIDEO_LOGO_MAX_SIZE (6 * 1024 * 1024)
-#define CONFIG_BMP_16BPP
-#define CONFIG_IPUV3_CLK 260000000
-#define CONFIG_IMX_HDMI
-#define CONFIG_IMX_VIDEO_SKIP
-
-#define CONFIG_PREBOOT                 ""
-
-#ifdef CONFIG_CMD_SATA
-#define CONFIG_DRIVE_SATA "sata "
-#else
-#define CONFIG_DRIVE_SATA
-#endif
-
-#ifdef CONFIG_CMD_MMC
-#define CONFIG_DRIVE_MMC "mmc "
-#else
-#define CONFIG_DRIVE_MMC
-#endif
 
-#ifdef CONFIG_USB_STORAGE
-#define CONFIG_DRIVE_USB "usb "
-#else
-#define CONFIG_DRIVE_USB
-#endif
-
-#define CONFIG_DRIVE_TYPES CONFIG_DRIVE_SATA CONFIG_DRIVE_MMC CONFIG_DRIVE_USB
-#define CONFIG_UMSDEVS CONFIG_DRIVE_SATA CONFIG_DRIVE_MMC
+#define BD_I2C_MASK	7
 
 #if defined(CONFIG_SABRELITE)
+#define CONFIG_ENV_IS_IN_MMC
+#include "boundary.h"
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"uimage=uImage\0" \
@@ -130,7 +47,6 @@
 	"fdt_addr=0x18000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"usb_pgood_delay=2000\0" \
 	"mmcdevs=0 1\0" \
 	"mmcpart=1\0" \
 	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
@@ -197,117 +113,9 @@
 	"done; " \
 	"run netboot; "
 #else
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	"bootdevs=" CONFIG_DRIVE_TYPES "\0" \
-	"umsdevs=" CONFIG_UMSDEVS "\0" \
-	"usb_pgood_delay=2000\0" \
-	"console=ttymxc1\0" \
-	"clearenv=if sf probe || sf probe || sf probe 1 ; then " \
-		"sf erase 0xc0000 0x2000 && " \
-		"echo restored environment to factory default ; fi\0" \
-	"bootcmd=for dtype in ${bootdevs}" \
-		"; do " \
-			"if itest.s \"xusb\" == \"x${dtype}\" ; then " \
-				"usb start ;" \
-			"fi; " \
-			"for disk in 0 1 ; do ${dtype} dev ${disk} ;" \
-				"load " \
-					"${dtype} ${disk}:1 " \
-					"10008000 " \
-					"/6x_bootscript" \
-					"&& source 10008000 ; " \
-			"done ; " \
-		"done; " \
-		"setenv stdout serial,vga ; " \
-		"echo ; echo 6x_bootscript not found ; " \
-		"echo ; echo serial console at 115200, 8N1 ; echo ; " \
-		"echo details at http://boundarydevices.com/6q_bootscript ; " \
-		"setenv stdout serial;" \
-		"setenv stdin serial,usbkbd;" \
-		"for dtype in ${umsdevs} ; do " \
-			"if itest.s sata == ${dtype}; then " \
-				"initcmd='sata init' ;" \
-			"else " \
-				"initcmd='mmc rescan' ;" \
-			"fi; " \
-			"for disk in 0 1 ; do " \
-				"if $initcmd && $dtype dev $disk ; then " \
-					"setenv stdout serial,vga; " \
-					"echo expose ${dtype} ${disk} " \
-						"over USB; " \
-					"ums 0 $dtype $disk ;" \
-				"fi; " \
-		"	done; " \
-		"done ;" \
-		"setenv stdout serial,vga; " \
-		"echo no block devices found;" \
-		"\0" \
-	"initrd_high=0xffffffff\0" \
-	"upgradeu=for dtype in ${bootdevs}" \
-		"; do " \
-		"for disk in 0 1 ; do ${dtype} dev ${disk} ;" \
-			"load ${dtype} ${disk}:1 10008000 " \
-				"/6x_upgrade " \
-				"&& source 10008000 ; " \
-		"done ; " \
-	"done\0" \
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
 
 #endif
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_MEMTEST_START       0x10000000
-#define CONFIG_SYS_MEMTEST_END	       0x10010000
-#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
-
-/* Physical Memory Map */
-#define CONFIG_NR_DRAM_BANKS	       1
-#define PHYS_SDRAM		       MMDC0_ARB_BASE_ADDR
-
-#define CONFIG_SYS_SDRAM_BASE	       PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* Environment organization */
-#define CONFIG_ENV_SIZE			(8 * 1024)
-
-#if defined(CONFIG_SABRELITE)
-#define CONFIG_ENV_IS_IN_MMC
-#else
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#endif
-
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
-#define CONFIG_SYS_MMC_ENV_DEV		0
-#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
-#define CONFIG_ENV_OFFSET		(768 * 1024)
-#define CONFIG_ENV_SECT_SIZE		(8 * 1024)
-#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
-#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
-#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
-#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
-#endif
-
-#define CONFIG_SYS_ALT_MEMTEST
-
-/*
- * PCI express
- */
-#ifdef CONFIG_CMD_PCI
-#define CONFIG_PCI_SCAN_SHOW
-#define CONFIG_PCIE_IMX
-#endif
-
-#define CONFIG_USB_FUNCTION_MASS_STORAGE
-
-#define CONFIG_USB_FUNCTION_FASTBOOT
-#define CONFIG_CMD_FASTBOOT
-#define CONFIG_ANDROID_BOOT_IMAGE
-#define CONFIG_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
-#define CONFIG_FASTBOOT_BUF_SIZE   0x07000000
 
 #endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nitrogen7.h u-boot-imx6/include/configs/nitrogen7.h
--- u-boot-2017.07/include/configs/nitrogen7.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nitrogen7.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX7D SABRESD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __NITROGEN7_CONFIG_H
+#define __NITROGEN7_CONFIG_H
+
+#include "mx7_common.h"
+
+#define CONFIG_DBG_MONITOR
+#define PHYS_SDRAM_SIZE			SZ_1G
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_DFU_MMC
+
+/* ENET1 */
+#define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#ifdef CONFIG_SPI_FLASH
+#define CONFIG_FSL_QSPI
+/* #define CONFIG_SYS_FSL_QSPI_AHB */
+#define FSL_QSPI_FLASH_NUM		1
+#define FSL_QSPI_FLASH_SIZE		SZ_16M
+#endif
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#define CONFIG_SUPPORT_EMMC_BOOT	/* eMMC specific */
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#define CONFIG_FEC_MXC_PHYADDR          4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_MXC_UART_BASE            UART1_IPS_BASE_ADDR
+#define BD_CONSOLE	"ttymxc0"
+#define BD_I2C_MASK	0xf
+
+/* M4 specific */
+#define SYS_AUXCORE_BOOTDATA_DDR	0x9ff00000
+#define SYS_AUXCORE_BOOTDATA_OCRAM	0x00910000
+#define SYS_AUXCORE_BOOTDATA_QSPI	0x601e0000
+#define SYS_AUXCORE_BOOTDATA_TCM	0x007F8000
+#define EXTRA_ENV_M4 \
+	"loadm4image=load ${devtype} ${devnum}:1 ${loadaddr} ${m4image}\0" \
+	"m4boot=run m4boot_nor\0" \
+	"m4boot_ext=load ${devtype} ${devnum}:1 ${m4loadaddr} ${m4image}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4boot_nor=sf probe; sf read ${m4loadaddr} ${m4offset} ${m4size}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4boot_qspi=bootaux "__stringify(SYS_AUXCORE_BOOTDATA_QSPI)"\0" \
+	"m4image=m4_fw.bin\0" \
+	"m4loadaddr="__stringify(SYS_AUXCORE_BOOTDATA_TCM)"\0" \
+	"m4loaddevs=mmc\0" \
+	"m4offset=0x1e0000\0" \
+	"m4size=0x8000\0" \
+	"m4update=for devtype in ${m4loaddevs}; do " \
+		"for devnum in 0 1 ; do ${devtype} dev ${devnum} ;" \
+			"if run loadm4image; then " \
+				"sf probe; " \
+				"sf erase ${m4offset} ${m4size}; " \
+				"sf write ${loadaddr} ${m4offset} ${filesize}; " \
+				"exit; " \
+			"fi; " \
+		"done; " \
+		"done\0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"clk_ignore_unused "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+	EXTRA_ENV_M4
+
+#endif	/* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/nw.h u-boot-imx6/include/configs/nw.h
--- u-boot-2017.07/include/configs/nw.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/nw.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices NW board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_FEC_MAC_FUSE
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	3
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/oc.h u-boot-imx6/include/configs/oc.h
--- u-boot-2017.07/include/configs/oc.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/oc.h	2018-08-27 21:35:37.794134324 +0300
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Nitrogen6X
+ * and Freescale i.MX6Q Sabre Lite boards.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/per.h u-boot-imx6/include/configs/per.h
--- u-boot-2017.07/include/configs/per.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/per.h	2018-08-27 21:35:37.797467642 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices bt
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3781
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/rc.h u-boot-imx6/include/configs/rc.h
--- u-boot-2017.07/include/configs/rc.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/rc.h	2018-08-27 21:35:37.797467642 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices rc
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ses.h u-boot-imx6/include/configs/ses.h
--- u-boot-2017.07/include/configs/ses.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ses.h	2018-08-27 21:35:37.800800959 +0300
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018, Boundary Devices <info@boundarydevices.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(40 * 1024 * 1024)
+
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/s.h u-boot-imx6/include/configs/s.h
--- u-boot-2017.07/include/configs/s.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/s.h	2018-08-27 21:35:37.800800959 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices S board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_VIDEO_LOGO
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_MXC_UART_BASE		UART4_BASE
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_CONSOLE "ttymxc3"
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/snap.h u-boot-imx6/include/configs/snap.h
--- u-boot-2017.07/include/configs/snap.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/snap.h	2018-08-27 21:35:37.800800959 +0300
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices Snap board
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_CONSOLE_MUX
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_FEC_MXC_PHYADDR		7
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_DISKS "1"
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/sp.h u-boot-imx6/include/configs/sp.h
--- u-boot-2017.07/include/configs/sp.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/sp.h	2018-08-27 21:35:37.804134277 +0300
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices SP board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3771
+
+#define CONFIG_ETHPRIME	"usbnet"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BOOT_TARGET_DEVICES(func) DISTRO_BOOT_DEV_MMC(func)
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ta.h u-boot-imx6/include/configs/ta.h
--- u-boot-2017.07/include/configs/ta.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ta.h	2018-08-27 21:35:37.804134277 +0300
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices TA board
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_BOOTDELAY   1
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"bootdelay=1\0" \
+	"disable_giga=1\0" \
+	"fb_lvds=tm070jdhg30\0" \
+	"panel=tm070jdhg30\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/usd.h u-boot-imx6/include/configs/usd.h
--- u-boot-2017.07/include/configs/usd.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/usd.h	2018-08-27 21:35:37.807467595 +0300
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices usd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define GP_KS8995_POWER_DOWN		IMX_GPIO_NR(5, 7)
+#define GP_KS8995_RESET			IMX_GPIO_NR(5, 8)
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/usd_mr2.h u-boot-imx6/include/configs/usd_mr2.h
--- u-boot-2017.07/include/configs/usd_mr2.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/usd_mr2.h	2018-08-27 21:35:37.807467595 +0300
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices usd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3778
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+#define BD_MMC_UMS_DISKS "1 0"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"disable_giga=1\0" \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/utc.h u-boot-imx6/include/configs/utc.h
--- u-boot-2017.07/include/configs/utc.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/utc.h	2018-08-27 21:35:37.807467595 +0300
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices UTC board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_VIDEO_LOGO
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#define BOOT_TARGET_DEVICES(func) \
+	DISTRO_BOOT_DEV_MMC(func) \
+	DISTRO_BOOT_DEV_SATA(func) \
+
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/vp.h u-boot-imx6/include/configs/vp.h
--- u-boot-2017.07/include/configs/vp.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/vp.h	2018-08-27 21:35:37.807467595 +0300
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Boundary Devices VP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+#define CONFIG_ETHPRIME			"usb_ether"
+#define CONFIG_FEC_MAC_FUSE
+
+#define CONFIG_IMX_HDMI
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_I2C_MASK	7
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/configs/ys.h u-boot-imx6/include/configs/ys.h
--- u-boot-2017.07/include/configs/ys.h	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/include/configs/ys.h	2018-08-27 21:35:37.810800911 +0300
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 Boundary Devices, Inc.
+ *
+ * Configuration settings for the Boundary Devices YS
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_MACH_TYPE	3769
+
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+
+/* M4 specific */
+#define SYS_AUXCORE_BOOTDATA_DDR		0x9ff00000
+#define SYS_AUXCORE_BOOTDATA_OCRAM	0x00910000
+#define SYS_AUXCORE_BOOTDATA_TCM		0x007F8000
+#define EXTRA_ENV_M4 \
+	"m4image=m4_fw.bin\0" \
+	"m4offset=0x1e0000\0" \
+	"m4size=0x8000\0" \
+	"loadm4image=load ${dtype} ${disk}:1 ${loadaddr} ${m4image}\0" \
+	"m4update=for dtype in ${bootdevs}; do " \
+		"for disk in 0 1 ; do ${dtype} dev ${disk} ;" \
+			"if run loadm4image; then " \
+				"sf probe; " \
+				"sf erase ${m4offset} ${m4size}; " \
+				"sf write ${loadaddr} ${m4offset} ${filesize}; " \
+				"exit; " \
+			"fi; " \
+		"done; " \
+		"done\0" \
+	"m4loadaddr="__stringify(CONFIG_SYS_AUXCORE_BOOTDATA_TCM)"\0" \
+	"m4boot=run m4boot_nor\0" \
+	"m4boot_ext=load ${dtype} ${disk}:1 ${m4loadaddr} ${m4image}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0" \
+	"m4boot_nor=sf probe; sf read ${m4loadaddr} ${m4offset} ${m4size}; " \
+		"dcache flush; bootaux ${m4loadaddr}\0"
+
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(4, 10)
+#define CONFIG_RGMII1
+#define CONFIG_RGMII2
+#define CONFIG_SYS_FSL_ESDHC_GPIO_WP
+#define ENET_MDIO_BASE			ENET_BASE_ADDR
+
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+#define CONFIG_FEC_MXC_PHYADDR		4
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define BD_CONSOLE	"ttymxc0"
+#define BD_I2C_MASK	7
+#define BD_LOG_LEVEL	"7"
+#define BD_CMA		"2M"
+
+#include "boundary.h"
+#define CONFIG_EXTRA_ENV_SETTINGS BD_BOUNDARY_ENV_SETTINGS \
+	"cmd_custom= \0" \
+	EXTRA_ENV_M4
+
+#endif	       /* __CONFIG_H */
diff -Nru u-boot-2017.07/include/env_callback.h u-boot-imx6/include/env_callback.h
--- u-boot-2017.07/include/env_callback.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/env_callback.h	2018-08-27 21:35:37.820800864 +0300
@@ -72,6 +72,7 @@
 	SILENT_CALLBACK \
 	SPLASHIMAGE_CALLBACK \
 	"stdin:console,stdout:console,stderr:console," \
+	"serial#:serialno," \
 	CONFIG_ENV_CALLBACK_LIST_STATIC
 
 struct env_clbk_tbl {
diff -Nru u-boot-2017.07/include/fsl_esdhc.h u-boot-imx6/include/fsl_esdhc.h
--- u-boot-2017.07/include/fsl_esdhc.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/fsl_esdhc.h	2018-08-27 21:35:37.824134182 +0300
@@ -174,11 +174,18 @@
 #define ESDHC_VENDORSPEC_VSELECT 0x00000002 /* Use 1.8V */
 
 struct fsl_esdhc_cfg {
-	phys_addr_t esdhc_base;
+	union
+	{
+		phys_addr_t esdhc_base;
+		struct fsl_esdhc *esdhc_regs;
+	};
 	u32	sdhc_clk;
-	u8	max_bus_width;
+	u8	bus_width;
 	u8	wp_enable;
-	struct mmc_config cfg;
+	u16	gp_cd;
+	u16	gp_reset;
+#define CFG_FORCE_1P8V	BIT(0)
+	u16	flags;
 };
 
 /* Select the correct accessors depending on endianess */
diff -Nru u-boot-2017.07/include/i2c.h u-boot-imx6/include/i2c.h
--- u-boot-2017.07/include/i2c.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/i2c.h	2018-08-27 21:35:37.827467499 +0300
@@ -616,6 +616,7 @@
 		 _set_speed, _speed, _slaveaddr, _hwadapnr, _name);
 
 struct i2c_adapter *i2c_get_adapter(int index);
+struct i2c_adapter *i2c_get_adapter_valid(int index);
 
 #ifndef CONFIG_SYS_I2C_DIRECT_BUS
 struct i2c_mux {
@@ -642,7 +643,7 @@
 #endif
 #define	I2C_BUS			gd->cur_i2c_bus
 
-#define	I2C_ADAP_NR(bus)	i2c_get_adapter(I2C_ADAPTER(bus))
+#define	I2C_ADAP_NR(bus)	i2c_get_adapter_valid(bus)
 #define	I2C_ADAP		I2C_ADAP_NR(gd->cur_i2c_bus)
 #define I2C_ADAP_HWNR		(I2C_ADAP->hwadapnr)
 
diff -Nru u-boot-2017.07/include/ipu_pixfmt.h u-boot-imx6/include/ipu_pixfmt.h
--- u-boot-2017.07/include/ipu_pixfmt.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/ipu_pixfmt.h	2018-08-27 21:35:37.827467499 +0300
@@ -32,6 +32,7 @@
 #define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*<  8  RGB-3-3-2    */
 #define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*< 16  RGB-5-5-5    */
 #define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_UPS051  fourcc('U', 'P', 'S', '0')	/*< 24  RG BR GB, 1.5 clks/pixel   */
 #define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*< 18  RGB-6-6-6    */
 #define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*< 18  BGR-6-6-6    */
 #define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*< 24  BGR-8-8-8    */
@@ -63,6 +64,7 @@
 int ipuv3_fb_init(struct fb_videomode const *mode,
 		  uint8_t disp,
 		  uint32_t pixfmt);
+void *ipuv3_fb_init2(void);
 void ipuv3_fb_shutdown(void);
 
 #endif
diff -Nru u-boot-2017.07/include/linux/fb.h u-boot-imx6/include/linux/fb.h
--- u-boot-2017.07/include/linux/fb.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/linux/fb.h	2018-08-27 21:35:37.830800817 +0300
@@ -79,6 +79,7 @@
 					/* vtotal = 144d/288n/576i => PAL  */
 					/* vtotal = 121d/242n/484i => NTSC */
 #define FB_SYNC_ON_GREEN	32	/* sync on green */
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
 
 #define FB_VMODE_NONINTERLACED	0	/* non interlaced */
 #define FB_VMODE_INTERLACED	1	/* interlaced	*/
diff -Nru u-boot-2017.07/include/net.h u-boot-imx6/include/net.h
--- u-boot-2017.07/include/net.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/net.h	2018-08-27 21:35:37.840800769 +0300
@@ -308,7 +308,7 @@
 	u8		et_dest[ARP_HLEN];	/* Destination node	*/
 	u8		et_src[ARP_HLEN];	/* Source node		*/
 	u16		et_protlen;		/* Protocol or length	*/
-};
+} __attribute__((packed));
 
 /* Ethernet header size */
 #define ETHER_HDR_SIZE	(sizeof(struct ethernet_hdr))
@@ -326,7 +326,7 @@
 	u8		et_snap2;
 	u8		et_snap3;
 	u16		et_prot;		/* 802 protocol		*/
-};
+} __attribute__((packed));
 
 /* 802 + SNAP + ethernet header size */
 #define E802_HDR_SIZE	(sizeof(struct e802_hdr))
@@ -340,7 +340,7 @@
 	u16		vet_vlan_type;		/* PROT_VLAN		*/
 	u16		vet_tag;		/* TAG of VLAN		*/
 	u16		vet_type;		/* protocol type	*/
-};
+} __attribute__((packed));
 
 /* VLAN Ethernet header size */
 #define VLAN_ETHER_HDR_SIZE	(sizeof(struct vlan_ethernet_hdr))
@@ -369,7 +369,7 @@
 	u16		ip_sum;		/* checksum			*/
 	struct in_addr	ip_src;		/* Source IP address		*/
 	struct in_addr	ip_dst;		/* Destination IP address	*/
-};
+} __attribute__((packed));
 
 #define IP_OFFS		0x1fff /* ip offset *= 8 */
 #define IP_FLAGS	0xe000 /* first 3 bits */
@@ -397,7 +397,7 @@
 	u16		udp_dst;	/* UDP destination port		*/
 	u16		udp_len;	/* Length of UDP packet		*/
 	u16		udp_xsum;	/* Checksum			*/
-};
+} __attribute__((packed));
 
 #define IP_UDP_HDR_SIZE		(sizeof(struct ip_udp_hdr))
 #define UDP_HDR_SIZE		(IP_UDP_HDR_SIZE - IP_HDR_SIZE)
@@ -435,7 +435,7 @@
 	u8		ar_tha[];	/* Target hardware address	*/
 	u8		ar_tpa[];	/* Target protocol address	*/
 #endif /* 0 */
-};
+} __attribute__((packed));
 
 #define ARP_HDR_SIZE	(8+20)		/* Size assuming ethernet	*/
 
@@ -470,7 +470,7 @@
 		} frag;
 		u8 data[0];
 	} un;
-};
+} __attribute__((packed));
 
 #define ICMP_HDR_SIZE		(sizeof(struct icmp_hdr))
 #define IP_ICMP_HDR_SIZE	(IP_HDR_SIZE + ICMP_HDR_SIZE)
diff -Nru u-boot-2017.07/include/spi_flash.h u-boot-imx6/include/spi_flash.h
--- u-boot-2017.07/include/spi_flash.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/spi_flash.h	2018-08-27 21:35:37.847467405 +0300
@@ -84,6 +84,11 @@
 	u8 write_cmd;
 	u8 dummy_byte;
 
+	u8 status_cmd;
+	u8 status_ready_mask;
+	u8 status_ready_level;
+	u8 spare1;
+
 	void *memory_map;
 
 	int (*flash_lock)(struct spi_flash *flash, u32 ofs, size_t len);
diff -Nru u-boot-2017.07/include/stdio_dev.h u-boot-imx6/include/stdio_dev.h
--- u-boot-2017.07/include/stdio_dev.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/include/stdio_dev.h	2018-08-27 21:35:37.847467405 +0300
@@ -113,6 +113,8 @@
 #endif
 #if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)
 int	drv_video_init (void);
+struct graphic_device;
+int	drv_video_init2(struct graphic_device *fb);
 #endif
 #ifdef CONFIG_KEYBOARD
 int	drv_keyboard_init (void);
diff -Nru u-boot-2017.07/make_boundary u-boot-imx6/make_boundary
--- u-boot-2017.07/make_boundary	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/make_boundary	2018-08-27 21:35:37.870800627 +0300
@@ -0,0 +1,32 @@
+savedir=../u-boot-images
+mkdir -p $savedir
+rm $savedir/*
+boards=$(cd configs && grep -l DEFCONFIG * | sed 's/_defconfig.*$//');
+cpus=`grep -c '^processor' /proc/cpuinfo` ;
+jobs=`expr $cpus + 2` ;
+numboards=0;
+numsuccess=0;
+numfailures=0;
+for board in $boards ; do
+    if [ $board != "mx6qsabrelite" ] ; then
+	make distclean ; make ${board}_defconfig
+	make all -j $jobs
+	if [ $? -ne 0 ]; then
+		numfailures=`expr $numfailures + 1`;
+		echo -e "\n\n\n!!!!!!!! build failure for $board !!!!!!!!!!!!\n\n";
+		read line;
+	else
+	        cp -fv u-boot.imx $savedir/u-boot.${board};
+	        ls -l $savedir/u-boot.${board};
+		numsuccess=`expr $numsuccess + 1`;
+	fi
+	defcfg=$(sed -n -e's/.\{1,\}DEFCONFIG=\\"\(.\{1,\}\)\\""/\1/p' configs/${board}_defconfig)
+	if [ "$defcfg" != "$board" ] ; then
+		echo -e "\n\n\n!!!!!!!! $board does not match $defcfg !!!!!!!!!!!!\n\n";
+		read line;
+	fi
+	numboards=`expr $numboards + 1`;
+    fi
+done
+make distclean ;
+echo -e "\n\n\nbuilt for ${numboards} boards. ${numsuccess} succeeded and ${numfailures} failed";
diff -Nru u-boot-2017.07/make_cfg.sh u-boot-imx6/make_cfg.sh
--- u-boot-2017.07/make_cfg.sh	1970-01-01 03:00:00.000000000 +0300
+++ u-boot-imx6/make_cfg.sh	2018-08-27 21:35:37.870800627 +0300
@@ -0,0 +1,35 @@
+savedir=../u-boot-images
+mkdir -p $savedir
+rm $savedir/*
+boards=$(cd configs && grep -l DEFCONFIG * | sed 's/_defconfig.*$//');
+cpus=`grep -c '^processor' /proc/cpuinfo` ;
+jobs=`expr $cpus + 2` ;
+numboards=0;
+numsuccess=0;
+numfailures=0;
+dd if=/dev/zero of=test.bin bs=4096 count=1
+for board in $boards ; do
+    if [ $board != "mx6qsabrelite" ] ; then
+	make distclean ; make ${board}_defconfig
+	cfgfile=$(sed -n -e's/.\{1,\}IMX_CONFIG=\([^,]\{1,\}\),.*$/\1/p' configs/${board}_defconfig)
+	make include/autoconf.mk
+
+	arm-linux-gnueabihf-gcc -E  \
+	 -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/5/include -Iinclude   \
+	 -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__    \
+	 -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  \
+	 -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  \
+	 -msoft-float   -pipe  -march=armv7-a -D__LINUX_ARM_ARCH__=7    \
+	 -x c -o test.cfgtmp $cfgfile
+
+	mkimage -n test.cfgtmp -T imximage -e 0x17800000 -d test.bin test.imx
+	od -Ax -tx4 --endian=big test.imx >$savedir/${board}.txt
+
+	if [ -e  $savedir/${board}.txt ] ; then
+		numsuccess=`expr $numsuccess + 1`;
+	fi
+	numboards=`expr $numboards + 1`;
+    fi
+done
+make distclean ;
+echo -e "\n\n\nbuilt for ${numboards} boards. ${numsuccess} succeeded and ${numfailures} failed";
diff -Nru u-boot-2017.07/net/bootp.h u-boot-imx6/net/bootp.h
--- u-boot-2017.07/net/bootp.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/net/bootp.h	2018-08-27 21:35:37.870800627 +0300
@@ -49,7 +49,7 @@
 	char		bp_sname[64];	/* Server host name		*/
 	char		bp_file[128];	/* Boot file name		*/
 	char		bp_vend[OPT_FIELD_SIZE]; /* Vendor information	*/
-};
+} __attribute__((packed));
 
 #define BOOTP_HDR_SIZE	sizeof(struct bootp_hdr)
 
diff -Nru u-boot-2017.07/net/dns.h u-boot-imx6/net/dns.h
--- u-boot-2017.07/net/dns.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/net/dns.h	2018-08-27 21:35:37.870800627 +0300
@@ -29,7 +29,7 @@
 	uint16_t	nauth;		/* Authority PRs */
 	uint16_t	nother;		/* Other PRs */
 	unsigned char	data[1];	/* Data, variable length */
-};
+} __attribute__((packed));
 
 void dns_start(void);		/* Begin DNS */
 
diff -Nru u-boot-2017.07/net/nfs.h u-boot-imx6/net/nfs.h
--- u-boot-2017.07/net/nfs.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/net/nfs.h	2018-08-27 21:35:37.874133944 +0300
@@ -79,7 +79,7 @@
 			uint32_t data[NFS_READ_SIZE];
 		} reply;
 	} u;
-};
+} __attribute__((packed));
 void nfs_start(void);	/* Begin NFS */
 
 
diff -Nru u-boot-2017.07/net/sntp.h u-boot-imx6/net/sntp.h
--- u-boot-2017.07/net/sntp.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/net/sntp.h	2018-08-27 21:35:37.874133944 +0300
@@ -51,7 +51,7 @@
 	unsigned long long originate_timestamp;
 	unsigned long long receive_timestamp;
 	unsigned long long transmit_timestamp;
-};
+} __attribute__((packed));
 
 void sntp_start(void);	/* Begin SNTP */
 
diff -Nru u-boot-2017.07/scripts/config_whitelist.txt u-boot-imx6/scripts/config_whitelist.txt
--- u-boot-2017.07/scripts/config_whitelist.txt	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/scripts/config_whitelist.txt	2018-08-27 21:35:37.880800579 +0300
@@ -185,6 +185,7 @@
 CONFIG_BOARD_REVISION_TAG
 CONFIG_BOARD_SIZE_LIMIT
 CONFIG_BOARD_TAURUS
+CONFIG_BOARD_TYPE
 CONFIG_BOARD_TYPES
 CONFIG_BOOGER
 CONFIG_BOOM
@@ -296,6 +297,7 @@
 CONFIG_CMDLINE_EDITING
 CONFIG_CMDLINE_PS_SUPPORT
 CONFIG_CMDLINE_TAG
+CONFIG_CMD_FBPANEL
 CONFIG_CMD_MAX6957
 CONFIG_CMD_MEM
 CONFIG_CMD_MFSL
@@ -477,6 +479,7 @@
 CONFIG_DEFAULT_SPI_BUS
 CONFIG_DEFAULT_SPI_CS
 CONFIG_DEFAULT_SPI_MODE
+CONFIG_DEFCONFIG
 CONFIG_DEF_HWCONFIG
 CONFIG_DELAY_ENVIRONMENT
 CONFIG_DESIGNWARE_ETH
@@ -758,6 +761,7 @@
 CONFIG_FEATURE_SH_STANDALONE_SHELL
 CONFIG_FEC_ENET_DEV
 CONFIG_FEC_FIXED_SPEED
+CONFIG_FEC_MAC_FUSE
 CONFIG_FEC_MXC_25M_REF_CLK
 CONFIG_FEC_MXC_PHYADDR
 CONFIG_FEC_MXC_SWAP_PACKET
@@ -924,6 +928,7 @@
 CONFIG_GPIO_ENABLE_SPI_FLASH
 CONFIG_GPIO_LED_INVERTED_TABLE
 CONFIG_GPIO_LED_STUBS
+CONFIG_GREEN_HIGH
 CONFIG_GREEN_LED
 CONFIG_GURNARD_FPGA
 CONFIG_GURNARD_SPLASH
@@ -1590,6 +1595,7 @@
 CONFIG_MX35_HCLK_FREQ
 CONFIG_MX6DL_LPDDR2
 CONFIG_MX6DQ_LPDDR2
+CONFIG_MX6QP
 CONFIG_MX6SX_SABRESD_REVA
 CONFIG_MX6UL_14X14_EVK_EMMC_REWORK
 CONFIG_MXC_EPDC
@@ -1600,6 +1606,7 @@
 CONFIG_MXC_NAND_IP_REGS_BASE
 CONFIG_MXC_NAND_REGS_BASE
 CONFIG_MXC_SPI
+CONFIG_MXC_SPI_DISPLAY
 CONFIG_MXC_UART_BASE
 CONFIG_MXC_USB_FLAGS
 CONFIG_MXC_USB_PORT
@@ -1666,6 +1673,7 @@
 CONFIG_NFSBOOTCOMMAND
 CONFIG_NFS_READ_SIZE
 CONFIG_NFS_TIMEOUT
+CONFIG_NITROGEN6X_FL
 CONFIG_NOBQFMAN
 CONFIG_NON_SECURE
 CONFIG_NORBOOT
@@ -1939,15 +1947,19 @@
 CONFIG_RESERVED_03_BASE
 CONFIG_RESERVED_04_BASE
 CONFIG_RESET
+CONFIG_RESET_CAUSE_ADDR
 CONFIG_RESET_PHY_R
 CONFIG_RESET_TO_RETRY
 CONFIG_RESET_VECTOR_ADDRESS
 CONFIG_RESTORE_FLASH
 CONFIG_RES_BLOCK_SIZE
 CONFIG_REV1
+CONFIG_REV2
 CONFIG_REV3
 CONFIG_REVISION_TAG
 CONFIG_RFSPART
+CONFIG_RGMII1
+CONFIG_RGMII2
 CONFIG_RIO
 CONFIG_RMII
 CONFIG_RMOBILE_BOARD_STRING
@@ -2423,6 +2435,7 @@
 CONFIG_SYS_APP2_SIZE
 CONFIG_SYS_ARCH_TIMER
 CONFIG_SYS_ARM_CACHE_WRITETHROUGH
+CONFIG_SYS_ARM_PODF
 CONFIG_SYS_AT91_CPU_NAME
 CONFIG_SYS_AT91_MAIN_CLOCK
 CONFIG_SYS_AT91_PLLA
@@ -2488,6 +2501,7 @@
 CONFIG_SYS_BOOTPARAMS_LEN
 CONFIG_SYS_BOOTSZ
 CONFIG_SYS_BOOT_BLOCK
+CONFIG_SYS_BOOT_BOARD_POWER_CHECK
 CONFIG_SYS_BOOT_GET_CMDLINE
 CONFIG_SYS_BOOT_GET_KBD
 CONFIG_SYS_BOOT_RAMDISK_HIGH
@@ -3212,6 +3226,7 @@
 CONFIG_SYS_FSL_ESDHC_BE
 CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
 CONFIG_SYS_FSL_ESDHC_FORCE_VSELECT
+CONFIG_SYS_FSL_ESDHC_GPIO_WP
 CONFIG_SYS_FSL_ESDHC_HAS_DDR_MODE
 CONFIG_SYS_FSL_ESDHC_LE
 CONFIG_SYS_FSL_ESDHC_NUM
@@ -5249,6 +5264,7 @@
 CONFIG_VIDEO_MXS_MODE_SYSTEM
 CONFIG_VIDEO_OMAP3
 CONFIG_VIDEO_ONBOARD
+CONFIG_VIDEO_SKIP_VERSION
 CONFIG_VIDEO_SM501_PCI
 CONFIG_VIDEO_STD_TIMINGS
 CONFIG_VIDEO_SUNXI
diff -Nru u-boot-2017.07/tools/imximage.h u-boot-imx6/tools/imximage.h
--- u-boot-2017.07/tools/imximage.h	2017-07-10 20:07:38.000000000 +0300
+++ u-boot-imx6/tools/imximage.h	2018-08-27 21:35:37.904133802 +0300
@@ -2,6 +2,8 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -27,10 +29,18 @@
 #define FLASH_OFFSET_NAND	FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_SD		FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_SPI	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_SATA	FLASH_OFFSET_STANDARD
+
+#ifdef CONFIG_IMX_FIXED_IVT_OFFSET
+#define FLASH_OFFSET_ONENAND	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_NOR	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_QSPI	FLASH_OFFSET_STANDARD
+#else
 #define FLASH_OFFSET_ONENAND	0x100
 #define FLASH_OFFSET_NOR	0x1000
 #define FLASH_OFFSET_SATA	FLASH_OFFSET_STANDARD
 #define FLASH_OFFSET_QSPI	0x1000
+#endif
 
 /* Initial Load Region Size */
 #define FLASH_LOADSIZE_UNDEFINED	0xFFFFFFFF
